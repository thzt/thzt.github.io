<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Closure and Object</title>

		<meta name="description" content="">
		<meta name="author" content="thzt">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="../css/reveal.css">
		<link rel="stylesheet" href="../css/theme/black.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="../lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? '../css/print/pdf.css' : '../css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
		
		<!--[if lt IE 9]>
		<script src="../lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				
				<section>
					<section data-markdown>
						## 闭包与对象
						
						——何幻						
					</section>
				</section>
				
				
				
				<section>
					<section data-markdown>
						## 简洁之道
						
						Programming languages should be designed not by piling feature on top of feature, 
						but by removing the weaknesses and restrictions that make additional features appear necessary.
						
						编程语言不应该设计为特性的堆积，而应该设法避免缺陷和减少限制，只增加必要的东西。
						
						——《RnRS》
						
					  	<!--trick: make script>pre>code show correctly.-->
						<pre><code data-trim class="scheme"></code></pre>
					</section>
					
					<section data-markdown>
						## 面向对象与函数式编程
						
						面向对象编程，提供了“类”，用来生成独立的对象，避免了不必要的信息共享。
						它使用继承，复用了实现。使用多态，复用了接口。
						
						函数式编程，给我们提供了另外一种视角，
						它使用高阶函数，抽象了运算模式。使用闭包，封装了状态。
					</section>
					
					<section data-markdown>
						## 状态的封装
						
						面向对象与函数式编程，采用了不同的方法。
						
						它们之间有什么关联呢？
					</section>
				</section>
				
				
				
				<section>
					<section data-markdown>
						## 1. 函数
						
						在Scheme语言中，函数是基本的单元，
						我们用它可以做各种各样的事情。
					</section>
					<section data-markdown>
						<script type="text/template">
							## 1. 函数
							
							定义
							<pre><code data-trim class="scheme">
(define add
	(lambda (x y)
		(+ x y)))
							</code></pre>
							便捷的写法
							<pre><code data-trim class="scheme">
(define (add x y)
	(+ x y))
							</code></pre>
							调用
							<pre><code data-trim class="scheme">
(add 1 2)
=> 3
							</code></pre>
						</script>
					</section>
				</section>
				
				
				
				<section>
					<section data-markdown>
						## 2. 高阶函数
						
						Scheme语言的函数，是first-class的，
						函数可以作为其他函数的参数，或者返回值。
					</section>
					<section data-markdown>
						<script type="text/template">
							## 2. 高阶函数
							
							定义
							<pre><code data-trim class="scheme">
(define high-order-fn
	(lambda (fn x y)
		(fn x y)))
							</code></pre>
							
							调用
							<pre><code data-trim class="scheme">
(high-order-fn + 1 2)
=> 3
							</code></pre>
						</script>
					</section>
				</section>
				
				
				
				<section>
					<section data-markdown>
						## 3. 环境
						
						Scheme语言的变量是具有词法作用域的，
						函数体在函数定义时的环境中求值。
					</section>
					<section data-markdown>
						<script type="text/template">
							## 3. 环境 (1/3)
							
							定义一个函数
							<pre><code data-trim class="scheme">
(define add
	(lambda (x y)
		(+ x y)))
							</code></pre>
							add定义处的环境
							<pre><code data-trim class="scheme">
(;env
	[;frame
		(add #&lt;procedure&gt;)
	]
)
							</code></pre>
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							## 3. 环境 (2/3)
							
							调用函数						
							<pre><code data-trim class="scheme">
(add 1 2)
							</code></pre>
							进入add函数后的环境
							<pre><code data-trim class="scheme">
(;env
	[;frame
		(x 1)
		(y 2)
	] 
	[;frame
		(add #&lt;procedure&gt;)
	]
)
							</code></pre>
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							## 3. 环境 (3/3)
							
							在这个环境中求值函数体
							<pre><code data-trim class="scheme">
(+ x y)
=> 3
							</code></pre>
							最终结果
							<pre><code data-trim class="scheme">
(add 1 2)
=> 3
							</code></pre>
						</script>
					</section>
				</section>
				
				
				
				<section>
					<section data-markdown>
						## 4. 闭包
						
						因为函数可以访问外层变量，
						而这个外层变量，是定义时决定的。
						运行时，无法增加新的函数来访问这个变量。
						
						这构成了一种封闭状态。					
					</section>
					<section data-markdown>
						<script type="text/template">
							## 4. 闭包 (1/4)
							
							定义一个可以访问外层变量的函数
							<pre><code data-trim class="scheme">
(define add1
	(let ((x 1))
		(lambda (y)
			(+ x y))))
							</code></pre>
							
							top-level环境
							<pre><code data-trim class="scheme">
(
	[(add1 #&lt;procedure&gt;)]
)
							</code></pre>
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							## 4. 闭包 (2/4)
							
							add1定义处的环境
							<pre><code data-trim class="scheme">
(
	[(x 1)]
	[(add1 #&lt;procedure&gt;)]
)
							</code></pre>
							
							调用add1
							<pre><code data-trim class="scheme">
(add1 2)
							</code></pre>
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							## 4. 闭包 (3/4)
							
							扩展add1定义时的环境
							<pre><code data-trim class="scheme">
(
	[(y 2)]
	[(x 1)]
	[(add #&lt;procedure&gt;)]
)
							</code></pre>
							
							在这个环境中求值add1函数体
							<pre><code data-trim class="scheme">
(+ x y)
=> 3
							</code></pre>
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							## 4. 闭包 (4/4)
							
							结果
							<pre><code data-trim class="scheme">
(add1 2)
=> 3
							</code></pre>
						</script>
					</section>
				</section>
				
				
				
				<section>
					<section data-markdown>
						## 5. 状态
						
						如果一个词法变量，只有固定的几个函数可以访问它，
						那么这些函数共享了变量的状态。
					</section>
					<section data-markdown>
						<script type="text/template">
							## 5. 状态
							
							定义一个计数器
							<pre><code data-trim class="scheme">
(define counter
	(let ((n 0))
		(lambda ()
			(set! n (+ n 1))
			n)))
							</code></pre>
							调用
							<pre><code data-trim class="scheme">
(counter)
=> 1

(counter)
=> 2
							</code></pre>
						</script>
					</section>
				</section>
				
				
				
				<section>
					<section data-markdown>
						## 6. 类和对象
						
						Java是一种面向对象的语言，
						它使用类来创建对象，
						这些对象都是互相隔离的，有各自的状态。
					</section>
					<section data-markdown>
						<script type="text/template">
							## 6. 类和对象 (1/2)
							
							Java中定义一个类
							<pre><code data-trim class="java">
public class Counter(){
	private int n = 0;

	public int next(){
		return ++n;
	}
}
							</code></pre>
							
							调用
							<pre><code data-trim class="java">
Counter counter = new Counter();

counter.next(); => 1
counter.next(); => 2
							</code></pre>
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							## 6. 类和对象 (2/2)
							
							生成闭包的函数
							<pre><code data-trim class="scheme">
(define create-counter
	(lambda ()
		(let ((n 0))
			(lambda ()
				(set! n (+ n 1))
				n))))
							</code></pre>
							
							调用
							<pre><code data-trim class="scheme">
(define counter
	(create-counter))
	
(counter) => 1
(counter) => 2
							</code></pre>
						</script>
					</section>
				</section>
				
				
				
				<section>
					<section data-markdown>
						## 7. 类的静态变量
						
						在Java中，类的静态变量是由类的多个实例共享的。
					</section>
					<section data-markdown>
						<script type="text/template">
							## 7. 类的静态变量 (1/4)
							
							一个包含静态变量的类
							<pre><code data-trim class="java">
public class Counter(){	
	private static int x = 0;
	private int n = 0;
	
	public int next(){
		x+=10; 
		n+=1;
		return x+n;
	}
}
							</code></pre>
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							## 7. 类的静态变量 (2/4)
							
							调用
							<pre><code data-trim class="java">
Counter counter1 = new Counter();
Counter counter2 = new Counter();

counter1.next();
=> 11

counter2.next(); 
=> 21

							</code></pre>
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							## 7. 类的静态变量 (3/4)
							
							共享变量
							<pre><code data-trim class="scheme">
(define create-counter
	(let ((x 0))
		(lambda ()
			(let ((n 0))
				(lambda ()
					(set! x (+ x 10))
					(set! n (+ n 1))
					(+ x n))))))
							</code></pre>
							
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							## 7. 类的静态变量 (4/4)
							
							调用
							<pre><code data-trim class="scheme">
(define counter1
	(create-counter)

(define counter2
	(create-counter)
	
(counter1)
=> 11
	
(counter2)
=> 21
							</code></pre>
						</script>
					</section>
				</section>
				
				
				
				<section>
					<section data-markdown>
						## 8. 对比
						
						我们来对比一下Scheme闭包和Java对象的关系。
					</section>
					<section data-markdown>
						<script type="text/template">
							## 8. 对比 (1/3)
							
							闭包与对象
							<pre><code data-trim class="scheme">
(let ((n 0))
	(lambda ()
		(set! n (+ n 1))
		n))
							</code></pre>
							
							<pre><code data-trim class="java">
Counter counter = new Counter();
							</code></pre>
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							## 8. 对比 (2/3)
							
							闭包工厂与类
							<pre><code data-trim class="scheme">
(lambda ()
	(let ((n 0))
		(lambda ()
			(set! n (+ n 1))
			n)))
							</code></pre>
							
							<pre><code data-trim class="java">
public class Counter(){
	private int n = 0;
	
	public int next(){
		return ++n;
	}
}
							</code></pre>
						</script>
					</section>
					<section data-markdown>
						<script type="text/template">
							## 8. 对比 (3/3)
							
							共享变量与类的静态变量
							<pre><code data-trim class="scheme">
(let ((x 0))
	(lambda ()
		(let ((n 0))
			(lambda ()
				(set! x (+ x 10))
				(set! n (+ n 1))
				(+ x n)))))
							</code></pre>
							
							<pre><code data-trim class="java">
public class Counter(){
	private int n = 0;
	private static int x = 0;
	public int next(){
		x+=10; n+=1;
		return x+n;
	}
}
							</code></pre>
						</script>
					</section>
				</section>
				
				<section data-markdown>
					<script type="text/template">
						##结语
						
						我们发现了闭包和对象之间，具有高度的概念一致性。
						
						闭包不是目的，它是手段。
						
						面向对象不是目的，它也是手段。
						
						长视者把目的当手段，短视者把手段当目的。
					</script>
				</section>

			</div>

		</div>

		<script src="../lib/js/head.min.js"></script>
		<script src="../js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: '../lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: '../plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '../plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: '../plugin/zoom-js/zoom.js', async: true },
					{ src: '../plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
