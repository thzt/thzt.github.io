<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[何幻]]></title>
  <link href="https://thzt.github.io/atom.xml" rel="self"/>
  <link href="https://thzt.github.io/"/>
  <updated>2016-01-28T10:56:18+08:00</updated>
  <id>https://thzt.github.io/</id>
  <author>
    <name><![CDATA[thzt]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[多做不如少做，不做不如去做]]></title>
    <link href="https://thzt.github.io/blog/2016/01/26/less-is-more/"/>
    <updated>2016-01-26T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/01/26/less-is-more</id>
    <content type="html"><![CDATA[<p>喜欢忙碌并不是勤奋。——塞内加</p>

<p><br/></p>

<p>在生活节奏日益加快的今天，</p>

<p>忙碌似乎已经成了普遍现象了，</p>

<p>大家急匆匆的做这个，</p>

<p>忙着做那个，口里说着<strong>没时间</strong>。</p>

<p><br/></p>

<p>且不说对自身的影响，</p>

<p><strong>我们这么忙，真的对要做的事情有益吗</strong>？</p>

<p><br/></p>

<p>有人说，</p>

<p>初级人才，完成任务。</p>

<p>中级人才，解决问题。</p>

<p>高级人才，<strong>带来价值</strong>。</p>

<p><br/></p>

<p>我十分同意这种说法。</p>

<p><br/></p>

<p>上帝安排我们来到这个世界上，</p>

<p>是希望我们有自己的活法，</p>

<p>给世界带来不同。</p>

<p><br/></p>

<p>公司雇佣我们，</p>

<p>是因为我们数十年的人生积累，</p>

<p>可以帮助公司为客户带来价值，</p>

<p>而不是仅仅忙起来这么简单。</p>

<p><br/></p>

<p>相似的，</p>

<p>程序员应该把自己定位成解决方案的提供者，</p>

<p>而不是帮助别人实现想法的人。</p>

<p><br/></p>

<p><strong>带来更大价值的事情是思考</strong>，</p>

<p>要有成效，而不是忙碌起来。</p>

<p><br/></p>

<h2>有效的思考时间</h2>

<p>如果回顾一下的话，</p>

<p>每天中，我们的有效思考时间，</p>

<p>实际上只占很少一部分，</p>

<p><strong>可能只有短短几秒钟</strong>。</p>

<p><br/></p>

<p>那么，我们经过这么多年的，</p>

<p>科学教育，人生阅历，挑灯苦读，</p>

<p>都白白浪费了。</p>

<p><br/></p>

<p>事实上，<strong>多思考才对得起别人支付的薪水</strong>，</p>

<p>否则，为什么请我们来做这件事情呢？</p>

<p>好吧，我们其实并不是那么重要。</p>

<p>不过，要先有这个自信。</p>

<p><br/></p>

<p>如果我们做的事情，</p>

<p>当初不必努力学习，现在就可以做，</p>

<p>那对企业来说就是资源浪费，</p>

<p>也可能我们并不适合这个地方。</p>

<p><br/></p>

<p>因此，要<strong>尽可能的延长自己每天中的有效思考时间</strong>，</p>

<p>这些通过思考而得来的结论，是我们的王牌，</p>

<p>也是我们唯一的价值所在。</p>

<p><br/></p>

<p>与此同时，也不要走到另一个极端。</p>

<p><strong>空想没有任何好处</strong>，</p>

<p>还必须为自己的想法给出实现，</p>

<p>落到实处。</p>

<p><br/></p>

<p>所以，我们一定是在实现自己的想法，</p>

<p>而不是别人的想法。</p>

<p><br/></p>

<p>想法也必须由自己实现，</p>

<p>才可以得到最直接的反馈，</p>

<p>做出<strong>快速的调整</strong>。</p>

<p><br/></p>

<h2>学会拒绝</h2>

<p>一个人的底线是什么，</p>

<p>他在社会中对外界的表现就是什么。</p>

<p><br/></p>

<p>无论他能力超群，</p>

<p>还是技高一筹，</p>

<p>或者出类拔萃，</p>

<p>这些都没有用。</p>

<p><br/></p>

<p><strong>同别人合作时</strong>，</p>

<p><strong>迟早会迫使退回自己的底线</strong>，</p>

<p>无法完全施展。</p>

<p><br/></p>

<p>所以说，在现实项目中，</p>

<p>一个程序员的代码好坏，</p>

<p>不止取决于自身的编码水平，</p>

<p>还取决于他的底线。</p>

<p><br/></p>

<p>没有不紧的工期，</p>

<p>没有资源足够的工程，</p>

<p>如果一个程序员不坚守底线，哪怕水平再高，</p>

<p>也只能编写劣质的软件。</p>

<p><br/></p>

<p>因为，实际安排工作的人，</p>

<p>并不会面面俱到，亲自落实每一件事情，</p>

<p>总会有一个折衷处理。</p>

<p><br/></p>

<p>学会拒绝吧。</p>

<p><br/></p>

<p>压力是我们自己造成的，</p>

<p>除了吃饭睡觉之外，</p>

<p>再<strong>没有不得不做的事情</strong>了。</p>

<p><br/></p>

<p>拒绝，还可以让安排工作的人清晰的认识到，</p>

<p>他<strong>对资源的可控程度</strong>。</p>

<p><br/></p>

<p>很简单，<strong>要想有时间，那就少做点事情</strong>。</p>

<p>如果可以多做，</p>

<p>就不会考虑怎样在少做的情况下，</p>

<p>达到相同的效果了。</p>

<p><br/></p>

<p>人们都会多做，很忙，</p>

<p>然而对<strong>结果</strong>可能并没有什么帮助。</p>

<p><br/></p>

<h2>勇气</h2>

<p>勇者，气也。</p>

<p>气之所至，力亦至焉。</p>

<p><strong>心</strong>之所至，气乃至焉。</p>

<p><br/></p>

<p>首先要有想法去做某件事情，</p>

<p>又很想把它做好，才会有勇气。</p>

<p><br/></p>

<p>如果说从多做到少做，是第一步，</p>

<p>从少做到不做，是第二步，</p>

<p>那么从不做到<strong>去做</strong>，就是第三步了。</p>

<p><br/></p>

<p>在选择不做的前提下，</p>

<p>在仔细分析了后果的条件下，</p>

<p>我们要<strong>勇于做一些自认为正确的事情</strong>。</p>

<p><br/></p>

<p>对于所有的事情而言，</p>

<p>如果不主动说出来，就没有人会理解，</p>

<p>如果没有人开始，就不可能继续下去。</p>

<p><br/></p>

<p>没有勇气的人，</p>

<p>对社会没有价值，</p>

<p>对他人没有帮助。</p>

<p><br/></p>

<p><strong>有拈叶飞花都可以伤人的武功，却消极逃避</strong>，</p>

<p><strong>不如，一把钝剑，勇于济世</strong>。</p>

<p><br/></p>

<h2>结语</h2>

<p>如果心脏病发作了，</p>

<p>每天只能工作4个小时，</p>

<p>我们会怎样工作？</p>

<p><br/></p>

<p>怎么可能每天的工作，都恰好8个小时可以做完？</p>

<p><br/></p>

<p>人生不是通过加速就可以体味到更多。——莫罕达斯·甘地</p>

<p>忙碌的人忙于任何事情，除了生活。——塞内加</p>

<p><br/></p>

<p>参考：</p>

<p>《<a href="http://book.douban.com/subject/10786476/">每周工作4小时</a>》</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件开发的节奏]]></title>
    <link href="https://thzt.github.io/blog/2016/01/21/the-rhythm-of-the-development/"/>
    <updated>2016-01-21T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/01/21/the-rhythm-of-the-development</id>
    <content type="html"><![CDATA[<p>有时候，在软件项目的巨大压力下，</p>

<p>我们会不由自主的做出，违反<strong>自然规律</strong>的事情。</p>

<p><br/></p>

<p>短期来看，确实受益了，</p>

<p>然而，长期看来，无异于<strong>揠苗助长</strong>，</p>

<p>流毒无穷。</p>

<p><br/></p>

<p>人们以为，</p>

<p>软件行业中，<strong>加班</strong>是家常便饭，</p>

<p>但实际上，这是管理上缺陷。</p>

<p><br/></p>

<p>处于底层的程序员们，无力涉足管理，</p>

<p>但也可以认真想一想，<strong>如何高效的加班</strong>。</p>

<p><br/></p>

<p>我们先从几个角度来看看加班这件事吧。</p>

<p><br/></p>

<h2>从收支上看加班</h2>

<p>长期加班并不是一件好事，</p>

<p>因为，它增加了投入。</p>

<p><br/></p>

<p>这还不好吗？</p>

<p>其实不然。</p>

<p><br/></p>

<p>因为一件事情的<strong>代价</strong>，</p>

<p>在很大程度上，影响了我们的<strong>决策</strong>。</p>

<p><br/></p>

<p>如果在计划阶段，</p>

<p>认为不加班可以做完，</p>

<p>最后结果是加班做完的。</p>

<p><br/></p>

<p>这只能说明我们低估了成本，</p>

<p>那么做这件事情就可能不是那么值得了。</p>

<p><br/></p>

<p>因此，<strong>加班会影响我们去评判某一选择的正确性</strong>，</p>

<p><strong>还会让我们继续做出错误的决定</strong>。</p>

<p><br/></p>

<h2>从工作性质上看加班</h2>

<p>短期加班，是很有效果的，</p>

<p>但是，人不能不休息，</p>

<p>软件工程师也不能不重新思考自己的设计。</p>

<p><br/></p>

<p>加班会迫使人们把工作赶出来，</p>

<p>那么任何有创造力的事情都将被错过。</p>

<p><br/></p>

<p>而且，代码质量会变差，</p>

<p><strong>添加新功能的成本也会越来也大</strong>。</p>

<p><br/></p>

<p>经常发生的事情是，</p>

<p>本来很简单的一个功能，因为有历史原因，</p>

<p>才不得不使用复杂的实现方案。</p>

<p><br/></p>

<p>加班会让这件事更频繁的发生。</p>

<p><br/></p>

<h2>从工作总量上看加班</h2>

<p>短期内，工作总量是会增加的，</p>

<p>因为前几天人们都不累，</p>

<p>延长了工作时间，代码总量肯定是会增加的。</p>

<p><br/></p>

<p>然而，长期加班会导致人们效率下降，</p>

<p>在明知道要加班的情况下，</p>

<p>会更有意识的降低自己的工作效率，</p>

<p>反正要加班嘛。</p>

<p><br/></p>

<p>因此，工作总量不增反降。</p>

<p><br/></p>

<p>另外，人是不可能违背自然规律的，</p>

<p><strong>没有必要用第二天一整天的无精打采</strong>，</p>

<p><strong>来换取今天几个小时的加班</strong>。</p>

<p><br/></p>

<p>只是改变了生物钟，</p>

<p>没有什么意义呀。</p>

<p><br/></p>

<p>而且，代码多一定不是好事，</p>

<p><strong>错的越多，要改的就越多</strong>。</p>

<p><br/></p>

<h2>从软件工程来看加班</h2>

<p>如果去饭店吃饭，</p>

<p>厨师说做一个鱼香肉丝要10分钟，</p>

<p>我们再急，也不会要求厨师5分钟把它做出来，</p>

<p>让他加班也没用。</p>

<p><br/></p>

<p>一个女人，必须经过10月怀胎，</p>

<p>才能生下小孩，</p>

<p>肯定不会有人强迫她5个月就生下来，</p>

<p>让她加班，给她加人手也没用。</p>

<p><br/></p>

<p>经验表明，</p>

<p><strong>有些事情经历的时间是不可压缩的</strong>。</p>

<p><br/></p>

<p>因此可以说，</p>

<p>当工期足够短的情况下，</p>

<p>加再多的人也是徒劳的。</p>

<p><br/></p>

<p>这时候，我们应该努力反思了，</p>

<p><strong>为什么我们要做那么多的事</strong>，</p>

<p><strong>却还剩下了这么少的时间</strong>？</p>

<p><br/></p>

<h2>工程师的价值</h2>

<p>以上的分析不少了，</p>

<p>我相信如果有领导看到这里，</p>

<p>还是想让你加班，那就是故意的了。</p>

<p><br/></p>

<p>在不可抗拒的情况下，</p>

<p>底层程序员们，实际上应该考虑，</p>

<p><strong>高效加班的办法</strong>。</p>

<p><br/></p>

<p>因为，只有我们明白软件，</p>

<p>知道它的生命周期，</p>

<p>了解它的特性，</p>

<p>更知道怎么做好它。</p>

<p><br/></p>

<p>我们在工期紧的情况下，</p>

<p>最应该做的事情就是，</p>

<p><strong>管理好自己的时间，调节好工作状态</strong>。</p>

<p><br/></p>

<p>用正确的姿势走好每一步。</p>

<p><br/></p>

<h2>保持节奏</h2>

<p>无论外界有多么大的压力，</p>

<p>我们都要<strong>保持自己的节奏</strong>。</p>

<p><br/></p>

<p>这不但是对自己负责，</p>

<p>也是从专业的角度对项目负责。</p>

<p><br/></p>

<p><strong>我们只有保持节奏的产出</strong>，</p>

<p><strong>才能帮助项目成功</strong>。</p>

<p><br/></p>

<p>不能为了速度一味的牺牲质量，</p>

<p>也不能因为洁癖，减缓前进的步伐。</p>

<p><br/></p>

<p>其实，更多情况下，我们是自乱阵脚。</p>

<p><br/></p>

<p>别人不了解软件，让我们精疲力尽，让项目走向失败，</p>

<p>如果就听之任之的话，那就只能怪我们自己了。</p>

<p><br/></p>

<p><strong>身为一名软件工程师</strong>，</p>

<p><strong>没有努力把项目调整到正确的轨道</strong>，</p>

<p><strong>而是选择傻傻的加班</strong>。</p>

<p><br/></p>

<p><strong>我觉得，这才是团队的悲哀</strong>。</p>

<p><br/></p>

<h2>结语</h2>

<p>再多的加班，</p>

<p>也比不上想人们在主观上想把它做好。</p>

<p><br/></p>

<p>可惜，可惜。</p>

<p><br/></p>

<p>欲将心事付瑶筝，</p>

<p>知音少，弦断有谁听？</p>

<p>——《小重山》岳飞</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第四重境界]]></title>
    <link href="https://thzt.github.io/blog/2016/01/18/the-fourth-level/"/>
    <updated>2016-01-18T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/01/18/the-fourth-level</id>
    <content type="html"><![CDATA[<p>人们对事物的认知，具有螺旋上升的特点，</p>

<p>与其说质变改变了现状，</p>

<p>倒不如说，<strong>质变让我们重新回到了历史上的今天</strong>。</p>

<p><br/></p>

<p>佛家有人生三重境界的说法：</p>

<p>看山是山，看水是水；</p>

<p>看山不是山，看水不是水；</p>

<p>看山还是山，看水还是水。</p>

<p><br/></p>

<p>一个人的外在表现，也具有这样的特点。</p>

<p><br/></p>

<p>新手，朴实无华；</p>

<p>熟手，锋芒毕露；</p>

<p>高手，含蓄内敛。</p>

<p><br/></p>

<p>新手们，天真无邪，</p>

<p>没有一点让人感到不快的地方，</p>

<p><strong>然而却不能委以重任</strong>。</p>

<p><br/></p>

<p>熟手门，展示着自己的才华，</p>

<p>哪怕你不想看，他们也在证明自己，</p>

<p><strong>让人不太放心</strong>。</p>

<p><br/></p>

<p>高手们，没办法探出真实水平，</p>

<p>他们说不会的，可能只是不想说罢了，</p>

<p><strong>指望不上</strong>。</p>

<p><br/></p>

<p>这些都不是我们所向往的。</p>

<p><br/></p>

<p>西游记中提起过，</p>

<p>小乘佛法，渡己；</p>

<p>大乘佛法，渡人。</p>

<p><br/></p>

<p><strong>自己的境界再高，也比不上对别人一点小小的帮助</strong>。</p>

<p>因此，高手的境界还远远不够，</p>

<p>还需要向第四重境界努力。</p>

<p><br/></p>

<p>我们回顾历史，</p>

<p>古今中外的那些伟人们，</p>

<p>他们的事迹为什么能够流传到今天？</p>

<p><br/></p>

<p>是因为他们做出了有巨大影响力的事情。</p>

<p>他们并没有隐瞒实力，</p>

<p>而是<strong>做出改变</strong>。</p>

<p><br/></p>

<p>看到满目苍夷的世界，</p>

<p>心中有一片美好的蓝图，</p>

<p>并逐步的实现它。</p>

<p><br/></p>

<p>只有这样，才能成为领袖，才有追随者，</p>

<p>自发的汇聚一些志同道合的人们，</p>

<p>让世界变得更好。</p>

<p><br/></p>

<p><strong>改变自己容易，改变别人太难</strong>。</p>

<p><strong>适应环境容易，改变环境太难</strong>。</p>

<p><br/></p>

<p>不但自身要有压倒性的实力优势，</p>

<p>而且还要有号召力，领导力，人格魅力。</p>

<p><br/></p>

<p>不能锋芒毕露，因为会失去朋友，</p>

<p>也不能含蓄内敛，因为被动注定失败。</p>

<p><br/></p>

<p>需要把自己的想法说出来，</p>

<p>需要沟通和演讲，需要分享和交流。</p>

<p><br/></p>

<p>既要有看山是看，看水是水的<strong>成熟心态</strong>，</p>

<p>也要有看山不是山，看水不是水的<strong>洞察力</strong>。</p>

<p><br/></p>

<p>这就是人生的第四重境界了吧。</p>

<p><br/></p>

<p>我们应该努力学习，同时戒骄戒躁，</p>

<p>不能愤世嫉俗，还不能消极避世。</p>

<p><br/></p>

<p>把大智若愚放下，把大巧若拙收起来。</p>

<p><br/></p>

<p><strong>是时候该出招了吧，勇士们</strong>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hask范畴上的Monad]]></title>
    <link href="https://thzt.github.io/blog/2016/01/11/monad-in-hask-category/"/>
    <updated>2016-01-11T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/01/11/monad-in-hask-category</id>
    <content type="html"><![CDATA[<p>范畴论是一个迷人的领域，</p>

<p>它是一门研究<strong>数学结构</strong>以及<strong>结构之间关系</strong>的理论。</p>

<p><br/></p>

<p>不知道我们学群论时，</p>

<p>是否感觉到了群同态与集合间映射的相似性。</p>

<p>学拓扑学时，</p>

<p>是否感觉到了连续映射与微分流形间光滑映射的相似性。</p>

<p><br/></p>

<p>范畴论统一了这些相似结构。</p>

<p>然而，这还要从抽象代数说起。</p>

<p><br/></p>

<h2>幺半群（monoid）</h2>

<p>在抽象代数中，<strong>幺半群</strong>是这样定义的。</p>

<p><br/></p>

<p>集合S和S上满足结合律的封闭二元运算"•"，</p>

<p>所形成的代数结构称为<strong>半群</strong>，记为(S, •)，简记为S</p>

<p><br/></p>

<p>设S是半群，元素e∈S，称为半群S的<strong>幺元素</strong>，</p>

<p>如果对于每一个x∈S，有xe=ex=x</p>

<p><br/></p>

<p>如果半群S有幺元素e，则它是唯一的。</p>

<p>含有幺元素的半群称为<strong>幺半群</strong>。</p>

<p><br/></p>

<p>注：</p>

<p>半群G如果有幺元素，且每个元素均可逆，</p>

<p>则称G为<strong>群</strong></p>

<p><br/></p>

<h2>图示法（diagram）</h2>

<p>一个幺半群M，可以描述为一个集合M，和两个函数</p>

<p>µ : M × M -> M</p>

<p>η : 1 -> M</p>

<p><br/></p>

<p>其中，1 = {0}是只有一个元素的集合。</p>

<p><br/></p>

<pre>           1 × µ<br>M × M × M -------&gt; M × M<br>    |                |<br>    | µ × 1          | µ<br>    |                |<br>    v                v<br>  M × M   -------&gt;   M<br>             µ</pre>




<pre>        η × 1          1 × η<br>1 × M -------&gt; M × M &lt; ------- M × 1<br>  |              |               |<br>  | α            | µ             | β<br>  |              |               |<br>  v              v               v<br>  M      =       M        =      M</pre>


<p><br/></p>

<p>用元素来表示图表，可以写为，</p>

<p><br/></p>

<pre>&lt;x,y,z&gt; |-------&gt;    &lt;x,yz&gt;<br>   -                   -<br>   |                   |<br>   |                   |<br>   v                   v<br>&lt;xy,z&gt;  |-------&gt; (xy)z=x(yz)</pre>




<pre>&lt;0,x&gt; |-------&gt; &lt;e,x&gt;    &lt;x,e&gt; &lt;-------| &lt;x,0&gt;<br>  -               -        -               -<br>  |               |        |               |<br>  |               |        |               |<br>  v               v        v               v<br>  x       =      ex       xe       =       x</pre>


<p><br/></p>

<p>可以看出，(xy)z=x(yz)表示了群乘法的结合律，</p>

<p>x=ex,xe=x表示了幺元e，因此图表展示了幺半群的结构。</p>

<p><br/></p>

<h2>范畴（category）</h2>

<p>一个<strong>范畴</strong>C由一系列<strong>对象</strong>（object）和<strong>箭头</strong>（arrow）组成。</p>

<p>对于每一个箭头f，有两个对象与之关联，</p>

<p>称为箭头f的定义域（domain）和值域（codomain）。</p>

<p>并且，满足以下几条规则，</p>

<p>（1）对于每一个对象a，存在恒等箭头（identity arrow），i:a->a</p>

<p>（2）箭头满足结合律，对于任意的箭头f,g,h有(f•g)•h=f•(g•h)</p>

<p>（3）箭头的集合在箭头组合运算下是封闭的</p>

<p><br/></p>

<p>注：</p>

<p>f•g表示g和f的组合运算，它也是一个箭头，其中g的值域是f的定义域</p>

<p><br/></p>

<p>例：</p>

<p>所有的集合，以集合作为对象，集合间的映射作为箭头，构成了一个范畴，</p>

<p>所有的群，以群作为对象，群同态作为箭头，构成了一个范畴，</p>

<p>所有的拓扑空间，以拓扑空间作为对象，拓扑空间之间的连续映射为箭头，构成了一个范畴，</p>

<p>所有的微分流形，以微分流形作为对象，流形间的光滑映射为箭头，构成了一个范畴，</p>

<p>Haskell中，以类型作为对象（类型是值的集合），函数作为箭头，构成了一个范畴（<strong>Hask范畴</strong>）。</p>

<p><br/></p>

<h2>函子（functor）</h2>

<p>如果把范畴看做对象，则函子可以看做箭头。</p>

<p><br/></p>

<p>一个<strong>函子</strong>F是范畴C到范畴D的箭头，F:C -> D，</p>

<p>它满足以下条件，</p>

<p>F把C中的对象c映射为D中的对象F c，把C中的箭头f映射为D中的箭头F f。</p>

<p>且满足分配律，F (f•g)=(F f)•(F g)</p>

<p><br/></p>

<p>注：</p>

<p>等式左边的"•"表示C中的箭头组合运算，</p>

<p>等式右边的"•"表示D中的箭头组合运算。</p>

<p><br/></p>

<p>范畴C到自身的函子，称为<strong>自函子</strong>（endofunctor）。</p>

<p><br/></p>

<p>Hask范畴的自函子把Haskell中的类型a映射为另一个类型f a，</p>

<p>把类型a到类型b的函数，映射为类型f a到类型f b的函数。</p>

<p><br/></p>

<p>class Functor f where</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmap :: (a -> b) -> f a -> f b</p>

<p><br/></p>

<p>class Functor f => Applicative f where</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pure :: a -> f a</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;*>) :: f (a -> b) -> f a -> f b</p>

<p><br/></p>

<p>我们看到，pure和fmap放在一起，</p>

<p>构成了一个Hask范畴的自函子。</p>

<p><br/></p>

<h2>自然变换（natural transformation）</h2>

<p>如果把函子看做对象，则自然变换可以看做箭头。</p>

<p><br/></p>

<p>若F和G是范畴C到D的函子，则<strong>自然变换</strong>τ是一个箭头，τ: F -> G，</p>

<p>它满足以下条件，</p>

<p><br/></p>

<pre>     f<br>a -------&gt; b</pre>




<pre>      F f<br>F a -------&gt; F b<br>|            |<br>| τ a        | τ b<br>|            |<br>v            v<br>G a -------&gt; G b<br>      G f</pre>


<p><br/></p>

<p>注：</p>

<p>F a是D中与a对应的对象，F b是D中与b对应的对象，F f是D中与f对应的箭头</p>

<p><br/></p>

<h2>函子范畴（functor category）</h2>

<p>以范畴C到D的函子为对象，以函子间的自然变换为箭头，</p>

<p>构成了一个范畴，称为<strong>函子范畴</strong>。</p>

<p><br/></p>

<p>易知，自然变换可以进行组合运算，</p>

<p>设µ a : F a -> G a，η a : G a -> H a</p>

<p>则可以定义一个新的自然变换(η • µ) a = F a -> H a</p>

<p>可证自然变换的组合运算满足结合律。</p>

<p><br/></p>

<p>注：</p>

<p>函子范畴的对象，不是一个集合，</p>

<p>函子范畴的箭头，也不是映射。</p>

<p><br/></p>

<h2>Monad</h2>

<p>范畴C上的monad，是一个<strong>三元组</strong>(F,µ,η)，其中</p>

<p>F是范畴C上的自函子，</p>

<p>µ是F<sup>2</sup>到F的自然变换，µ:F<sup>2</sup>->F，</p>

<p>η是单位自函子I到F的自然变换，η:I->F</p>

<p><br/></p>

<p>且满足以下条件</p>

<p><br/></p>

<pre>           F • µ<br>F • F • F -------&gt; F • F<br>    |                |<br>    | µ • F          | µ<br>    |                |<br>    v                v<br>  F • F   -------&gt;   F<br>             µ</pre>




<pre>        η • F          F • η<br>I • F -------&gt; F • F &lt; ------- F • I<br>                 |                <br>  ||             | µ            ||<br>                 |               <br>                 v                <br>  F      =       F        =      F</pre>


<p><br/></p>

<p>在Haskell中可以这样表示：</p>

<p><br/></p>

<p>{- 自函子F，作用在对象上时 -}</p>

<p>fObj :: (Applicative f) => a -> f a</p>

<p>fObj = pure</p>

<p><br/></p>

<p>{- 自函子F，作用在箭头上时 -}</p>

<p>fArr :: (Applicative f) => (a -> b) -> (f a -> f b)</p>

<p>fArr = fmap</p>

<p><br/></p>

<p>{- 自函子F<sup>2</sup> -}</p>

<p><br/></p>

<p>f2Obj :: (Applicative f) => a -> f (f a)</p>

<p>f2Obj = fObj . fObj</p>

<p><br/></p>

<p>f2Arr :: (Applicative f) => (a -> b) -> (f (f a) -> f (f b))</p>

<p>f2Arr :: fArr . fArr</p>

<p><br/></p>

<p>{- 单位自函子，作用到对象上时 -}</p>

<p>iObj :: a -> a</p>

<p>iObj = id</p>

<p><br/></p>

<p>{- 单位自函子，作用到箭头上时 -}</p>

<p>iArr :: (a -> b) -> (a -> b)</p>

<p>iArr = id</p>

<p><br/></p>

<p>{- 自然变换µ:F<sup>2</sup>->F，（µ a:F<sup>2</sup> a->F a） -}</p>

<p>µ :: (Applicative f) => a -> f (f a) -> f a</p>

<p><br/></p>

<p>{- 自然变换η:I->F，（η a:I a->F a） -}</p>

<p>η :: (Applicative f) => a -> a -> (f a)</p>

<p><br/></p>

<h2>自函子范畴上的幺半群</h2>

<p>以范畴C上的自函子为对象，自然变换为箭头，</p>

<p>构成的函子范畴，称为<strong>自函子范畴</strong>。</p>

<p><br/></p>

<p>对比Monad定义中的自函子F与幺半群中的集合M，</p>

<p><br/></p>

<p><strong>结合律</strong>：</p>

<pre>           1 × µ<br>M × M × M -------&gt; M × M<br>    |                |<br>    | µ × 1          | µ<br>    |                |<br>    v                v<br>  M × M   -------&gt;   M<br>             µ</pre>




<pre>           F • µ<br>F • F • F -------&gt; F • F<br>    |                |<br>    | µ • F          | µ<br>    |                |<br>    v                v<br>  F • F   -------&gt;   F<br>             µ</pre>


<p><strong>幺元</strong>：</p>

<pre>        η × 1          1 × η<br>1 × M -------&gt; M × M &lt; ------- M × 1<br>  |              |               |<br>  | α            | µ             | β<br>  |              |               |<br>  v              v               v<br>  M      =       M        =      M</pre>




<pre>        η • F          F • η<br>I • F -------&gt; F • F &lt; ------- F • I<br>                 |                <br>  ||             | µ            ||<br>                 |               <br>                 v                <br>  F      =       F        =      F</pre>


<p><br/></p>

<p>可知，自函子F相当于群的集合M，自然变换µ相当于群乘法，单位自函子相当于幺元，它们构成了一个<strong>幺半群</strong>，</p>

<p>即<strong>Monad是Hask自函子范畴上的幺半群</strong>。</p>

<p><br/></p>

<p>注：</p>

<p>M × M × M表示集合M的笛卡尔积，</p>

<p>而F • F • F表示自函子F的组合。</p>

<p><br/></p>

<h2>幺半群范畴（monoidal category）</h2>

<p>幺半群在范畴论中是有了新的意义，</p>

<p>比群论中的概念更一般化。</p>

<p><br/></p>

<p>我们可以为范畴增加一个满足结合律的二元函子，</p>

<p>构成一个『范畴论意义上的』<strong>幺半群</strong>（monoid）。</p>

<p><br/></p>

<p>说一个范畴是具有幺半群结构的（monodial），</p>

<p>如果它有一个像笛卡尔积，或者直和，张量积，那样的『乘积』，</p>

<p>并且，这个『乘积』满足结合律，还有一个单位元。</p>

<p><br/></p>

<p>即，一个<strong>严格幺半群范畴</strong>（strict monoidal category）是范畴B上的一个结构&lt;B,□,e&gt;，</p>

<p>其中□是一个满足结合律的二元函子，□: B × B -> B，</p>

<p>□ (□ × 1) = □ (1 × □) : B × B × B -> B</p>

<p>而且存在对象e是二元函子□的单位元，</p>

<p>□ (e × 1) = id(B) = □ (1 × e)</p>

<p><br/></p>

<p>然后就可以在任意的幺半群范畴&lt;B,□,e&gt;中定义幺半群了。</p>

<p><br/></p>

<p>幺半群范畴B上的<strong>幺半群</strong>由三部分组成，&lt;c,µ,η&gt;，</p>

<p>其中c是B中的对象，µ : c □ c -> c，η : e -> c是范畴B中的箭头，</p>

<p>且满足以下条件</p>

<pre>               σ                  µ □ 1<br>c □ (c □ c) -------&gt; (c □ c) □ c -------&gt; c □ c<br>    |                                       |<br>    | 1 □ µ                                 | µ<br>    |                                       |<br>    v                                       v<br>  c □ c ----------------------------------&gt; c<br>                        µ</pre>




<pre>        η □ 1          1 □ η<br>e □ c -------&gt; c □ c &lt; ------- c □ e<br>  |              |               |<br>  | α            | µ             | β<br>  |              |               |<br>  v              v               v<br>  c      =       c        =      c</pre>


<p><br/></p>

<h2>结语</h2>

<p>『All told, a monad in X is just a monoid in the category of endofunctors of X,</p>

<p>with the product × replaced by composition of endofunctors</p>

<p>and unit set by the identity endofunctor.』</p>

<p><br/></p>

<p>一语成谶，很多人都是因为这句话入坑的，</p>

<p>然而理解它真的很不容易，</p>

<p>原来这个『幺半群』应该在范畴论意义上进行理解，</p>

<p>已经不是集合论基础上群论的内容了。</p>

<p><br/></p>

<p>在写这篇文章时，我甚至还没有入门，有错误在所难免，</p>

<p>但是多年坚持下来，似乎对这个问题有些眉目了，</p>

<p>于是就赶紧整理了一下，希望接下来以此为起点继续努力，勇往直前。</p>

<p><br/></p>

<p><strong>参考</strong>：</p>

<p>《<a href="http://book.douban.com/subject/4201293/">近世代数引论</a>》</p>

<p>《<a href="http://book.douban.com/subject/1823110/">Categories for the Working Mathematician 2nd</a>》</p>

<p><a href="https://medium.com/@brettwines/implementing-a-category-theoretic-hask-monad-in-haskell-7bf662f2e98b">Implementing a category-theoretic Hask-monad in Haskell</a></p>

<p><a href="http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem">A monad is just a monoid in the category of endofunctors, what&rsquo;s the problem?</a></p>

<p><a href="http://slides.com/julientournay/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-what-s-the-problem/fullscreen">A MONAD IS JUST A MONOID IN THE CATEGORY OF ENDOFUNCTORS. WHAT&rsquo;S THE PROBLEM ?</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[积极成长]]></title>
    <link href="https://thzt.github.io/blog/2015/12/22/grow-up-positively/"/>
    <updated>2015-12-22T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/12/22/grow-up-positively</id>
    <content type="html"><![CDATA[<p>飞机晚点了。</p>

<p><br/></p>

<p>正好趁这个机会，整理下思路，</p>

<p>这些天居然以技术人员的身份杀入到<strong>产品和需求的讨论</strong>中了，</p>

<p>真是一个挑战。</p>

<p><br/></p>

<p>对我来说，</p>

<p>之前看的一些软件工程，需求分析，产品设计的知识终于用上了。</p>

<p>即使这样，<strong>给我带来的改变是仍旧是巨大的</strong>。</p>

<p><br/></p>

<p>第一次因为公事出差，</p>

<p>第一次说这么多话，</p>

<p>第一次忙的没时间写代码。</p>

<p><br/></p>

<h2><strong>学会沟通</strong></h2>

<p>这些经历，让我理解到，</p>

<p><strong>一开始把自己定位成一个程序的编写者，</strong></p>

<p><strong>是多么的狭隘。</strong></p>

<p><br/></p>

<p>也让我认识到，</p>

<p><strong>软件工程师自称的不善言辞，</strong></p>

<p><strong>其实更多的是一种借口。</strong></p>

<p><br/></p>

<p>当我们不得不了解用户的问题，</p>

<p>当我们不得不修正根本不解决问题的解决方案时，</p>

<p>就<strong>必须学会沟通</strong>。</p>

<p><br/></p>

<h2><strong>以身试毒</strong></h2>

<p>语言是思想的交流媒介，不是思想本身，</p>

<p>因此，即使进行再多的交流，</p>

<p><strong>两个人的理解总是会有偏差的</strong>。</p>

<p><br/></p>

<p>业务人员不知道我们能为他们做到什么程度，</p>

<p>技术人员不知道我们是否真的解决了问题。</p>

<p>这些都是需要交流的。</p>

<p><br/></p>

<p>武侠小说中，</p>

<p>经常出现，神医为了解毒，以身试毒。</p>

<p>我现在觉得，<strong>这种胆略，才是真正想要解决问题的态度</strong>。</p>

<p><br/></p>

<h2><strong>我做的了</strong></h2>

<p>当客观条件不允许时，</p>

<p>达不到专业的标准，是情有可原的。</p>

<p>正如一个软件系统，</p>

<p>如果工期太短，那么<strong>短期内</strong>的质量低下是不可避免的。</p>

<p><br/></p>

<p>然而，当解决了用户的主要问题后，</p>

<p><strong>剩下大把的空闲时间，如果不努力提高品质，</strong></p>

<p><strong>就是主观原因了。</strong></p>

<p><br/></p>

<p>经历这次讨论，让我学到无论做什么事，</p>

<p>都应该用专业的标准要求自己。</p>

<p><strong>任何形式的『我做不了』，短期来看可原谅，长期来看就是慵懒。</strong></p>

<p><br/></p>

<p>成功者想办法，失败者找理由。</p>

<p><br/></p>

<h2><strong>先活下来</strong></h2>

<p>最后，让我理解到的是，</p>

<p><strong>软件必须首先能解决问题，能创造效益，</strong></p>

<p><strong>才有存活下来的可能。</strong></p>

<p><br/></p>

<p>一开始可能很丑陋，但是活下来了。</p>

<p>胜过一切漂亮的框架，优雅的结构。</p>

<p><br/></p>

<p>一方面，通过分析需求的优先级，</p>

<p>解决<strong>真正困扰用户的难题</strong>。</p>

<p>另一方面，用这仅有的争取得来的时间，</p>

<p>提高扩展性，以适应业务的发展。</p>

<p><br/></p>

<h2><strong>不要急躁</strong></h2>

<p>努力用最短的时间解决问题，是好样的，</p>

<p>然而，这并不能消除后期<strong>修正方案</strong>的可能性。</p>

<p><br/></p>

<p>尤其是沟通过程中，</p>

<p>这很重要，</p>

<p><strong>别人总是担心我们给他们看的就是最终的解决方案。</strong></p>

<p><br/></p>

<p>实际上，软件是活的，</p>

<p>事情是发展的，</p>

<p>业务场景，以及别人的理解也是变化的，</p>

<p>甚至市场氛围也是瞬息万变。</p>

<p><br/></p>

<p>我学会了<strong>着眼于程度</strong>，</p>

<p>而不是<strong>判断</strong>。</p>

<p><br/></p>

<p>如果没有完全解决，那么<strong>是否比昨天更好</strong>，</p>

<p>有没有进步。</p>

<p><br/></p>

<h2><strong>逐步调整</strong></h2>

<p>理想中，只要切题，我们的方案一出，</p>

<p>用户的问题，马上就能得到解决。</p>

<p>它是那么有效，那么一阵见血。</p>

<p><br/></p>

<p>然而，<strong>现实并不是这样的</strong>。</p>

<p><strong>能做出什么样的改变，完全取决于目前的项目状态。</strong></p>

<p><br/></p>

<p>我们想的很好，</p>

<p>然而，能做的，只是进行<strong>有限范围</strong>上的调整。</p>

<p><br/></p>

<p>要落到实处，方案就必须能和现有的系统接轨，</p>

<p>完全废弃一个系统是不可能的，</p>

<p>代价也太高了。</p>

<p><br/></p>

<p>此外，我们必须能够改善现状，</p>

<p>才能证明我们可以做的更好。</p>

<p><br/></p>

<p>把现在的事情做好，是证明自己能把其他事情做好的唯一办法。</p>

<p><br/></p>

<h2><strong>团队无价</strong></h2>

<p>随着年龄的增长，我发现个人的作用越来越小了，</p>

<p>因为，<strong>同龄人是其他行业专家的可能性越来越大</strong>。</p>

<p><br/></p>

<p>你在这个领域深入研究了10年，</p>

<p>另外一个人就完全有可能在其他领域深入研究了10年。</p>

<p>而从外表上是看，是无法区分的。</p>

<p><br/></p>

<p>这跟学生阶段是完全不同的，</p>

<p><strong>学生之间的差距更多的是同领域深入程度的差距</strong>。</p>

<p><br/></p>

<p>因此，为了把事情做好，</p>

<p><strong>我们需要各领域的专家一起交流</strong>，</p>

<p>这样的团队是无价的，一个人不可能面面俱到。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>飞机要起飞了。</p>

<p><br/></p>

<p>先总结到这里，继续努力。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[守住天赋]]></title>
    <link href="https://thzt.github.io/blog/2015/12/01/defend-the-advantage/"/>
    <updated>2015-12-01T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/12/01/defend-the-advantage</id>
    <content type="html"><![CDATA[<p>人们的智商其实都差不多，</p>

<p>谁能比谁笨呢，</p>

<p>但是每个人的<strong>天赋</strong>却各有不同。</p>

<p><br/></p>

<p>在自己有天赋的领域努力，</p>

<p>会成长迅猛，事半功倍，</p>

<p>收获到意想不到的成果。</p>

<p><br/></p>

<p>随着现代社会节奏的加快，</p>

<p>随着人们交流方式的进步发展，</p>

<p>我们更容易看到别人在做着什么了。</p>

<p><br/></p>

<p>有的人擅长这个，</p>

<p>有的人擅长那个，</p>

<p><strong>我们自己的呢？好像什么都很差。</strong></p>

<p><br/></p>

<p>这时候，我们该怎么办呢？</p>

<p>我们想努力，</p>

<p>可是努力的方向在哪呢？</p>

<p><br/></p>

<p><strong>不是我不努力，</strong></p>

<p><strong>而是我不知道该努力做什么。</strong></p>

<p><br/></p>

<h2><strong>保住优势</strong></h2>

<p>中学时代，我很偏科，</p>

<p>对于自己喜欢的课程，会不留余力的学习，</p>

<p>这就导致在考试时，有几门弱科丢分严重。</p>

<p><br/></p>

<p>班主任是一个喜欢开导人的好老师，</p>

<p>又一次谈到了偏科问题。</p>

<p>我不由得问到，</p>

<p><strong>我是不是该放弃某些强势科目的学习，</strong></p>

<p><strong>花时间把弱科补好？</strong></p>

<p><br/></p>

<p>班主任说，不要那么做。</p>

<p><strong>你应该保住优势，学到出类拔萃，</strong></p>

<p><strong>同时把弱科学到不是太弱就行了。</strong></p>

<p><br/></p>

<p>我瞬间觉得，事情简单多了，</p>

<p>对弱科我对自己有了<strong>不一样的要求</strong>了。</p>

<p><br/></p>

<p>没有弱科，<strong>别人就无法轻易击败我</strong>，</p>

<p>有强科，就能轻松的拿到高分。</p>

<p><br/></p>

<h2><strong>防守赢得冠军</strong></h2>

<p>学打篮球时，经常听到这样的说法，</p>

<p>进攻赢得比赛，防守赢得冠军。</p>

<p><br/></p>

<p>是说最终获胜的队伍，</p>

<p>靠的是坚不可摧的防守，</p>

<p>而不是犀利的进攻。</p>

<p><br/></p>

<p><strong>防守不好的话，就会很被动，疲于奔命。</strong></p>

<p><strong>只有防守不是那么弱，进攻方面才有发挥的余地。</strong></p>

<p><br/></p>

<p>个人懂得防守，可以坚定自己，</p>

<p>团队懂得防守，可以稳定自己，</p>

<p>公司懂得防守，可以稳固自己。</p>

<p><br/></p>

<p>总是被别人指使，</p>

<p>没有自己的<strong>灵魂</strong>，</p>

<p>是经不住风吹雨打的。</p>

<p><br/></p>

<h2><strong>建立自我意识</strong></h2>

<p>认识自己，是一件很难的事情，</p>

<p>拥有<strong>自我意识</strong>和<strong>独立的知识体系</strong>，</p>

<p>才能避免被碎片化的信息淹没。</p>

<p><br/></p>

<p>科技发展革新太快，</p>

<p>一看到什么火起来，</p>

<p>都会一窝蜂的跑过去。</p>

<p><br/></p>

<p>可悲的是，人们只看到了短期效益，</p>

<p>长远看来，却未必是好事。</p>

<p><strong>经常救火的会一直救火，</strong></p>

<p><strong>经常加班的会一直加班，</strong></p>

<p><strong>经常跟风的会一直跟风，</strong></p>

<p><strong>因为缺少自我意识。</strong></p>

<p><br/></p>

<p>有独立人格的人们，</p>

<p>会分析自己的优势和弱势，更加理智客观，</p>

<p><strong>明白自己需要什么，</strong></p>

<p><strong>有选择的接触新的知识。</strong></p>

<p><br/></p>

<p>只有根深蒂固，才能避免随波逐流，</p>

<p>才能产生自己的<strong>价值</strong>，而不是为浪潮贡献死水。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>学习，是一种<strong>进攻</strong>手段，</p>

<p>我们可以掠夺本来别人擅长的知识。</p>

<p>具有优秀的学习能力，是好事。</p>

<p><br/></p>

<p>然而，与此同时，</p>

<p>我们仍然<strong>不要忘记防守</strong>，</p>

<p><strong>要保住自己的天赋，不要方方面面平民化。</strong></p>

<p><br/></p>

<p>天赋是上天给予我们的礼物，</p>

<p>我们总会要拿来做一番事业的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[问题洁癖]]></title>
    <link href="https://thzt.github.io/blog/2015/11/25/fanatic-for-cleanliness-on-solving-problems/"/>
    <updated>2015-11-25T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/11/25/fanatic-for-cleanliness-on-solving-problems</id>
    <content type="html"><![CDATA[<p>我们遇到过大大小小的困难，</p>

<p>它们经常蜂拥而至，</p>

<p>我们很想把这些恼人的事情处理好，</p>

<p><strong>不想堵在这里</strong>。</p>

<p><br/></p>

<p>我们目光很敏锐，</p>

<p>似乎看到了别人发现不了的失误，</p>

<p>我们操碎了心想改善它，</p>

<p><strong>不想放任不管</strong>。</p>

<p><br/></p>

<p>我们想做一桩买卖，</p>

<p>因为明显有了一个好主意，且时间紧迫，</p>

<p>我们会<strong>不计成本，不惜代价</strong>，</p>

<p>也要赶出来。</p>

<p><br/></p>

<p>这一切是不是很熟悉？</p>

<p><br/></p>

<p>当我们遇到问题，受到压力时，</p>

<p>通常的反应是不择手段的，</p>

<p><strong>不够冷静</strong>，是失败的前兆。</p>

<p><br/></p>

<p>为什么会这样呢？</p>

<p>是因为我们有<strong>问题洁癖</strong>。</p>

<p><br/></p>

<h2><strong>冷静下来</strong></h2>

<p>保持冷静的唯一办法就是，</p>

<p><strong>做好准备</strong>。</p>

<p><br/></p>

<p>有些时候，事情比较多，</p>

<p>这是正常的，</p>

<p>不全是自己的原因。</p>

<p><br/></p>

<p>孙子兵法说：</p>

<p>打仗的原则是，不要寄希望于敌人不来，</p>

<p>而要依靠自己有充分准备，严阵以待；</p>

<p>不要寄希望于敌人不会进攻，</p>

<p>而要依靠自己有敌人不可攻破的条件。</p>

<p><br/></p>

<p>因此，要事先分析一下，</p>

<p>各种紧急态势的应对方案，</p>

<p><strong>有备而无患</strong>。</p>

<p><br/></p>

<h2><strong>考虑效益</strong></h2>

<p>不计成本，往往成本高昂。</p>

<p>不择手段，往往用的不是最佳的办法。</p>

<p><br/></p>

<p>在决定做一件事情的时候，</p>

<p>我们不得不考虑<strong>成本，风险和收益</strong>，</p>

<p>否则运转下去就难以维持了。</p>

<p><br/></p>

<p>在决定做一件事情的时候，</p>

<p>我们还不得不考虑<strong>价值</strong>，</p>

<p>解决了什么问题，对现状有没有改善，</p>

<p>这决定别人是否可以参与进来。</p>

<p><br/></p>

<p>有些问题，只有我们自己想把它解决，</p>

<p>却并不带来任何效益和价值，</p>

<p>那么这件事也只是为了解开自己的<strong>心结</strong>罢了。</p>

<p><br/></p>

<h2><strong>排优先级</strong></h2>

<p>另一个慌乱的原因是，</p>

<p>我们没有理清事情的优先级。</p>

<p>而强迫自己处理能力之外的事情，</p>

<p>显然是在<strong>冒险</strong>。</p>

<p><br/></p>

<p>因此，秉着对自己乃至别人负责的原则，</p>

<p>我们要<strong>专业的处理事情</strong>。</p>

<p>哪些问题是不重要的，</p>

<p>哪些问题事关生死存亡，</p>

<p>我们要心里清楚。</p>

<p><br/></p>

<p>事情是做不完的。</p>

<p>因此<strong>不要考虑怎样做完</strong>，</p>

<p><strong>而是要考虑做到什么程度</strong>。</p>

<p><br/></p>

<p>有了优先级，</p>

<p>我们就有了完成度的标准，</p>

<p>有了评判合格，良好，优秀的准绳。</p>

<p><br/></p>

<h2><strong>保持顺畅</strong></h2>

<p>问题洁癖，</p>

<p>意指那些<strong>急于解决一切问题的行为习惯</strong>。</p>

<p><br/></p>

<p>这是不专业的，</p>

<p>也是容易被事情驱动的，</p>

<p>每天的生活就是做任务，赶进度。</p>

<p><br/></p>

<p>优秀的商务人士，</p>

<p>总是会说，<strong>请把事情安排到我的日程中</strong>。</p>

<p>这是非常值得我们学习的地方。</p>

<p><br/></p>

<p>我们要保持顺畅，</p>

<p>但不是没有事情可做，</p>

<p>而是<strong>有条不紊的处理</strong>它们。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>越紧急就越慌张，</p>

<p>越急迫就越得不到。</p>

<p>这是人性的弱点。</p>

<p><br/></p>

<p>每个人都会有弱点，</p>

<p>不同的是，有的人可以<strong>控制</strong>它。</p>

<p>佛家的修行，就是管控能力的训练。</p>

<p><br/></p>

<p>能在不断涌现的琐事中<strong>保持心态平和</strong>，</p>

<p>就已然<strong>成功</strong>了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数理逻辑定义汇总]]></title>
    <link href="https://thzt.github.io/blog/2015/11/23/introduction-to-mathematical-logic/"/>
    <updated>2015-11-23T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/11/23/introduction-to-mathematical-logic</id>
    <content type="html"><![CDATA[<script src="https://thzt.github.io/thirdpart/jQuery/jquery-1.11.1.js"></script>


<p><link href="https://thzt.github.io/thirdpart/KaTeX/katex.min.css" rel="stylesheet"/></p>

<script src="https://thzt.github.io/thirdpart/KaTeX/katex.min.js"></script>


<script src="https://thzt.github.io/javascripts/katex.js"></script>


<p><strong>逻辑学</strong>真是博大精深，</p>

<p>first-order logic，propositional logic，predicate logic，</p>

<p>mathematical logic，second-order Logic，intuitionistic logic，</p>

<p>modal logic，free logic，plural logic&hellip;</p>

<p><br/></p>

<p>所涉及的内容也很广，</p>

<p>set theory，proof theory，model theory，recursion theory，</p>

<p>theory of computation，computability and decidability&hellip;</p>

<p><br/></p>

<p>学习它，对<strong>数学</strong>，<strong>计算机科学</strong>或其他学科都有指导意义。</p>

<p><br/></p>

<p>例如，哥德尔协调性定理指出了公理化方法的局限性，</p>

<p>它告诉我们，<strong>在理论上就不能通过逻辑推理解决所有的问题</strong>，</p>

<p>必要时，要通过构造模型来进行检验。</p>

<p>对软件进行测试，就是这样的一个例子。</p>

<p><br/></p>

<p>例如，<strong>类型系统</strong>，相当于加在程序语言语法层面上的(谓词)逻辑，</p>

<p>类型系统的<strong>可靠性</strong>保证了语法正确的程序，</p>

<p>语义上也是满足规范的。</p>

<p><br/></p>

<p>这样的例子还有很多，</p>

<p>实际工作中，只有<strong>见多识广</strong>，站在更高的角度，</p>

<p>才能做到庖丁解牛，<strong>游刃有余</strong>。</p>

<p><br/></p>

<p>到此，我们还是从一阶谓词逻辑开始，慢慢打好基础吧。</p>

<p>以下摘自《<a href="http://book.douban.com/subject/2364517/">数理逻辑</a>》——李未</p>

<p><br/></p>

<h2><strong>一阶语言的定义</strong></h2>

<p>每个一阶语言的字符集由两类符号集合组成。</p>

<p>一类称为逻辑符号集合，另一类称为非逻辑符号集合。</p>

<p><br/></p>

<p><strong>逻辑符号集合</strong>包括：</p>

<p><span data-katex="V"></span>：变元符号集合，<span data-katex="x_1, x_2, ..., x_n, ..."></span></p>

<p><span data-katex="C"></span>：逻辑连接词符号集合，<span data-katex="\neg , \wedge , \vee , \rightarrow , \leftrightarrow"></span></p>

<p><span data-katex="Q"></span>：量词符号集合，<span data-katex="\forall , \exists"></span></p>

<p><span data-katex="E"></span>：等词符号集合，<span data-katex="\doteq"></span></p>

<p><span data-katex="P"></span>：括号集合，<span data-katex="(, )"></span></p>

<p><br/></p>

<p><strong>非逻辑符号集合</strong>包括：</p>

<p><span data-katex="\mathscr{L}_c"></span>：常元符号集合，<span data-katex="c_1, c_2, ..."></span></p>

<p><span data-katex="\mathscr{L}_f"></span>：函数符号集合，<span data-katex="f_1, f_2, ..."></span></p>

<p><span data-katex="\mathscr{L}_P"></span>：谓词符号集合，<span data-katex="P_1, P_2, ..."></span></p>

<p><br/></p>

<p><strong>例子：</strong>初等算术语言<span data-katex="\mathscr{A}"></span></p>

<p>初等算术语言是一个一阶语言，</p>

<p>它的常元符号集为<span data-katex="\{0\}"></span>，</p>

<p>函数符号集为<span data-katex="\{S, +, \cdot \}"></span>，</p>

<p>谓词符号集合为<span data-katex="\{<\}"></span>。</p>

<p><br/></p>

<h2><strong>项</strong></h2>

<p>一阶语言<span data-katex="\mathscr{L}"></span>中的项被下述三个规则归纳的定义：</p>

<p><span data-katex="T_1"></span>：每一个常元是一个项</p>

<p><span data-katex="T_2"></span>：每一个变元是一个项</p>

<p><span data-katex="T_3"></span>：如果<span data-katex="t_1, ..., t_n"></span>是项，而f是一个n元函数符号，那么，<span data-katex="ft_1\cdot \cdot \cdot t_n"></span>是一个项</p>

<p><br/></p>

<p>此定义也可以表述成下述形式：</p>

<p><span data-katex="t ::= c | x | ft_1\cdot \cdot \cdot t_n"></span></p>

<p><br/></p>

<p><strong>例子：</strong><span data-katex="\mathscr{A}"></span>的项</p>

<p><span data-katex="S0, Sx_1, +S0SSx, \cdot x_1+Sx_1x_2"></span></p>

<p><br/></p>

<h2><strong>逻辑公式</strong></h2>

<p>语言<span data-katex="\mathscr{L}"></span>中的逻辑公式，简称<strong>公式</strong>，用大写字母<span data-katex="A, B, ..."></span>表示，并用下述五条规则归纳的定义：</p>

<p><br/></p>

<p><span data-katex="F_1"></span>：如果<span data-katex="t_1"></span>和<span data-katex="t_2"></span>为项，那么<span data-katex="t_1\doteq t_2"></span>是公式</p>

<p><span data-katex="F_2"></span>：如果<span data-katex="t_1, ..., t_n"></span>为项，而<span data-katex="R"></span>是一个n元谓词，那么<span data-katex="Rt_1\cdot \cdot \cdot t_n"></span>是公式</p>

<p><span data-katex="F_3"></span>：如果<span data-katex="A"></span>是公式，则<span data-katex="\neg A"></span>是公式</p>

<p><span data-katex="F_4"></span>：若<span data-katex="A, B"></span>是公式，则<span data-katex="A\wedge B, A\vee B, A\rightarrow B, A\leftrightarrow B"></span>都是公式</p>

<p><span data-katex="F_5"></span>：若<span data-katex="A"></span>是公式并且<span data-katex="x"></span>是一个变元，那么<span data-katex="\forall xA"></span>和<span data-katex="\exists xA"></span>也是公式，<span data-katex="x"></span>称为<strong>约束变元</strong></p>

<p><br/></p>

<p>上述结构归纳定义的Backus范式为：</p>

<p><span data-katex="A ::= t_1\doteq t_2 | Rt_1\cdot \cdot \cdot t_n | \neg A | A\wedge B | A\vee B | A\rightarrow B | A\leftrightarrow B | \forall xA | \exists xA"></span></p>

<p><br/></p>

<p><strong>例子：</strong><span data-katex="\mathscr{A}"></span>的公式</p>

<p><span data-katex="\forall x\neg (Sx\doteq 0), \forall x\forall y(< xy\rightarrow(\exists (y\doteq +xz)))"></span></p>

<p><br/></p>

<h2><strong><span data-katex="\mathscr{L}"></span>的结构</strong></h2>

<p>一阶语言<span data-katex="\mathscr{L}"></span>的<strong>结构</strong><span data-katex="M"></span>是一个偶对，记为<span data-katex="M=(\mathbb{M}, I)"></span>，其中，</p>

<p>（1）<span data-katex="\mathbb{M}"></span>是一个非空集合，称为<strong>论域</strong></p>

<p>（2）<span data-katex="I"></span>是从<span data-katex="\mathscr{L}"></span>到<span data-katex="\mathbb{M}"></span>的映射，称为<strong>解释</strong>，记为<span data-katex="I:\mathscr{L} \rightarrow \mathbb{M}"></span>，它满足下面三个条件</p>

<p>a) 对<span data-katex="\mathscr{L}"></span>中的每一个常元符号<span data-katex="c"></span>，<span data-katex="I(c)"></span>是<span data-katex="\mathbb{M}"></span>中的元素</p>

<p>b) 对<span data-katex="\mathscr{L}"></span>中的每一个n元函数符号<span data-katex="f"></span>，<span data-katex="I(f)"></span>是<span data-katex="\mathbb{M}"></span>上的n元函数</p>

<p>c) 对<span data-katex="\mathscr{L}"></span>中的每一个n元谓词符号<span data-katex="P"></span>，<span data-katex="I(P)"></span>是<span data-katex="\mathbb{M}"></span>上的一个n元关系</p>

<p><br/></p>

<p><strong>例子：</strong><span data-katex="\mathscr{A}"></span>的结构</p>

<p><span data-katex="\mathscr{A}"></span>的常元符号为<span data-katex="0"></span>，</p>

<p>函数符号有<span data-katex="\{S, +, \cdot \}"></span>，</p>

<p>谓词符号只有一个，它是<span data-katex="<"></span>。</p>

<p><br/></p>

<p>我们定义偶对<span data-katex="N=(\mathbb{N}, I)"></span>，其中论域<span data-katex="\mathbb{N}"></span>为自然数系。</p>

<p>令<span data-katex="s"></span>为<span data-katex="\mathbb{N}"></span>上的加1函数，即<span data-katex="s(x)=x+1"></span>，</p>

<p><span data-katex="+, \cdot"></span>代表<span data-katex="\mathbb{N}"></span>上的加法和乘法，</p>

<p><span data-katex="<"></span>为<span data-katex="\mathbb{N}"></span>上的小于关系。</p>

<p><br/></p>

<p>我们定义解释映射<span data-katex="I"></span>如下：</p>

<p><span data-katex="I(0)=0, I(S)=s, I(+)=+, I(\cdot )=\cdot , I(<)=<"></span></p>

<p><br/></p>

<p>解释映射<span data-katex="I"></span>将常元符号<span data-katex="0"></span>解释为自然数<span data-katex="0"></span>，</p>

<p>将一元函数符号<span data-katex="S"></span>解释为自然数集合上的加1运算<span data-katex="s"></span>，</p>

<p>将二元函数符号<span data-katex="+"></span>和<span data-katex="\cdot"></span>分别解释为自然数集合上的加法和乘法，</p>

<p>将二元谓词符号<span data-katex="<"></span>解释为自然数集合上的小于关系，</p>

<p>而<span data-katex="N"></span>是初等算术语言<span data-katex="\mathscr{A}"></span>的一个结构。</p>

<p><br/></p>

<h2><strong>赋值</strong></h2>

<p>赋值<span data-katex="\sigma"></span>是一个定义域为变元集合<span data-katex="V"></span>，值域为<span data-katex="\mathbb{M}"></span>的一个映射，记为<span data-katex="\sigma :V\rightarrow \mathbb{M}"></span>。</p>

<p>赋值<span data-katex="\sigma"></span>把<span data-katex="\mathscr{L}"></span>中的每一个变元<span data-katex="x"></span>，赋以论域<span data-katex="\mathbb{M}"></span>中的一个元素<span data-katex="a\in \mathbb{M}"></span>，</p>

<p>记为<span data-katex="\sigma (x)=a"></span>。</p>

<p><br/></p>

<h2><strong>模型</strong></h2>

<p>给定一阶语言<span data-katex="\mathscr{L}"></span>，以及它的结构<span data-katex="M"></span>和赋值<span data-katex="\sigma"></span>，</p>

<p>偶对<span data-katex="(M, \sigma )"></span>称为<span data-katex="\mathscr{L}"></span>的一个<strong>模型</strong>。</p>

<p><br/></p>

<h2><strong>项的语义</strong></h2>

<p>给定一阶语言<span data-katex="\mathscr{L}"></span>，结构<span data-katex="M=(\mathbb{M}, I)"></span>和赋值<span data-katex="\sigma :V\rightarrow \mathbb{M}"></span>。</p>

<p>在模型<span data-katex="(M, \sigma )"></span>下，项<span data-katex="t"></span>的语义是<span data-katex="\mathbb{M}"></span>中的一个元素，它用<span data-katex="t_{M[\sigma]}"></span>表示，并被归纳的定义：</p>

<p>（1）<span data-katex="x_{M[\sigma ]}=\sigma (x)"></span>，<span data-katex="x"></span>为变元符号</p>

<p>（2）<span data-katex="c_{M[\sigma ]}=c_M"></span>，<span data-katex="c"></span>为常元符号</p>

<p>（3）<span data-katex="(ft_1\cdot \cdot \cdot t_n)_{M[\sigma ]}=f_M((t_1)_{M[\sigma ]},\cdot \cdot \cdot (t_n)_{M[\sigma ]})"></span></p>

<p><br/></p>

<p><strong>例子：</strong><span data-katex="\mathscr{A}"></span>项的语义</p>

<p><span data-katex="(+x_1Sx_7)_{N[\sigma ]}=(x_1)_{N[\sigma ]}+(Sx_7)_{N[\sigma ]}=1+((x_7)_{N[\sigma ]}+1)=1+(7+1)=9"></span></p>

<p><br/></p>

<h2><strong>逻辑连接词符号的语义</strong></h2>

<p>为了避免逻辑连接词符号的多义性，我们把每一个逻辑连接词符号的语义都定义为一个真值函数，</p>

<p>此函数的定义域是一个真值集合或两个真值集合的笛卡尔积，而函数值是一个真假值。</p>

<p>对于一阶语言而言，逻辑连接词符号<span data-katex="\neg"></span>的真值函数为<span data-katex="B_\neg"></span>，</p>

<p>其自变量是<span data-katex="X"></span>，<span data-katex="X"></span>只能取<span data-katex="T"></span>和<span data-katex="F"></span>，</p>

<p>而函数值<span data-katex="B_\neg (X)"></span>由下述真值表定义：</p>

<p><span data-katex="B_\neg (T)=F, B_\neg (F)=T"></span></p>

<p><br/></p>

<p>二元函数<span data-katex="B_\wedge, B_\vee, B_\rightarrow, B_\leftrightarrow"></span>分别为逻辑连接词符号<span data-katex="\wedge, \vee, \rightarrow, \leftrightarrow"></span>的真值函数。</p>

<p><br/></p>

<h2><strong>公式的语义</strong></h2>

<p>设<span data-katex="M"></span>和<span data-katex="\sigma"></span>分别为一阶语言<span data-katex="\mathscr{L}"></span>的结构和赋值，而<span data-katex="A"></span>为<span data-katex="\mathscr{L}"></span>的公式。</p>

<p>公式<span data-katex="A"></span>在模型<span data-katex="(M, \sigma )"></span>下的语义是一个真假值，用<span data-katex="A_{M[\sigma ]}"></span>表示，被归纳的定义如下：</p>

<p>（1）<span data-katex="(Pt_1\cdot \cdot \cdot t_n)_{M[\sigma ]}=P_M((t_1)_{M[\sigma ]},\cdot \cdot \cdot ,(t_n)_{M[\sigma ]})"></span></p>

<p>（2）<span data-katex="(t_1\doteq t_2)_{M[\sigma ]}=\begin{cases}T,&\text{if }(t_1)_{M[\sigma ]}=(t_2)_{M[\sigma ]}\\F,&\text{otherwise}\end{cases}"></span></p>

<p>（3）<span data-katex="(\neg A)_{M[\sigma ]}=B_\neg (A_{M[\sigma ]})"></span></p>

<p>（4）<span data-katex="(A\vee B)_{M[\sigma ]}=B_\vee (A_{M[\sigma ]}, B_{M[\sigma ]})"></span></p>

<p>（5）<span data-katex="(A\wedge B)_{M[\sigma ]}=B_\wedge (A_{M[\sigma ]}, B_{M[\sigma ]})"></span></p>

<p>（6）<span data-katex="(A\rightarrow B)_{M[\sigma ]}=B_\rightarrow (A_{M[\sigma ]}, B_{M[\sigma ]})"></span></p>

<p>（7）<span data-katex="(A\leftrightarrow B)_{M[\sigma ]}=B_\leftrightarrow (A_{M[\sigma ]}, B_{M[\sigma ]})"></span></p>

<p>（8）<span data-katex="(\forall x_iA)_{M[\sigma ]}=\begin{cases}T,&\forall a\in M, A_{M[\sigma [x_i:=a]]}=T\\F,&\text{otherwise}\end{cases}"></span></p>

<p>（9）<span data-katex="(\exists x_iA)_{M[\sigma ]}=\begin{cases}T,&\exists a\in M, A_{M[\sigma [x_i:=a]]}=T\\F,&\text{otherwise}\end{cases}"></span></p>

<p><br/></p>

<h2><strong>可满足性</strong></h2>

<p>给定一阶语言<span data-katex="\mathscr{L}"></span>和它的公式<span data-katex="A"></span>以及公式集合<span data-katex="\Gamma"></span>。</p>

<p>如果存在模型<span data-katex="(M, \sigma )"></span>，使得<span data-katex="A_{M[\sigma ]}=T"></span>成立，</p>

<p>那么称公式<span data-katex="A"></span>关于模型<span data-katex="(M, \sigma )"></span>是<strong>可满足的</strong>，</p>

<p>简称<span data-katex="A"></span>可满足，也称为模型<span data-katex="(M, \sigma )"></span>满足<span data-katex="A"></span>，记为<span data-katex="M\models _\sigma A"></span>。</p>

<p>如果<span data-katex="A"></span>是一个语句，那么记为<span data-katex="A"></span>，记为<span data-katex="M\models A"></span></p>

<p><br/></p>

<p>如果<span data-katex="\Gamma"></span>中的每一个公式关于模型<span data-katex="(M, \sigma )"></span>都是可满足的，即，</p>

<p><span data-katex="M\models _\sigma A"></span>对于任意<span data-katex="A\in \Gamma"></span>成立，</p>

<p>那么称为公式集合<span data-katex="\Gamma"></span>关于模型<span data-katex="(M, \sigma )"></span>可满足，</p>

<p>简称公式集合<span data-katex="\Gamma"></span>可满足，</p>

<p>也称模型<span data-katex="(M, \sigma )"></span>满足公式集合<span data-katex="\Gamma"></span>，或<span data-katex="(M, \sigma )"></span>是<span data-katex="\Gamma"></span>的模型，记为<span data-katex="M\models _\sigma \Gamma"></span>。</p>

<p>如果<span data-katex="\Gamma"></span>是由语句组成的集合，那么记为<span data-katex="M\models \Gamma"></span>。</p>

<p><br/></p>

<h2><strong>永真性</strong></h2>

<p>称公式<span data-katex="A"></span>是<strong>永真的</strong>或有效的，如果<span data-katex="A"></span>对<span data-katex="\mathscr{L}"></span>的任意模型<span data-katex="(M, \sigma )"></span>均可满足，</p>

<p>即，对任意结构<span data-katex="M"></span>和赋值<span data-katex="\sigma"></span>，<span data-katex="M\models _\sigma A"></span>成立，记为<span data-katex="\models A"></span>。</p>

<p>称公式集合<span data-katex="\Gamma"></span>是永真的或有效的，如果<span data-katex="\Gamma"></span>中的每一个公式<span data-katex="A"></span>都是永真的，记为<span data-katex="\models \Gamma"></span></p>

<p>永真公式，也称为重言式，是与模型无关的公式，它们在任何模型下都为真。</p>

<p><br/></p>

<p><strong>例子：</strong>重言式</p>

<p><span data-katex="A\vee \neg A, \forall x(x\doteq x)"></span></p>

<p><br/></p>

<h2><strong>逻辑结论</strong></h2>

<p>设<span data-katex="A"></span>为公式，<span data-katex="\Gamma"></span>为公式集合，如果<span data-katex="M"></span>为任意结构，<span data-katex="\sigma"></span>为任意赋值，并且，</p>

<p>如果<span data-katex="M\models _\sigma \Gamma"></span>成立，则有<span data-katex="M\models _\sigma A"></span>成立，</p>

<p>那么称<span data-katex="A"></span>是<span data-katex="\Gamma"></span>的<strong>逻辑结论</strong>或语义结论，记为<span data-katex="\Gamma \models A"></span>，也称<span data-katex="\Gamma \models A"></span>有效。</p>

<p><br/></p>

<p><strong>注：</strong>符号<span data-katex="\models"></span>可以出现在4种不同类型的语义关系式中，它们是，</p>

<p><span data-katex="M\models _\sigma A, M\models A, \models A, \Gamma \models A"></span></p>

<p><span data-katex="\models"></span>在每种语义关系式中的含义不同，</p>

<p>区别这些关系式的简单办法是，</p>

<p>当<span data-katex="M"></span>和<span data-katex="\sigma"></span>同时出现时，表示此式仅对给定的<span data-katex="M"></span>和<span data-katex="\sigma"></span>成立，</p>

<p>当<span data-katex="\sigma"></span>不出现时，表示此式对任意<span data-katex="\sigma"></span>成立，</p>

<p>当<span data-katex="M"></span>及<span data-katex="\sigma"></span>均不出现时，表示此式对任意<span data-katex="M"></span>和任意<span data-katex="\sigma"></span>成立。</p>

<p><br/></p>

<p><span data-katex="\Gamma \models A"></span>也是一个语义关系式，它表示对任意<span data-katex="M"></span>和任意<span data-katex="\sigma"></span>，</p>

<p>如果<span data-katex="\Gamma"></span>为真，那么<span data-katex="A"></span>也为真。</p>

<p><br/></p>

<h2><strong>序贯</strong></h2>

<p>设<span data-katex="\Gamma ,\Delta"></span>为公式的有穷集合，<span data-katex="\Gamma \vdash \Delta"></span>称为<strong>序贯</strong>。</p>

<p><span data-katex="\Gamma"></span>称为序贯的前提，<span data-katex="\Delta"></span>称为序贯的结论。</p>

<p><br/></p>

<h2><strong>公理</strong></h2>

<p>设<span data-katex="\Gamma ,\Delta ,\Lambda ,\Theta"></span>为有穷公式集合，<span data-katex="A"></span>为公式，</p>

<p>则序贯<span data-katex="\Gamma ,A,\Delta \vdash \Lambda ,A,\Theta"></span>称为<strong>公理</strong>。</p>

<p><br/></p>

<p><strong>注：</strong>公理序贯之所以成立，是因为证明结论中至少有一个公式包含在公理序贯的前提之中。</p>

<p><br/></p>

<h2><strong>G推理系统</strong></h2>

<p>（1）<span data-katex="\neg"></span>规则</p>

<p><span data-katex="\neg -L:\frac{\Gamma ,\Delta \vdash A,\Lambda }{\Gamma ,\neg A,\Delta \vdash \Lambda}"></span></p>

<p><span data-katex="\neg -R:\frac{A,\Gamma \vdash \Lambda ,\Delta }{\Gamma \vdash \Lambda ,\neg A,\Delta }"></span></p>

<p>（2）<span data-katex="\vee"></span>规则</p>

<p><span data-katex="\vee -L:\frac{\Gamma ,A,\Delta \vdash \Lambda \quad \Gamma ,B,\Delta \vdash \Lambda }{\Gamma ,A\vee B,\Delta \vdash \Lambda }"></span></p>

<p><span data-katex="\vee -R:\frac{\Gamma \vdash \Lambda ,A,B,\Theta }{\Gamma \vdash \Lambda ,A\vee B,\Theta }"></span></p>

<p>（3）<span data-katex="\wedge"></span>规则</p>

<p><span data-katex="\wedge -L:\frac{\Gamma ,A,B,\Delta \vdash \Lambda }{\Gamma ,A\wedge B,\Delta \vdash \Lambda }"></span></p>

<p><span data-katex="\wedge -R:\frac{\Gamma \vdash \Lambda ,A,\Theta \quad \Gamma \vdash \Lambda ,B,\Theta }{\Gamma \vdash \Lambda ,A\wedge B,\Theta }"></span></p>

<p>（4）<span data-katex="\rightarrow"></span>规则</p>

<p><span data-katex="\rightarrow -L:\frac{\Gamma ,\Delta \vdash A,\Lambda \quad B,\Gamma ,\Delta \vdash \Lambda }{\Gamma ,A\rightarrow B,\Delta \vdash \Lambda }"></span></p>

<p><span data-katex="\rightarrow -R:\frac{A,\Gamma \vdash B,\Lambda ,\Theta }{\Gamma \vdash \Lambda ,A\rightarrow B,\Theta }"></span></p>

<p>（5）<span data-katex="\forall"></span>规则</p>

<p><span data-katex="\forall -L:\frac{\Gamma ,A[t/x],\forall xA(x),\Delta \vdash \Lambda }{\Gamma ,\forall xA(x),\Delta \vdash \Lambda }"></span></p>

<p><span data-katex="\forall -R:\frac{\Gamma \vdash \Lambda ,A[y/x],\Theta }{\Gamma \vdash \Lambda ,\forall xA(x),\Theta }"></span></p>

<p>（6）<span data-katex="\exists"></span>规则</p>

<p><span data-katex="\exists -L:\frac{\Gamma ,A[y/x],\Delta \vdash \Lambda }{\Gamma ,\exists xA(x),\Delta \vdash \Lambda }"></span></p>

<p><span data-katex="\exists -L:\frac{\Gamma ,A[y/x],\Delta \vdash \Lambda }{\Gamma ,\exists xA(x),\Delta \vdash \Lambda }"></span></p>

<p><br/></p>

<h2><strong>可靠性，紧致性，协调性，完全性</strong></h2>

<p><strong>可靠性</strong></p>

<p>如果序贯<span data-katex="\Gamma \vdash \Lambda"></span>可证，那么<span data-katex="\Gamma \models \Lambda"></span>成立。</p>

<p><br/></p>

<p><strong>紧致性</strong></p>

<p>如果<span data-katex="\Gamma"></span>是一个公式集合，<span data-katex="A"></span>是一个公式，并且序贯<span data-katex="\Gamma \vdash A"></span>可证，</p>

<p>那么必然存在有穷公式集合<span data-katex="\Delta"></span>，使得<span data-katex="\Delta \subseteq \Gamma"></span>并且<span data-katex="\Delta \vdash A"></span>可证。</p>

<p><br/></p>

<p><strong>协调性</strong></p>

<p>设<span data-katex="\Gamma"></span>为公式集合，如果不存在一个公式<span data-katex="A"></span>使得序贯<span data-katex="\Gamma \vdash A"></span>与<span data-katex="\Gamma \vdash \neg A"></span>均可证，</p>

<p>那么称<span data-katex="\Gamma"></span>是协调的。</p>

<p><br/></p>

<p><strong>完全性</strong></p>

<p>令<span data-katex="\Gamma"></span>为一个公式集合，<span data-katex="A"></span>为一个公式，</p>

<p>如果<span data-katex="\Gamma \models A"></span>成立，那么<span data-katex="\Gamma \vdash A"></span>可证。</p>

<p><br/></p>

<p><strong>定理：</strong>令<span data-katex="\Gamma"></span>为一个公式集合，<span data-katex="A"></span>为一个公式，</p>

<p>（1）<span data-katex="\Gamma \models A"></span>有效，当且仅当<span data-katex="\Gamma \vdash A"></span></p>

<p>（2）<span data-katex="\Gamma"></span>可满足，当且仅当<span data-katex="\Gamma"></span>协调</p>

<p><br/></p>

<h2><strong>形式理论</strong></h2>

<p>设<span data-katex="\Gamma"></span>是一阶语言<span data-katex="\mathscr{L}"></span>的有穷或可数无穷的语句集合，</p>

<p>如果<span data-katex="\Gamma"></span>协调，则称<span data-katex="\Gamma"></span>是一阶语言的形式理论，简称<strong>形式理论</strong>。</p>

<p>而称<span data-katex="\Gamma"></span>中的语句为<span data-katex="\Gamma"></span>的<strong>公理</strong>。</p>

<p><br/></p>

<p>如果<span data-katex="\Gamma"></span>是一个形式理论，</p>

<p>那么称语句集合，<span data-katex="Th(\Gamma )=\{A|A"></span>是<span data-katex="\mathscr{L}"></span>的语句，并且<span data-katex="\Gamma \vdash A"></span>可证<span data-katex="\}"></span>，</p>

<p>为<span data-katex="\Gamma"></span>的<strong>理论闭包</strong>。</p>

<p><br/></p>

<p>如果<span data-katex="\Gamma =\emptyset"></span>，那么，<span data-katex="Th(\emptyset )=\{A|A"></span>是<span data-katex="\mathscr{L}"></span>的语句，并且<span data-katex="\vdash A"></span>可证<span data-katex="\}"></span>，</p>

<p>是由全体重言式组成的集合。</p>

<p><br/></p>

<p>如果<span data-katex="M"></span>是<span data-katex="\mathscr{L}"></span>的模型，并且<span data-katex="M\models \Gamma"></span>，那么称<span data-katex="M"></span>是<span data-katex="\Gamma"></span>的模型。</p>

<p><br/></p>

<h2><strong>关于模型的形式理论</strong></h2>

<p>如果<span data-katex="M"></span>是一阶语言<span data-katex="\mathscr{L}"></span>的模型，那么称语句集合，</p>

<p><span data-katex="Th(M)=\{A|A"></span>是<span data-katex="\mathscr{L}"></span>的语句，并且<span data-katex="M\models A\}"></span></p>

<p>为<span data-katex="\mathscr{L}"></span>关于模型<span data-katex="M"></span>的形式理论。</p>

<p><br/></p>

<h2><strong>形式理论的完全性</strong></h2>

<p>称形式理论<span data-katex="\Gamma"></span>是完全的，如果对任意语句<span data-katex="A"></span>，</p>

<p><span data-katex="\Gamma \vdash A"></span>及<span data-katex="\Gamma \vdash \neg A"></span>中必有一个可证。</p>

<p><br/></p>

<h2><strong>函数的可表示性</strong></h2>

<p>设<span data-katex="f:\mathbb{N}^k\rightarrow \mathbb{N}"></span>是<span data-katex="\mathbb{N}"></span>上的<span data-katex="k"></span>元函数，</p>

<p>如果存在<span data-katex="\mathscr{A}"></span>公式<span data-katex="A(x_1,...,x_{k+1})"></span>，使得对任意自然数<span data-katex="n_1,...,n_{k+1}"></span>，</p>

<p>如果<span data-katex="f(n_1,...,n_k)=n_{k+1}"></span>，那么<span data-katex="\Pi \vdash A[S^{n_1}0,...,S^{n_{k+1}}0]"></span>可证</p>

<p>如果<span data-katex="f(n_1,...,n_k)\neq n_{k+1}"></span>，那么<span data-katex="\Pi \vdash \neg A[S^{n_1}0,...,S^{n_{k+1}}0]"></span>可证</p>

<p>在这种情况下，称函数<span data-katex="f"></span>在<span data-katex="\Pi"></span>中<strong>可表示</strong>，</p>

<p>并称公式<span data-katex="A(x_1,...,x_k,x_{k+1})"></span>是函数<span data-katex="f"></span>在<span data-katex="\Pi"></span>中的<strong>表示</strong>。</p>

<p><br/></p>

<p><strong>定理：</strong>如果<span data-katex="f:\mathbb{N}^k\rightarrow \mathbb{N}"></span>是<span data-katex="\mathbb{N}"></span>上的<span data-katex="k"></span>元可计算函数，</p>

<p>那么函数<span data-katex="f"></span>在<span data-katex="\Pi"></span>中可表示。</p>

<p><br/></p>

<h2><strong>关系的可表示性</strong></h2>

<p>设<span data-katex="r"></span>是<span data-katex="\mathbb{N}"></span>上的<span data-katex="k"></span>元关系，</p>

<p>如果存在<span data-katex="\mathscr{A}"></span>公式<span data-katex="A(x_1,...,x_{k+1})"></span>，使得对任意自然数<span data-katex="n_1,...,n_{k+1}"></span>，有</p>

<p>如果<span data-katex="r(n_1,...,n_k)=n_{k+1}"></span>，那么<span data-katex="\Pi \vdash A[S^{n_1}0,...,S^{n_{k+1}}0]"></span>可证</p>

<p>如果<span data-katex="r(n_1,...,n_k)\neq n_{k+1}"></span>，那么<span data-katex="\Pi \vdash \neg A[S^{n_1}0,...,S^{n_{k+1}}0]"></span>可证</p>

<p>在这种情况下，称关系<span data-katex="r"></span>在<span data-katex="\Pi"></span>中<strong>可表示</strong>，</p>

<p>并称公式<span data-katex="A(x_1,...,x_k,x_{k+1})"></span>在<span data-katex="\Pi"></span>中表示关系<span data-katex="r"></span>。</p>

<p><br/></p>

<p><strong>定理：</strong>如果<span data-katex="r:\mathbb{N}^k\rightarrow \mathbb{N}"></span>是<span data-katex="\mathbb{N}"></span>上的<span data-katex="k"></span>元可判定关系，</p>

<p>那么<span data-katex="r"></span>在<span data-katex="\Pi"></span>中可表示。</p>

<p><br/></p>

<h2><strong>哥德尔定理</strong></h2>

<p><strong>哥德尔不完全性定理</strong></p>

<p>如果<span data-katex="\Gamma"></span>是一个有穷并包含初等算术<span data-katex="\Pi"></span>的形式理论，</p>

<p>那么<span data-katex="\Gamma"></span>是一个不完全的形式理论。</p>

<p><br/></p>

<p><strong>哥德尔协调性定理</strong></p>

<p>如果形式理论<span data-katex="\Gamma"></span>包含初等算术<span data-katex="\Pi"></span>，</p>

<p>那么<span data-katex="\Pi"></span>的协调性不能在<span data-katex="\Gamma"></span>中被证明。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>以上，只是对谓词逻辑中用到的部分公式，进行了整理，</p>

<p>对建立<strong>用证明论和模型论的观点来理解公理系统</strong>，是很有帮助的。</p>

<p>然而，从更高的角度来看，有些观点很有可能就是<strong>错误</strong>的，</p>

<p>因此，此篇只是一个开始，督促我朝着更广阔的方向努力学习。</p>

<p><br/></p>

<p><strong>参考</strong></p>

<p><a href="http://book.douban.com/subject/2364517/">数理逻辑</a></p>

<p><a href="http://www.logicmatters.net/tyl/">Teach Yourself Logic 2015</a></p>

<p><a href="http://book.douban.com/subject/2878521/">logic and structure</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[论证与直觉]]></title>
    <link href="https://thzt.github.io/blog/2015/11/08/demonstration-and-intuition/"/>
    <updated>2015-11-08T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/11/08/demonstration-and-intuition</id>
    <content type="html"><![CDATA[<p>无论是工业还是科学，</p>

<p>很多领域中，</p>

<p>都需要积极的思考才能推动进步。</p>

<p><br/></p>

<p>在没有扎实的知识储备时，</p>

<p>在没有明确目标导向的情况下，</p>

<p>人们容易产生不切实际的<strong>幻想</strong>。</p>

<p><br/></p>

<p>所谓的民科，</p>

<p>是因为他们的想法，</p>

<p><strong>并没有解决更多的实际问题</strong>。</p>

<p><br/></p>

<p>观点在没有被论证之前，</p>

<p>是难以服众的，</p>

<p>至少不被已有的知识体系所接纳。</p>

<p><br/></p>

<p>因此，<strong>锻炼自己论证的能力</strong>，</p>

<p>是检验想法可靠途径。</p>

<p><br/></p>

<p><strong>然而，直觉也是必不可少的</strong>，</p>

<p>它可以预先设定一个目标，</p>

<p>指导我们去检验。</p>

<p><br/></p>

<h2><strong>实现它</strong></h2>

<p>检验构想的唯一途径，</p>

<p>就是<strong>用实现来证明它</strong>。</p>

<p><br/></p>

<p>尤其是在软件设计中，</p>

<p>在切实实现之前，</p>

<p>我们并不知道某个设计构思是否可行。</p>

<p><br/></p>

<p>总是心中先有了一个蓝图，</p>

<p>然后<strong>在实验室环境中对它进行检验</strong>，</p>

<p>可行的话，就移植到生产环境中。</p>

<p><br/></p>

<p>这就要求我们<strong>具有实现想法的能力</strong>，</p>

<p>锻炼自己的编程水平，</p>

<p>用最有效的方式检验设想。</p>

<p><br/></p>

<p>好的想法从哪里来的呢？</p>

<p><strong>过滤掉不可行的方案，</strong></p>

<p><strong>剩下的才可行。</strong></p>

<p><br/></p>

<p>我们只看到别人提出了一个方案，</p>

<p>却没有看到它已经用实验过滤掉了不行的那些设想。</p>

<p><br/></p>

<h2><strong>想象它</strong></h2>

<p>有了实现能力之后，</p>

<p>还需要<strong>锻炼想象力</strong>。</p>

<p><br/></p>

<p>如果存在的话，应该是怎样的？</p>

<p>假设已经存在了，结果会怎样？</p>

<p>人们期待它是什么样的呢？</p>

<p>如果存在，我们如何验证它呢？</p>

<p><br/></p>

<p><strong>有了想象力，</strong></p>

<p><strong>实现就有了方向。</strong></p>

<p><br/></p>

<p>测试驱动开发，</p>

<p>先思考检验的方式，再考虑实现。</p>

<p><br/></p>

<p>自顶向下开发，</p>

<p>先考虑外在表现，再考虑内部细节。</p>

<p><br/></p>

<p>设计接口，</p>

<p>先考虑别人怎么使用，再实现它。</p>

<p><br/></p>

<p>想象力也是需要锻炼的，</p>

<p>使我们可以<strong>预见事物的发展结果</strong>。</p>

<p><br/></p>

<h2><strong>学习它</strong></h2>

<p>曾经有人说过，</p>

<p>你永远没有自己的想法，</p>

<p>除非在写博士论文。</p>

<p><br/></p>

<p>确实如此。</p>

<p>在产生一个想法的同时，</p>

<p>还要<strong>学习别人的思路</strong>，</p>

<p>尤其是要<strong>关注别人在干什么</strong>。</p>

<p><br/></p>

<p>一方面，很多设想，</p>

<p>是已经被实现检验过的，</p>

<p>没必要走别人的老路。</p>

<p><br/></p>

<p>另一方面，很多设想，</p>

<p>虽然比人已经考虑过了，</p>

<p>但是思路值得学习，有利于我们类比到其他问题。</p>

<p><br/></p>

<p>因此，总是要保持<strong>学习和交流</strong>的态度，</p>

<p>而不是闭门造车。</p>

<p><br/></p>

<p>然而，<strong>又不能被别人的方案冲昏头脑</strong>，</p>

<p><strong>忘记自己知识体系的构建</strong>。</p>

<p><br/></p>

<h2><strong>接受它</strong></h2>

<p>一潭死水，指的是，</p>

<p>没有实现能力，没有想象力，</p>

<p>也没有学习能力。</p>

<p><br/></p>

<p>有的人，一开始就认为别人是错的，</p>

<p>他自己的知识体系已经封闭了，</p>

<p>他们说自己有<strong>怀疑精神</strong>。</p>

<p><br/></p>

<p><strong>而怀疑精神，指的是证否能力，前提要先接受。</strong></p>

<p>很多好的想法，别人没有时间给你证明，</p>

<p>先拒绝，会错过很多新奇的玩意。</p>

<p><br/></p>

<p>有怀疑精神是很难的，</p>

<p>难度在证明上，</p>

<p>而不是在接受上。</p>

<p><br/></p>

<p>只有我们保持开放，</p>

<p>思维才会活跃，</p>

<p>每天的日常就是努力获取更多的知识。</p>

<p><br/></p>

<p>别担心，当知识多了的时候，</p>

<p>鉴别能力也会随之提高，</p>

<p>不用小心翼翼的求稳，</p>

<p>广博的听取多家之言，才是最稳的。</p>

<p><br/></p>

<p><strong>不用担心自己理解错了，</strong></p>

<p><strong>反对者们会抢先告诉你的。</strong></p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>孟子曰，尽信书，不如无书，</p>

<p>坑了太多的人。</p>

<p><br/></p>

<p>人家说<strong>尽</strong>信，而不是信。</p>

<p>在盲目的时候，要提醒自己保持怀疑，</p>

<p>在过度怀疑的时候，要提醒自己接受，</p>

<p>让想象力飞起来吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[先后之分]]></title>
    <link href="https://thzt.github.io/blog/2015/10/30/preparation/"/>
    <updated>2015-10-30T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/10/30/preparation</id>
    <content type="html"><![CDATA[<p>孙子曰：</p>

<p>昔之善战者，<strong>先为不可胜</strong>，以待敌之可胜。</p>

<p><br/></p>

<p>善于指挥作战的人，</p>

<p>总是先创造条件使自己处于不可战胜的地位，</p>

<p>然后等待敌人能被我战胜的时机。</p>

<p><br/></p>

<p>孙子曰：</p>

<p>胜兵<strong>先胜而后求战</strong>，败兵先战而后求胜。</p>

<p><br/></p>

<p>胜利之师是先具备必胜的条件然后再去交战，</p>

<p>失败之师总是先同敌人交战，</p>

<p>然后期求从苦战中侥幸取胜。</p>

<p><br/></p>

<p>诚然，</p>

<p>现代的生活，没有了表面上的战争，</p>

<p>但是隐性的战争却无处不在。</p>

<p><br/></p>

<p>兵，泛指了可以利用资源，</p>

<p>而兵法写了对资源的管理方式。</p>

<p>2500年前的兵家思想，</p>

<p>对现代仍然有战略指导意义。</p>

<p><br/></p>

<h2><strong>先做准备</strong></h2>

<p>毛泽东是一个熟读兵法的领袖人物，</p>

<p>在《目前形势和我们的任务》中提到：</p>

<p><strong>不打无准备之仗</strong>，不打无把握之仗，</p>

<p>每战都应力求有准备，力求在敌我条件对比下有胜利的把握。</p>

<p><br/></p>

<p>日常生活中，我们应该<strong>利用闲余时间做好准备</strong>，</p>

<p>等到机会来临时，才有能力把握住。</p>

<p><br/></p>

<p>运气，只是成功者的谦辞。</p>

<p><br/></p>

<p>听过一个故事，说自己因为2分之差没有入选。</p>

<p>于是就抱怨，说别人只不过比自己多2分而已。</p>

<p><br/></p>

<p>后来父亲教导说，</p>

<p>人啊就是要拼了命努力，</p>

<p>你看着他比你多了2分你不服气，你怎么知道他比你多努力的只是2分啊，</p>

<p><strong>如果你需要靠75分才能入围，那你就要做85分的努力才能保证自己一定会入围</strong>，</p>

<p>侥幸的成功是不稳定的。</p>

<p><br/></p>

<p>事实就是如此，</p>

<p>很多输赢在准备阶段已经确定了，比赛只是走个过场，</p>

<p>没有压倒性的优势，就会陷于焦灼战，</p>

<p>对本身损害极大，又<strong>丧失了进一步做准备的时间</strong>。</p>

<p><br/></p>

<p>孙子兵法在谋攻中指出：</p>

<p>最好的策略是以<strong>谋略</strong>胜敌，其次是<strong>外交</strong>手段，再次是通过<strong>交战</strong>，最下等的是<strong>攻城</strong>。</p>

<p>而善于用兵的人，使敌军屈服而不用交战，夺取敌城而不用攻城，消灭敌国而不用兵。</p>

<p>一定要本着不诉诸兵刃就使敌完整屈服的原则，争横天下。</p>

<p><br/></p>

<h2><strong>任何能力都需要时间的积累</strong></h2>

<p>当想明白了输赢靠准备，不靠交战这一层之后，</p>

<p>我们就要努力<strong>积累</strong>能力了。</p>

<p><br/></p>

<p>我们生存的这个世界，不是瞬变的过程，</p>

<p>任何改变都需要足够多的时间。</p>

<p><br/></p>

<p>学生时代，即使学过了牛顿的惯性定律，</p>

<p>也没有太在意，天真的认为，社会的发展，首先是设计成某个样子，</p>

<p>然后大家再努力建设成那个样子。</p>

<p><br/></p>

<p>而事实上，<strong>怎样从现状做出改变，才是关键</strong>。</p>

<p><strong>一个系统不可能直接废掉，变成其他的系统。</strong></p>

<p>我们得用发展的眼光看待问题，</p>

<p>因势利导，局部调整。</p>

<p><br/></p>

<p>个人的职业发展，也是如此，</p>

<p>一个人不是因为自己成为了领袖，才学会领导才能。</p>

<p>而是<strong>先对领导力进行了主动积累，才有希望成为领袖</strong>。</p>

<p><br/></p>

<p>人的成长，并非仅是知识的获取，</p>

<p>还包括了心智的成熟与人生经验的积累，</p>

<p>而这些都需要足够的时间。</p>

<p><br/></p>

<h2><strong>攻守之战</strong></h2>

<p>我原以为躁进的心态是这些年才有的，</p>

<p>其实不然。</p>

<p><br/></p>

<p>从古至今，都不缺少急功近利的人。</p>

<p>汉代董仲舒对胶西王说过：</p>

<p>仁人者正其道不谋其利，修其理不急其功。</p>

<p>这才是真正的强国之路。</p>

<p><br/></p>

<p>而在追逐利益的同时，必定暴露弱点，</p>

<p>让其他人有机可乘。</p>

<p>相反，<strong>国家昌盛了，有道之士自然会来投奔。</strong></p>

<p><br/></p>

<p>从夯实基础为立足点，稳中求进，</p>

<p>一旦拿下就是压倒性的优势，</p>

<p>别人无法反抗。</p>

<p><br/></p>

<p>孙子兵法中提到：</p>

<p>打仗的原则是，不要寄希望于敌人不来，而要依靠自己有充分准备，严阵以待；</p>

<p>不要寄希望于敌人不会进攻，而要依靠自己有敌人不可攻破的条件。</p>

<p><br/></p>

<p>对啊，就算早别人一步，未必能守住。</p>

<p><strong>能掌握先机，未必不被后来者居上。</strong></p>

<p><br/></p>

<p>躁进的同时，还是先假想一下成功后的结果吧。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>事件的发生顺序，是有先后之分的，</p>

<p>不能因为事件紧迫，就选择冒进的办法。</p>

<p><br/></p>

<p>做好准备，好好积累，</p>

<p>才会有能力应对突发情况。</p>

<p><br/></p>

<p>突发情况处理的不好，并不是应变能力的问题，</p>

<p>而是风险管理的问题。</p>

<p>我们不应该想，时间这么紧，怎么办呢？</p>

<p>而应该想，<strong>为什么任务这么紧急，我们却还剩下这么少的时间？</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[愉快的三天]]></title>
    <link href="https://thzt.github.io/blog/2015/10/15/web-front-end-bug/"/>
    <updated>2015-10-15T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/10/15/web-front-end-bug</id>
    <content type="html"><![CDATA[<p><strong>场景：</strong></p>

<p>两级弹框，第一级是bootstrap的modal，里面有一个jqgrid，第二级是jqgrid添加记录的弹框</p>

<p>第二级弹框中的textarea在IE9中不能换行，而在chrome中可以</p>

<p><br/></p>

<h2><strong>Day 1</strong></h2>

<p>bootstrap的modal和jqgrid全部在实验室环境中搭建起来，比较麻烦，先考虑别的办法</p>

<p>因为IE9调试工具太弱了，看看firefox有没有同样的问题</p>

<p>发现firefox中的问题是textarea不能聚焦</p>

<p>以前遇到过不能获得焦点的问题，跟tabindex有关，把tabindex删掉，没作用</p>

<p>发现一级弹框中加了元素级别的textarea样式，删掉，没作用</p>

<p>因为这个框是jqgrid弹出来的，查看jqgrid源码，有没有劫持回车事件，没有</p>

<p>firefox中逐个删除页面元素，发现可以让textarea获得焦点，可能是元素的问题</p>

<p>把一级对话框内中的jqgrid删掉，再用控制台命令添加纯html二级弹框，还是有问题，说明不是jqgrid的问题</p>

<p>考虑到删除元素会改变子元素的样式，可能是样式问题</p>

<p>firefox中删除所有样式，发现可以获得焦点了，是样式问题</p>

<p>逐步缩小范围，发现是一级弹框有一个行内样式所致，删掉后，可以获得焦点了</p>

<p>但是在IE9中仍然不可换行</p>

<p><strong>解决了firefox不能聚焦的问题</strong></p>

<p><br/></p>

<h2><strong>Day 2</strong></h2>

<p>现在Chrome和Firefox都没问题了，只好硬着头皮用IE9调试了，鉴于昨天的结论，先从样式角度考虑</p>

<p>发现一级弹框去掉所有样式，就可以换行了</p>

<p>但是聚焦不到特定的某一条样式上，怀疑是脏乱的样式加成结果导致CSS解析器出错了</p>

<p>发现在错误的样式下，只要隐藏对话框也是可换行的，可能是浏览器计算位置时出错了</p>

<p>因为bootstrap样式层叠的太多了，既然不知道哪个样式是错的，那就用正确的样式手写生成原来的样子，也是个办法</p>

<p>生成过程中发现其他样式都去掉，display:block;position:fixed;z-index:1030;就能复现问题，可能是浏览器计算z-index错了</p>

<p>用IE9调试工具修改页面源码，就没问题了。因为页面重绘，重新计算了位置，也可能是事件都删掉了</p>

<p>页面太乱了，清理一下，把页面杂乱的标签都删掉，尤其是script片段，没作用</p>

<p>把link标签都删掉，没问题了。应该是某个样式表的问题，定位到是bootstrap.css或ui.jqgrid.css的问题，这两个删一个问题就复现</p>

<p>把一级弹框的所有父元素保留，删除页面中所有其他的html，问题还存在。但是IE9调试工具中点Refresh就没问题了，IE9调试工具不可靠</p>

<p>不能过度依赖调试工具了，得想办法把本地服务器端运行起来，不然剩下的办法只能是实验室环境中把网页重新静态构建起来了</p>

<p><strong>找到一个可行的解决方案，弹出第二级对话框时，把第一级隐藏掉</strong></p>

<p><br/></p>

<h2><strong>Day 3</strong></h2>

<p>搭建本机环境，把服务器端运行起来</p>

<p>删掉一级弹框中的所有代码，控制台命令弹出二级纯html弹框，没作用</p>

<p>先用控制台命令弹出二级纯html弹框，再在页面点击弹出一级弹框，没作用</p>

<p>控制台命令弹出二级纯html弹框，再控制台命令弹出一级纯html弹框，好了，应该是一级弹框弹出的过程中做了什么</p>

<p>发现是bootstrap的modal(&lsquo;show&rsquo;)这条语句弹出的框有问题</p>

<p>因为IE9不容易跟源码，所以先不看源码，在实验室环境中，造一个一模一样modal，然后二级弹框果然出问题了，并且firefox和chrome都无法获得焦点</p>

<p>实验室环境中复现了问题，问题快解决了</p>

<p>找到bootstrap的modal插件的官方例子，弹出二级弹框，没问题</p>

<p>对比有问题的代码，发现只要modal-body中包含&lt;button&gt;就能复现问题，定位为bootstrap的问题</p>

<p>考虑解决方案，把服务器中的所有button都换成div，还是有问题，而实验室没问题，说明IE9不太稳定</p>

<p>控制台删掉所有的button，结果好了</p>

<p>看看是哪个button影响的，发现总是最后一个button影响的</p>

<p>用补丁方式，先造一个隐藏的button，然后载入时模拟控制台删掉它，没作用。但是控制台删掉它，就有作用，不稳定</p>

<p>不看modal的源码不行了</p>

<p>为了能调试进源码中，换Chrome跟进bootstrap源码，再到IE9看效果</p>

<p>先把modal函数中代码全删了，果然问题没了，然后逐个功能还原，寻找复现问题的临界点</p>

<p>发现enforceFocus这样的方法，是为了强制让对话框获得焦点，感觉就是这个了</p>

<p>把这个方法注掉，没作用，看看实现，就是先解绑一个自定义聚焦事件再绑定这个自定义聚焦事件</p>

<p>在事件中写log，果然点击textarea，就触发这个自定义事件</p>

<p>把事件中把强制获得焦点的代码删掉，好了，这应该就是问题所在了</p>

<p>考虑解决方案，enforceFocus只是进行解绑和绑定事件，而事件是点击textarea时触发的，那就让它只解绑不绑定</p>

<p>分析源码，enforceFocus引用是Modal.prototype中的方法，而Modal是$.fn.modal.constructor，因此是在源码外改的</p>

<p>尽量不动源码，在源码之外加补丁</p>

<p>chrome和firefox在实验室环境中，textarea是不能获得焦点的，但是网站中可以，原因未知</p>

<p><strong>通过覆盖自动聚焦事件，解决了问题</strong></p>

<p><br/></p>

<h2><strong>困难</strong></h2>

<p>IE9的调试工具太差，Chrome调试工具虽好，但是Chrome没有问题</p>

<p>bootstrap大量的样式名污染的全局空间，每一个元素有大量冗余的层叠样式</p>

<p>很多事件可能是跟样式名相关联的，删了样式名会影响事件</p>

<p>前两天本机环境没有搭建好，只能通过浏览器调试</p>

<p>第三方库用了什么黑魔法，不知道</p>

<p>页面太杂乱，script片段遍布各处，到处是动态加载但不清理的内容</p>

<p>setTimeout乱用，至少二十处setTimeout，js执行过程紊乱</p>

<p>两层弹框，第一级弹框中还能进行内容tab切换，影响因素比较多</p>

<p>项目代码的问题写的太差，互相依赖，很难对功能进行隔离，不能以功能模块为单位进行测试</p>

<p>二级弹框并不是一级弹框的子元素，而是body的子元素，与一级弹框的位置相距很远，从直觉上很难发现有关联</p>

<p><br/></p>

<h2><strong>优势</strong></h2>

<p>电脑配置不错，两个显示器，16G内存装了虚拟机可以模拟IE8-11,Edge</p>

<p>没有时间压力，没人催我，没有别的项目或会议打断我</p>

<p>服务器端同事配合，没有怀疑我的能力</p>

<p>bootstrap和jqgrid源码不是太烂</p>

<p>这不是一个偶现的bug，没次都能出现，难度降低了不少</p>

<p><br/></p>

<h2><strong>误区</strong></h2>

<p>其实IE的问题并不是那么多，更多的是可见代码的问题</p>

<p>黑盒试错，不如静下心来跟进源码看看原理</p>

<p>不能过度依赖调试工具的结论</p>

<p>可以通过改动来试错的代码越多，排除假设的机会就越大</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[不同的前提]]></title>
    <link href="https://thzt.github.io/blog/2015/10/12/different-premise/"/>
    <updated>2015-10-12T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/10/12/different-premise</id>
    <content type="html"><![CDATA[<p>在对待数学问题时，</p>

<p>我们知道，</p>

<p>要在相同的前提下考虑问题。</p>

<p><br/></p>

<p>否则，</p>

<p>所得到的结论之间没有可比性。</p>

<p><br/></p>

<p>但是，在处理其他问题的时候，</p>

<p>我们容易忽略这一点，</p>

<p>烦恼和迷惑就随之而来了。</p>

<p><br/></p>

<h2><strong>换位思考</strong></h2>

<p>某位高管收了多少贿赂，你骂他贪官，</p>

<p>某个明星聚众吸毒，你骂他可笑，</p>

<p>某某富二代超速飙车，你骂他废柴。</p>

<p><br/></p>

<p>诚然，</p>

<p>这是不对的。</p>

<p><br/></p>

<p><strong>但是，换作我们，</strong></p>

<p><strong>在他们的位置，也不一定能洁身自好。</strong></p>

<p><br/></p>

<p>因为，普通人并没有遭遇同等级别的诱惑。</p>

<p><br/></p>

<p>每个人都有爱好，</p>

<p>你喜好什么，别人就利用什么，</p>

<p>要想全身而退，非常困难。</p>

<p><br/></p>

<p>某位领导在台上吹嘘拍马，你说他忽悠，</p>

<p>某个产品经理的需求几经调整，你说他不专业，</p>

<p>某个程序员写的代码Bug不少，你说他技术不行。</p>

<p><br/></p>

<p>诚然，</p>

<p>他们应该可以做的更好。</p>

<p><br/></p>

<p><strong>但是，换做我们，</strong></p>

<p><strong>在他们的位置，未必能达到他们现在的水平。</strong></p>

<p><br/></p>

<p>因为，外行人并没有看到专业人士遇到的困难。</p>

<p><br/></p>

<p>在专业领域有很多限制条件，</p>

<p>这大大缩小了决策范围，</p>

<p>外行的建议，往往不能兼顾这些限制条件。</p>

<p><br/></p>

<h2><strong>严于律己</strong></h2>

<p>不要为自己找借口，</p>

<p>前提并不是影响结果的唯一因素，</p>

<p><strong>同样的前提，别人可以做的更好。</strong></p>

<p><br/></p>

<p>在电视剧《GOLD》中，</p>

<p>早乙女悠里在监狱中的演讲，</p>

<p>说明了这一点。</p>

<p><br/></p>

<p>很多被害者的遗属，带着几近绝望的愤怒抗诉，</p>

<p>要求给犯罪者更重的刑罚，要求处以极刑。</p>

<p><br/></p>

<p>要说为什么他们的愤怒会如此强烈，</p>

<p>那是因为这些犯人中，</p>

<p>很多人都不为自己犯下的罪行感到悔恨，</p>

<p>唯一悔恨的只是自己被逮住。</p>

<p><br/></p>

<p>为了让审判对自己有利，</p>

<p>他们会演一些令人作呕的小把戏，</p>

<p>这样的小把戏，被害人家属一眼就能看穿。</p>

<p><br/></p>

<p>他们说自己的成长经历，</p>

<p>说自己不被父母爱护，说社会对自己不理不睬，</p>

<p>尽说这些让人腻烦的狡辩和自欺的废话。</p>

<p><br/></p>

<p><strong>我告诉你们，即便是被塞进同样的环境，</strong></p>

<p><strong>不，即便是遭遇更残酷的命运，</strong></p>

<p><strong>很多人也绝不会犯罪。</strong></p>

<p><br/></p>

<p>绝不会去伤害，欺骗，抢劫，杀害他人，</p>

<p>沾染毒品，欺诈老年人，汇款欺诈，</p>

<p>抢劫，强奸，杀人。</p>

<p><br/></p>

<p>会那么轻易的剥夺他人的尊严的人，</p>

<p>它心琴的弦早就一根不剩了，一根不剩。</p>

<p><br/></p>

<h2><strong>宽以待人</strong></h2>

<p>我们眼中，自己才是最好的，</p>

<p>不幸的是，每个人都是这样认为的。</p>

<p><br/></p>

<p>别人是否失误，</p>

<p>是站在自己的前提考虑的，</p>

<p><strong>我们能看到别人看不到的盲区。</strong></p>

<p><br/></p>

<p>常见的一句话是，</p>

<p>你不知道怎么不问呢？</p>

<p>然而，他既然不知道，怎么会意识到要问？</p>

<p><br/></p>

<p>曹植说，</p>

<p>东海广且深，由卑下百川；</p>

<p>五岳虽高大，不逆垢与尘。</p>

<p><br/></p>

<p>循循善诱，克制好自己的愤怒和嘲讽，</p>

<p><strong>实力相差悬殊的对手之间，没有仇恨。</strong></p>

<p><br/></p>

<p>这世界很奇怪，</p>

<p>高人常常以隐瞒自己的实力为乐，</p>

<p>不能韬光养晦，也成不了高人。</p>

<p><br/></p>

<p><strong>所以，你觉得别人很差，</strong></p>

<p><strong>他也有可能在逗你。</strong></p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>事了拂衣去，深藏身与名。</p>

<p>——《李白》</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Scheme元编程]]></title>
    <link href="https://thzt.github.io/blog/2015/09/21/define-syntax/"/>
    <updated>2015-09-21T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/09/21/define-syntax</id>
    <content type="html"><![CDATA[<p><a href="https://en.wikipedia.org/wiki/Homoiconicity">同相性</a>，指的是，</p>

<p>程序和程序所操作的数据采用了统一编码。</p>

<p><br/></p>

<p>Lisp语言使用了S表达式，</p>

<p>例如，(fn x)</p>

<p>既可以看做是程序，用参数x调用函数fn，</p>

<p>也可以看做是数据，由符号fn和符号x构成的列表。</p>

<p><br/></p>

<p><strong>同相性使得我们，可以像处理数据一样处理代码。</strong></p>

<p>做一些代码转换之类的工作，十分简单。</p>

<p><br/></p>

<p>例如，</p>

<p>当遇到(fn x)时，</p>

<p>我们可以让它先转换成，</p>

<p>(begin</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(display x)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(gn x))</p>

<p>然后再执行。</p>

<p><br/></p>

<p>甚至也可以用来定义变量，</p>

<p>(define-with-display (f a)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(g a))</p>

<p><br/></p>

<p>转换成，</p>

<p>(define (f a)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(display a)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(g a))</p>

<p><br/></p>

<p>这种代码层面的转换称为“宏”(macro)。</p>

<p><br/></p>

<h2><strong>定义一个宏</strong></h2>

<p>Scheme是Lisp的一个简洁方言，</p>

<p>它使用define-syntax来定义宏。</p>

<p><br/></p>

<p>本质上，宏是一个特殊的标识符，</p>

<p>它关联了转换器函数。</p>

<p><br/></p>

<p>表达式的求值过程，分为了3个阶段，</p>

<p>读取期，宏展开期，运行期。</p>

<p><br/></p>

<p>在遇到宏调用的时候，</p>

<p>Scheme会先调用与之关联的转换器，进行代码转换，(宏展开期)</p>

<p><strong>然后再求值结果表达式</strong>。(运行期)</p>

<p><br/></p>

<p>在解释器中，宏展开和表达式求值可能是交替进行的，</p>

<p>而在编译器中，他们是两个独立的阶段。</p>

<p><br/></p>

<p>(define-syntax or</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules ()</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_) #f]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_ e) e]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_ e1 e2 e3 &hellip;)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (let ([t e1]) (if t t (or e2 e3 &hellip;)))]))</p>

<p><br/></p>

<p>以上代码定义了一个宏，or，</p>

<p>它用来对(or &hellip;)表达式进行变换。</p>

<p><br/></p>

<p>(or)转换成了#f</p>

<p>(or a)转换成了a</p>

<p>(or a b)转换成了(let ([t a]) (if t t (or b)))</p>

<p><br/></p>

<p>我们看到，</p>

<p>宏展开是支持递归调用的。</p>

<p><br/></p>

<h2><strong>模式匹配</strong></h2>

<p>syntax-rules使用了模式匹配来定义转换器，</p>

<p>它的每一条语句给定了形如“[模式 模板]”的转换规则，</p>

<p>如果模式匹配成功了，</p>

<p>就按着模板的方式进行转换。</p>

<p><br/></p>

<p>[(_ e) e]</p>

<p><br/></p>

<p>其中，</p>

<p>模式是(_ e)，</p>

<p>模板是e，</p>

<p>“_”表示通配符。</p>

<p><br/></p>

<p>这个模式匹配了(or e)，</p>

<p>转换结果为e，</p>

<p>即它能把(or a)转换成a。</p>

<p><br/></p>

<p>我们再来看(_ e1 e2 e3 &hellip;)，</p>

<p>其中的省略号“&hellip;”，</p>

<p><strong>并不是为了演示方便故意省略了。</strong></p>

<p><br/></p>

<p>“&hellip;”是一个标识符，是模式匹配的一部分，</p>

<p>它用来代表“和前面一样的匹配”。</p>

<p>模板中也出现了“&hellip;”，</p>

<p>它会根据模式中“&hellip;”来进行填充。</p>

<p><br/></p>

<p>Scheme中使用的模式匹配，是一个庞大的主题，</p>

<p>甚至<strong>模式匹配已经构成了一门新的语言，</strong></p>

<p>TSPL4中进行了详细的解释，<a href="http://www.scheme.com/tspl4/syntax.html#./syntax:h2">Syntax-Rules Transformers</a></p>

<p><br/></p>

<h2><strong>转换器函数</strong></h2>

<p>另外一种定义宏的方式是，</p>

<p>显式的指定宏展开器函数。</p>

<p><br/></p>

<p>(define-syntax r</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(lambda (x)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display x)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display &ldquo;\n&rdquo;)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#t))</p>

<p><br/></p>

<p>我们用lambda定义了一个匿名函数，</p>

<p>并让它与宏标识符r相关联。</p>

<p><br/></p>

<p>我们直接在REPL中看看r是什么，</p>

<p><br/></p>

<p>#&lt;syntax r&gt;</p>

<p>#t</p>

<p><br/></p>

<p>第一行是(display x)副作用，</p>

<p>可见x的值是#&lt;syntax r&gt;，称为<strong>语法对象</strong>(syntax object)。</p>

<p><br/></p>

<p>然后r被转换成#t，</p>

<p>第二行是REPL中打印了#t的值。</p>

<p><br/></p>

<p>为了处理转换器中匹配到的语法对象，</p>

<p>Scheme语言提供了syntax-case特殊形式。</p>

<p><br/></p>

<p>(define-syntax or</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(lambda (x)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case x ()</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_) #&lsquo;#f]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_ e) #&lsquo;e]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_ e1 e2 e3 &hellip;)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&lsquo;(let ([t e1]) (if t t (or e2 e3 &hellip;)))])))</p>

<p><br/></p>

<p>它使用了与syntax-rules相同的模式匹配规则，</p>

<p>不同的是，我们还需要<strong>显式构造模板中的语法对象</strong>。</p>

<p><br/></p>

<p>对于宏调用(or a b)来说，x的值是#&lt;syntax (or a b)&gt;，</p>

<p><strong>syntax-case会先求值x，然后解开语法对象的封装</strong>，得到(or a b)，</p>

<p>再进行模式匹配。</p>

<p><br/></p>

<h2><strong>语法对象</strong></h2>

<p>语法对象，包装了标识符的作用域信息。</p>

<p><br/></p>

<p>我们知道Scheme的宏是卫生的(hygienic)，</p>

<p><strong>宏展开后的标识符还处在其来源处的词法作用域中，</strong></p>

<p>为了达成这个目的，作用域信息就要被保存起来。</p>

<p><br/></p>

<p>Scheme的不同实现有不同的做法，</p>

<p><a href="http://www.scheme.com/download/">Petite Chez Scheme</a>使用了<strong>语法对象</strong>进行封装。</p>

<p><br/></p>

<p>语法对象由syntax特殊形式创建，(syntax e)</p>

<p>#&lsquo;e是它的简写，</p>

<p>在程序的读取阶段会被展开为(syntax e)。</p>

<p><br/></p>

<p>前文我们说，</p>

<p>“模式匹配构成了一门新的语言”，并不为过，</p>

<p>因为#&lsquo;有很多规则(<strong>坑</strong>)需要我们了解。</p>

<p><br/></p>

<p>（1）出现在“模式”中的变量，称为模式变量(pattern variable)，</p>

<p><strong>模式变量的值是它匹配的值</strong>。</p>

<p>例如：(_ a b)匹配(or x y)，a和b就是模式变量，a的值是x，b的值是y</p>

<p><br/></p>

<p>（2）#&lsquo;e的值是一个语法对象，<strong>e可以是模式变量也可以不是</strong>。</p>

<p>如果e是模式变量，则值为#&lt;syntax e匹配的值&gt;，</p>

<p>如果e不是模式变量，则值为#&lt;syntax e&gt;。</p>

<p><br/></p>

<p>（3）“模板”中的模式变量，必须出现在#&lsquo;或者#&rsquo;(&hellip;)中，<strong>不能裸写</strong>。</p>

<p><a href="http://www.scheme.com/tspl4/syntax.html#./syntax:h3">Pattern variables, however, can be referenced only within syntax expressions</a></p>

<p><br/></p>

<p>（4）<strong>#&lsquo;(a b)不是一个语法对象，而是由语法对象构成的列表</strong>，(#'a #'b)</p>

<p>例如：[(_ a) #&lsquo;(a b)]，结果是(#&lt;syntax a匹配的值&gt; #&lt;syntax b&gt;)</p>

<p>注意到b不是模式变量。</p>

<p><br/></p>

<p>（5）多层#&lsquo;，读取器会先将每一层展开成(syntax &hellip;)再求值。</p>

<p>例如：#&lsquo;#'a实际上是(syntax (syntax a))，</p>

<p>求值为(#&lt;syntax syntax&gt; (#&lt;syntax syntax&gt; #&lt;syntax a匹配的值&gt;))。</p>

<p>注意到syntax不是模式变量。</p>

<p><br/></p>

<h2><strong>可以定义宏的宏</strong></h2>

<p>syntax-rules是用来定义宏的，</p>

<p>然而，它也是一个宏，它最终被展开为syntax-case。</p>

<p><br/></p>

<p>(define-syntax syntax-rules</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(lambda (x)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case x ()</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_ (i &hellip;) ((keyword . pattern) template) &hellip;)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&lsquo;(lambda (x)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case x (i &hellip;)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [(_ . pattern) #&lsquo;template] &hellip;))])))</p>

<p><br/></p>

<p>syntax-rules的目的，</p>

<p>是为了避免显式的书写lambda和#&lsquo;。</p>

<p><br/></p>

<p>像这种生成syntax-case的宏还有很多，</p>

<p>例如，with-syntax。</p>

<p><br/></p>

<p>(define-syntax with-syntax</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(lambda (x)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case x ()</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_ ((p e) &hellip;) b1 b2 &hellip;)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&lsquo;(syntax-case (list e &hellip;) ()</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [(p &hellip;) (let () b1 b2 &hellip;)])])))</p>

<p><br/></p>

<p>with-syntax的目的，</p>

<p>是把匹配条件写在一起，</p>

<p>最后输出到一个模板中。</p>

<p><br/></p>

<p>从这里我们可以看到，</p>

<p>syntax-case第一个参数的值，</p>

<p>可以是语法对象的列表。</p>

<p><br/></p>

<p>syntax-case会对列表中的语法对象，</p>

<p>解除#&lt;syntax &hellip;&gt;的封装，</p>

<p>然后再进行模式匹配。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>Lisp的宏非常强大，</p>

<p>很多人只是听说过，</p>

<p>没有切身使用过，</p>

<p>隐约觉得宏可以解决任何问题。</p>

<p><br/></p>

<p>其实不然，</p>

<p><strong>Lisp宏只是做了一些代码的变换，</strong></p>

<p><strong>简化了已完成功能的描述方式。</strong></p>

<p><br/></p>

<p>本文对Scheme宏的定义和使用做了简单介绍，</p>

<p>希望能揭开它的神秘面纱。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[消除重复与可复用相距多远]]></title>
    <link href="https://thzt.github.io/blog/2015/09/11/reuse-oriented-programming/"/>
    <updated>2015-09-11T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/09/11/reuse-oriented-programming</id>
    <content type="html"><![CDATA[<p>程序员们都讨厌重复，</p>

<p>因为他们知道，</p>

<p>这是可以避免的冗余工作量。</p>

<p>——代码坏味</p>

<p><br/></p>

<p>如果本来就不可避免，</p>

<p>那只好认了，</p>

<p>就好像需求不可能不变的事实一样。</p>

<p><br/></p>

<p>但是，<strong>盲目的消除重复</strong>，</p>

<p>并不是正确的姿势，</p>

<p>反而会把简单的事情搞复杂。</p>

<p><br/></p>

<p>为什么程序员们甘心写那么多“public class XXX {}”，</p>

<p>甘心写那么多“END”，“;”或者“)”，</p>

<p>而不设法避免呢？</p>

<p><br/></p>

<p>为什么不把所有的“this”都提取出来，</p>

<p>放在一个地方，</p>

<p>在编译前，再把他们塞入代码中呢。</p>

<p><br/></p>

<p>诚然，通过macro，</p>

<p>可以做一些代码生成之类的事情，</p>

<p>但是直觉告诉我们，不能乱来。</p>

<p><br/></p>

<p>原因是什么？</p>

<p>消除重复与面向复用其实还相距太远。</p>

<p><br/></p>

<h2>什么是面向复用的编程</h2>

<p>“面向”，指的是目的，目标。</p>

<p><br/></p>

<p>方法论告诉我们，</p>

<p>要完成一件事需要3个步骤，</p>

<p>（1）确定目标</p>

<p>（2）分析差距</p>

<p>（3）缩小差距</p>

<p><br/></p>

<p>确定目标是第一步。</p>

<p><br/></p>

<p>要想让我们的程序被复用，</p>

<p>首先他要设计成<strong>可以</strong>被复用的，</p>

<p>不是哪天要用了，忽然就行了。</p>

<p><br/></p>

<p>而且，在一套软件中，</p>

<p>并不是所有的代码都是可复用的，</p>

<p>有些根本无法复用。</p>

<p><br/></p>

<p>承认了这两个事实以后，</p>

<p>任务一下子简单了很多。</p>

<p><br/></p>

<h2><strong>提取并不意味着抽象</strong></h2>

<p>一段代码，在很多地方都出现了，</p>

<p>我们马上就能想到，</p>

<p>把它<strong>提取</strong>到了一个函数中。</p>

<p><br/></p>

<p>然而这对可复用并没有任何作用，</p>

<p>我们只是凑巧成功了几次。</p>

<p><br/></p>

<p>假如某个调用处的<strong>业务逻辑</strong>发生了变化，</p>

<p>我们就遇到麻烦了，</p>

<p>不能修改提取出去的代码，因为别人也在用，</p>

<p>还要把代码再复制回去，只调整这一块。</p>

<p><br/></p>

<p>自讨苦吃啊。</p>

<p>那可如何是好？</p>

<p><br/></p>

<p>这是因为，提取和抽象是不同的，</p>

<p>提取是文本层次的观察，</p>

<p>而抽象是逻辑层次的考察。</p>

<p><br/></p>

<p>这段代码虽然在很多地方出现了，</p>

<p>可是它却由不同的<strong>逻辑单元</strong>组成，</p>

<p>这就隐藏了很多引起它改变的因素。</p>

<p>——单一职责原则</p>

<p><br/></p>

<p>我们应该先把这些逻辑单元封装好，</p>

<p>然后<strong>拼装</strong>出统一的抽象接口，</p>

<p>各处对接口进行调用。</p>

<p>——依赖倒置原则</p>

<p>——合成/聚合复用原则</p>

<p><br/></p>

<p>一旦某个逻辑单元需要调整了，</p>

<p>那么只需要单独为某处调用，</p>

<p>再<strong>实现</strong>一个新的接口函数就行了。</p>

<p>——开-闭原则</p>

<p><br/></p>

<h2><strong>外表要简单，内心不要太简单</strong></h2>

<p>有人觉得有个<strong>拼装层</strong>太麻烦了，</p>

<p>还不如直接提取函数好呢，</p>

<p>这其实是混淆了抽象与实现。</p>

<p><br/></p>

<p>接口的使用者是看不到实现方式的，</p>

<p>实现很复杂是为了有更高的灵活性。</p>

<p>——迪米特法则</p>

<p><br/></p>

<p><strong>语言的魅力不就是，把复杂藏于只言片语之后吗？</strong></p>

<p>编程的目的不就是，为多变的业务逻辑提供简洁的描述语言吗？</p>

<p>——领域特定语言</p>

<p><br/></p>

<p>一切都应该尽可能地简单,但不要太简单。</p>

<p>——爱因斯坦</p>

<p><br/></p>

<h2><strong>业务与功能</strong></h2>

<p>经常变动的是业务逻辑，</p>

<p>而可复用的是功能模块。</p>

<p><br/></p>

<p>对逻辑我们要抽象，</p>

<p>而对功能我们要封装。</p>

<p><br/></p>

<p><strong>很多新手认为，</strong></p>

<p><strong>把相关的代码组织在一起就是封装了，</strong></p>

<p><strong>这与认为把代码提取出来了就是抽象了一样失败。</strong></p>

<p><br/></p>

<p>要封装，是因为它们“能够封装”，</p>

<p>而不是代码恰好出现在了一起。</p>

<p><br/></p>

<p>只有<strong>与要描述的业务无关</strong>的功能，</p>

<p>才是可复用的单元。</p>

<p><br/></p>

<p>每个页面都发送AJAX请求，</p>

<p>然后更新一个id=&ldquo;message"的标签，</p>

<p>这是不可封装的。</p>

<p><br/></p>

<p>而发送AJAX模块，</p>

<p>更新任一标签内容的模块，</p>

<p>才是可封装的。</p>

<p><br/></p>

<p>一致的业务流程，也是可以封装的。</p>

<p>例如，如果有定时任务，</p>

<p>可以封装一个定时任务管理器，</p>

<p>只需要挂载任务的配置信息就可以自动执行。</p>

<p><br/></p>

<p>对了，别人有写好了的，</p>

<p>不用自己做，</p>

<p>但我们要这么想。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>能闻到坏味是好事，</p>

<p>但是不正确的打扫方法，</p>

<p>反而会使代码更难维护。</p>

<p><br/></p>

<p>消除重复是表象，</p>

<p>而面向复用才是目的。</p>

<p><br/></p>

<p><strong>和别人读同样的书，</strong></p>

<p><strong>不一定考上一样的大学，</strong></p>

<p><strong>更不一定有相同的人生。</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[无法扭转的颓势]]></title>
    <link href="https://thzt.github.io/blog/2015/09/02/impractical-illusion/"/>
    <updated>2015-09-02T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/09/02/impractical-illusion</id>
    <content type="html"><![CDATA[<p>很多人都参与过失败的项目，</p>

<p>代码脏乱差，补丁套补丁，</p>

<p>硬编码，版本紊乱，</p>

<p>加班严重，人肉文档，</p>

<p>幻想中的需求，人心涣散。</p>

<p><br/></p>

<p>我们都不想看着它失败，</p>

<p>但是又无能为力。</p>

<p><br/></p>

<p>不少能人异士，</p>

<p>提出建设性的方针，</p>

<p>提高开发能力，架构能力，</p>

<p>管控需求，加强团队建设。</p>

<p><br/></p>

<p>似乎可以力挽狂澜一样，</p>

<p>好像真的可以。</p>

<p><br/></p>

<p>实际上，<strong>地基如果坏了，</strong></p>

<p><strong>项目就已经完了，是无法挽救的，</strong></p>

<p>不如想想怎样重新来过吧。</p>

<p><br/></p>

<p>我们需要做的，</p>

<p>不是抱怨，也不是消极处理，</p>

<p>而是<strong>承认事实，理智对待</strong>。</p>

<p><br/></p>

<h2><strong>质量只会变得更差</strong></h2>

<p><strong>软件质量，一旦比昨天差，</strong></p>

<p><strong>明天只会更差。</strong></p>

<p><br/></p>

<p>一个房子如果窗户破了，没有人去修补，</p>

<p>隔不久，其它的窗户也会莫名其妙地被人打破。</p>

<p>——破窗效应</p>

<p><br/></p>

<p>明天有明天的事情，</p>

<p>如果明天替今天买单，</p>

<p>那今天还不如不做。</p>

<p><br/></p>

<p>期望以后来整理它，</p>

<p>那么这个时间永远都不会到来，</p>

<p>除非那天你不务正业。</p>

<p><br/></p>

<p>当天的事情，当天解决。</p>

<p><br/></p>

<p>永远保持离开时的露营地比你发现它时更整洁。</p>

<p>——童子军规则</p>

<p><br/></p>

<p>如果发现代码质量出了问题，</p>

<p><strong>唯一的办法就是停下手头的活，</strong></p>

<p><strong>偿还技术债务，</strong></p>

<p><strong>把它弄好了再继续。</strong></p>

<p><br/></p>

<p>否则，明天需要偿还的会更多。</p>

<p><br/></p>

<h2><strong>需求不需要稳定，需要控制</strong></h2>

<p><strong>没有稳定的需求，</strong></p>

<p><strong>作为专业程序员，</strong></p>

<p><strong>早就应该承认这一点。</strong></p>

<p><br/></p>

<p>需求是不可能不变的，</p>

<p>软件的存在就是为了适应变化的需求。</p>

<p><br/></p>

<p>但是，这并不是说我们不用去控制它，</p>

<p>至少我们应该让它<strong>阶段性的稳定</strong>。</p>

<p><br/></p>

<p>而且，程序员不是仅仅抱怨一下就完了，</p>

<p>软件本来就应该采用灵活的设计。</p>

<p><br/></p>

<p>如果需求乱了，并不是一个人的问题，</p>

<p>抱怨也没有用，所有人都该停下来，</p>

<p>承认事实，再想办法。</p>

<p><br/></p>

<h2><strong>早就该调整的架构</strong></h2>

<p>没有永远合理的架构，</p>

<p>架构是随着业务发展演变的。</p>

<p><br/></p>

<p><strong>好的架构，</strong></p>

<p><strong>是适用的，同时也应该是易于调整的。</strong></p>

<p><br/></p>

<p>当所有人都意识到模块划分不合理的时候，</p>

<p>早就应该调整结构了，</p>

<p>很多人都知道应该怎么做，</p>

<p>但是，几乎没有人做过，</p>

<p>是因为现在做起来成本太大。</p>

<p><br/></p>

<p>这就给了人们一个假象，</p>

<p>结构调整是复杂的，</p>

<p>不是短期就成实现的。</p>

<p><br/></p>

<p>其实不然，</p>

<p>治理的最高境界，</p>

<p>在于<strong>防患于未然</strong>。</p>

<p><br/></p>

<p>善战者无赫赫之功，善医者无煌煌之名。</p>

<p>——《曹选》</p>

<p><br/></p>

<p><strong>持续调整，成本并不大</strong>，</p>

<p>累积起来，就变成不可能完成的事情了。</p>

<p><br/></p>

<h2><strong>团结是每天都需要保持的</strong></h2>

<p>等到涣散了再考虑人心，</p>

<p>为时已晚。</p>

<p><br/></p>

<p>不团队的队伍，</p>

<p>再训练也无法变得团结一心。</p>

<p><br/></p>

<p>开除任何一个人，</p>

<p>也无法改善已有的状态。</p>

<p><br/></p>

<p>那怎么办？</p>

<p>我们得承认事实，</p>

<p><strong>有的事情糟了，确实是不可挽救的。</strong></p>

<p><br/></p>

<p>真到了这个地步，</p>

<p>只能全部都干掉。</p>

<p><br/></p>

<p>或者下更大的成本，</p>

<p>用新人组织新的团队，</p>

<p>只加入一个老兵。</p>

<p><br/></p>

<p>我们可不想到这一天，</p>

<p>那么我们今天要怎么做？</p>

<p>还能没有办法吗？</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>有时候，<strong>人们之所以乏力，</strong></p>

<p><strong>是因为还在抱有幻想，</strong></p>

<p><strong>不承认既定事实。</strong></p>

<p><br/></p>

<p>如果一开始就认为，</p>

<p>软件项目做烂了是无法挽救的。</p>

<p><br/></p>

<p>那什么都不一样了，</p>

<p>今天我们只会竭尽所能避免它变坏，</p>

<p>不然等到那一天，</p>

<p>一切都太迟了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[前端程序员的自我修养]]></title>
    <link href="https://thzt.github.io/blog/2015/09/01/an-introduction-to-web-front-end/"/>
    <updated>2015-09-01T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/09/01/an-introduction-to-web-front-end</id>
    <content type="html"><![CDATA[<p><strong>读史使人明智。——弗兰西斯.培根</strong></p>

<p><br/></p>

<p>学习历史，</p>

<p>可以帮助我们看清现在的决定，</p>

<p>并为以后的发展做好准备。</p>

<p><br/></p>

<p>前端技术，是<strong>界面技术</strong>的一种应用。</p>

<p><u>字符界面</u> <em>DOS</em></p>

<p><u>图形界面</u> <em>GUI</em></p>

<p><u>浏览器界面</u> <em>Browser</em></p>

<p><br/></p>

<p>前端项目，属于B/S类型的<strong>平台体系结构</strong>。</p>

<p><u>文件/服务器</u> <em>F/S</em></p>

<p><u>客户端/服务器</u> <em>C/S</em></p>

<p><u>浏览器/服务器</u> <em>B/S</em></p>

<p><br/></p>

<p>JavaScript，是最流行的<strong>客户端技术</strong>，</p>

<p>其他的还有，<em>Java-Applet Flash ActiveX Silverlight</em></p>

<p><br/></p>

<p>Web前端，是<strong>网页技术</strong>一个发展阶段，</p>

<p>在这个过程中，服务器端经历了，CGI，Web框架，MVC，</p>

<p>客户端经历了，HTML，CSS，AJAX，前端MVC，前端组件化。</p>

<p><br/></p>

<p>JavaScript也推广到了服务器端，</p>

<p><u>服务器端脚本</u> <em>Node.js</em>，</p>

<p><u>数据库</u> <em>MongoDB</em>，</p>

<p><u>WebApp</u> <em>React-Native</em>，</p>

<p><u>桌面应用</u> <em>nw.js</em></p>

<p><br/></p>

<p><strong>总结</strong></p>

<p>前端技术是一个处理<strong>人机交互</strong>的关键环节，</p>

<p>各种技术都汇聚于此，</p>

<p>随着云计算需要，以及移动设备的出现，</p>

<p>前端已经变的越来越丰富多彩，</p>

<p>大有平分天下的趋势。</p>

<p><br/></p>

<h2><strong>前端技术栈</strong></h2>

<p><strong>语言只是一种工具，对一个聪明的程序员来说，用没用过什么工具主要是由他原来的工作需要决定，并不能代表他全部的技能。</strong></p>

<p><strong>——请不要说自己是XX程序员</strong></p>

<p><br/></p>

<p>前端技术浩如烟海，</p>

<p>单纯JavaScript语言来说，也有数不清的细节，</p>

<p>为了有一个整体的印象，我们分类来看。</p>

<p><br/></p>

<p><strong>精一行，必先通十行。</strong></p>

<p><br/></p>

<p><u>浏览器环境</u> <em>IE6~8 IE9+ Chrome Firefox Safari Opera Edge</em></p>

<p><u>HTTP协议</u> <em>URI Cache Session Cookie Request Response</em></p>

<p><u>HTML</u> <em>W3C HTML4.01 HTML5 DOM 语义化</em></p>

<p><u>CSS</u> <em>CSS1~3 选择器 盒模型 Flex 媒体检测 响应式 渲染引擎</em></p>

<p><u>JavaScript</u> <em>EcmaScript3~5~6 Lexical-scope prototype-chain AJAX js引擎</em></p>

<p><u>编辑器</u> <em>Emacs Vim WebStorm Atom Sublime-Text</em></p>

<p><u>发布部署</u> <em>合并 压缩 单元测试 Node.js Grunt Gulp Yeoman Phantom JSLint</em></p>

<p><u>框架类库</u> <em>jQuery Zepto UnderScore Backbone Knockout React AngularJS</em></p>

<p><u>模块管理</u> <em>CommonJS Webpack</em></p>

<p><u>UI框架</u> <em>BootStrap SemanticUI jQueryUI Foundation</em></p>

<p><u>推送技术</u> <em>WebSocket 轮询 长连接</em></p>

<p><u>跨域技术</u> <em>iframe JSONP CORS</em></p>

<p><u>数据可视化</u> <em>D3 Echarts HighCharts Canvas</em></p>

<p><u>异步编程</u> <em>Promise $.Deferred Generator</em></p>

<p><u>CSS预处理器</u> <em>LESS SASS Stylus</em></p>

<p><u>客户端模板</u> <em>Handlebars Haml Jade Mustache</em></p>

<p><u>相关语言</u> <em>CoffeeScript TypeScript Dart WebAssembly</em></p>

<p><u>WebApp/PC</u> <em>React-native ionic</em></p>

<p><br/></p>

<p>以上提到的这些，<strong>几乎成了前端程序员的标配了</strong>，</p>

<p>所以，我们需要很努力，才不会被淘汰。</p>

<p><br/></p>

<p>JavaScript是一个动态弱类型的，原型继承的，函数式的编程语言，</p>

<p>掌握它并不简单，也为了与服务器端程序员愉快的沟通，</p>

<p>我们还要再学习一些<strong>编程语言</strong>。</p>

<p><br/></p>

<p>C/Rust/Go</p>

<p>C#/Java</p>

<p>Scheme/Haskell</p>

<p>PHP/Python/Ruby</p>

<p>Prolog/Erlang</p>

<p><br/></p>

<p>包括命令式，面向对象，函数式，逻辑式，</p>

<p>各种典型的编程泛型。</p>

<p><br/></p>

<h2><strong>少争论多读书</strong></h2>

<p><strong>思而不学则殆。——孔子</strong></p>

<p>我们之所以迷惑，不是因为缺少思考，</p>

<p>而是缺少学习。</p>

<p><br/></p>

<p><strong>前端的书籍</strong>越来越容易找到了，</p>

<p>除了EmcaScript语言规范之外，还有一些有趣的读物。</p>

<p><br/></p>

<p>JavaScript权威指南</p>

<p>JavaScript高级程序设计</p>

<p>JavaScript语言精粹</p>

<p>JavaScript模式</p>

<p>JavaScript DOM高级程序设计</p>

<p>高性能JavaScript编程</p>

<p>JavaScript异步编程</p>

<p>JavaScript忍者的秘密</p>

<p><br/></p>

<p>基于MVC的JavaScript Web富应用开发</p>

<p>jQuery权威指南</p>

<p>犀利开发jQuery内核详解与实践</p>

<p>jQuery Mobile权威指南</p>

<p>用AngularJS开发下一代Web应用</p>

<p>Node.js开发指南</p>

<p>高性能网站建设指南</p>

<p>响应式Web设计</p>

<p><br/></p>

<p>快速软件开发</p>

<p>测试驱动开发</p>

<p>重构</p>

<p>人月神话</p>

<p>敏捷软件开发：原则，模式与实践</p>

<p>面向模式的软件架构</p>

<p>计算机程序的构造与解释</p>

<p><br/></p>

<p>读书是一个愉快的过程。</p>

<p><br/></p>

<h2><strong>参考</strong></h2>

<p><a href="http://wenku.baidu.com/link?url=cGPDDS0nM8fKJgWVzf7YsgagTCfTrM_6U9BwvWg3w8YkjMH11ZA7bWZ7L68Aq_swpvFzOEcYS5I-fZpcpATU1nSfYpH6UW2ZPd4dd6b28py">「浅论CS和BS体系结构」</a></p>

<p><a href="http://blog.jobbole.com/45169/">「Web开发的发展史」</a></p>

<p><a href="http://wenku.baidu.com/link?url=m8fPjYHf5Q8_6hke8GttfLN9qtHpICgFCVtUsC7TYbjq5wb5HPjGGJaMwWp-zFEdfdNnLW4iKh4LfRKPVR71LywoZ4SPSp-3KTGigv8G9ve">「Web的发展史」</a></p>

<p><a href="https://github.com/fouber/blog/issues/10">「前端工程——基础篇」</a></p>

<p><a href="http://javascript.info/tutorial/overview">「Overview: JavaScript, Flash, Java, Silverlight and ActiveX」</a></p>

<p><a href="http://hechuanzhen.iteye.com/blog/1680685">「jQuery,Extjs,YUI,Prototype,Dojo 等JS框架的区别和应用场景简述」</a></p>

<p><a href="http://blog.jobbole.com/45170/">「Web开发技术的演变」</a></p>

<p><a href="http://www.oschina.net/question/2320925_227508">「请不要说自己是Java程序员」</a></p>

<p><a href="https://github.com/unruledboy/WebFrontEndStack">「WebFrontEndStack」</a></p>

<p><a href="http://wenku.baidu.com/link?url=TGWloxxKzDXe2CxwtKUxVVlX_ytO05K5-nH_CJPUlljpkU_Q60gpcoQuRIVrR-xsQtBPHJqv6-e8QcMWEPFtoXTfoD5D4JvyP_0DwAU1rXS">「服务器内容推送技术」</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[道德的不对称性]]></title>
    <link href="https://thzt.github.io/blog/2015/08/29/asymmetry-of-the-morality/"/>
    <updated>2015-08-29T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/08/29/asymmetry-of-the-morality</id>
    <content type="html"><![CDATA[<p>我们怎样对别人，</p>

<p>别人就应该怎么对我们吗？</p>

<p><br/></p>

<p>别人怎样对我们，</p>

<p>我们就应该怎样对别人吗？</p>

<p><br/></p>

<p>不是的。</p>

<p><br/></p>

<p>道德是不对称的。</p>

<p><br/></p>

<p>帮助别人，并不是为了得到感谢。</p>

<p>别人帮助了我们，就要知恩图报。</p>

<p><br/></p>

<p>请教别人问题，要怀着付费的态度。</p>

<p>回答别人问题，要怀着免费的态度。</p>

<p><br/></p>

<p>地铁上，踩到了别人，要说对不起。</p>

<p>被别人踩到了，要说没关系。</p>

<p><br/></p>

<p>不妨碍别人，是修养。</p>

<p>能容忍别人，是气度。</p>

<p><br/></p>

<p>不要拿自己的道德观约束别人。</p>

<p><br/></p>

<p>我们不希望被感谢，不代表可以不知恩图报。</p>

<p>我们耐心的解答问题，不代表可以霸占别人的时间。</p>

<p>我们没关系，不代表可以不说对不起。</p>

<p><br/></p>

<p>也不要拿别人对待我们的方式对待他们。</p>

<p><br/></p>

<p>严于律己，宽以待人。</p>

<p><br/></p>

<h2>谦虚而自信</h2>

<p>有修养有气度的认识难易程度，</p>

<p>才能自信而谦虚。</p>

<p><br/></p>

<p>自己觉得简单的，认为别人会觉得困难，是骄傲。</p>

<p>别人觉得简单的，认为自己会觉得困难，是自卑。</p>

<p><br/></p>

<p>自己觉得困难的，认为别人未必觉得困难，是谦虚。</p>

<p>别人觉得困难的，认为自己努力后会克服，是自信。</p>

<p><br/></p>

<p>做一个有涵养的人，很困难，</p>

<p>要主动磨练自己。</p>

<p><br/></p>

<p>嘲笑声中，保持自信容易，保持谦虚却很难。</p>

<p>鼓励声中，保持谦虚容易，保持自信却很难。</p>

<p><br/></p>

<p>我们容易受外界影响，</p>

<p>难以建立坚强的世界观。</p>

<p><br/></p>

<h2>各行各业</h2>

<p>一个学历差的人找工作，</p>

<p>会强调自己的能力并不差，</p>

<p>而学历好的人，就不需要强调这些。</p>

<p><br/></p>

<p>一个从事平凡工作的人，</p>

<p>更容易认为别人看不起他，</p>

<p>而工作体面的人，就很难这样想。</p>

<p><br/></p>

<p>一个高官达贵，</p>

<p>更容易贪污受贿，</p>

<p>而普通人，根本没有接受过挑战。</p>

<p><br/></p>

<p>每个人的处境是不同的，</p>

<p>就导致了不同的想法。</p>

<p><br/></p>

<p>这就好比，</p>

<p>康熙不明白书生为什么要饭一样，</p>

<p>因为他没有饿过。</p>

<p><br/></p>

<p>这就好比，</p>

<p>高官达贵不明白为什么有医患纠纷一样，</p>

<p>因为他得病以后不会和平民一样受辱。</p>

<p><br/></p>

<p>这就好比，</p>

<p>一个热门专业的教育专家，</p>

<p>不明白为什么还有人找不到工作。</p>

<p><br/></p>

<p>没关系，</p>

<p>如果我们像他们一样的处境，</p>

<p>我们也会有这样的世界观。</p>

<p><br/></p>

<p>同时，我们希望别人理解我们的处境，</p>

<p>但不强求。</p>

<p><br/></p>

<h2>谈起软件</h2>

<p>稳定需求，不代表设计可以不灵活。</p>

<p>设计巧妙，不代表需求可以不控制。</p>

<p><br/></p>

<p>外观易用，不代表结构简单。</p>

<p>结构复杂，不代表接口难懂。</p>

<p><br/></p>

<p>改代码，要少怀着尽量理解的心态。</p>

<p>写代码，要使用可以被理解的方式。</p>

<p>读书和写文章也是如此。</p>

<p><br/></p>

<p>不对称的对待矛盾，</p>

<p>是一种艺术，</p>

<p>让我们可以同时获得双方的优点。</p>

<p><br/></p>

<p>当我们抛弃了矛盾的一方，</p>

<p>就抛弃了一半可能性。</p>

<p><br/></p>

<p>智者总是可以心怀天下，</p>

<p>哪怕有各种不平和怨恨。</p>

<p><br/></p>

<h2>结语</h2>

<p>世无孔子，谁能定是非之真？</p>

<p>然则人之失者未必非得也，</p>

<p>吾之无失者未必非大失也。</p>

<p>而彼此相嗤无有已时，</p>

<p>曾观弈者之不若已！</p>

<p>——《弈喻》</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[潮流的推手]]></title>
    <link href="https://thzt.github.io/blog/2015/08/23/tendency/"/>
    <updated>2015-08-23T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/08/23/tendency</id>
    <content type="html"><![CDATA[<p>如果我们紧跟技术潮流的话，</p>

<p>就会发现，</p>

<p>日新月异的并不是技术本身，</p>

<p>而是人们对技术的宣传。</p>

<p><br/></p>

<p>大小的商业集团，</p>

<p>为了争夺市场，</p>

<p>吹捧着他们的最佳实践，</p>

<p>掠夺着劳动力。</p>

<p><br/></p>

<p>我们做着量产的事情，</p>

<p>拿着微薄的收入，</p>

<p>赚钱的事情怎么会让给我们呢，</p>

<p>推手们获得丰厚的利润。</p>

<p><br/></p>

<p>在过去的任何年代，</p>

<p>历史都不是一脉相承的，</p>

<p>各个流派百家争鸣，</p>

<p>共同影响着那个时代的人。</p>

<p><br/></p>

<p>培根说，</p>

<p>读史使人明智。</p>

<p><br/></p>

<p>只有梳理好过去，</p>

<p>才能看清舞台上的小丑，</p>

<p>方法其实是多样的，</p>

<p>言语代表了各自的立场。</p>

<p><br/></p>

<p>Fortran,Lisp,Basic,Pascal,</p>

<p>C,Prolog,ML,SmallTalk,</p>

<p>Scheme,C++,Common Lisp,Matlab,</p>

<p>Objective-C,Erlang,Perl,Haskell,</p>

<p>Python,Visual Basic,Ruby,</p>

<p>Lua,Java,Delphi,JavaScript,</p>

<p>PHP,D,C#,Go,Rust&hellip;</p>

<p><br/></p>

<p>就只拿编程语言来说，</p>

<p>他们的发展也不是线性的，</p>

<p>而是构成了一个图，</p>

<p>互相作用互相影响着。</p>

<p><br/></p>

<p>以前火爆的技术，</p>

<p>现在去了哪里，</p>

<p>立于不败之地，</p>

<p>不是技术最终的归宿。</p>

<p><br/></p>

<p>HTML,Java Applet,JavaScript,CSS,</p>

<p>QuickTime,ActiveX,Flash,CGI,</p>

<p>PHP,.NET,J2EE,AJAX,</p>

<p>Rails,jQuery,Node,Backbone,</p>

<p>Angular,BootStrap,RESTful,React,nw.js&hellip;</p>

<p><br/></p>

<p>转眼几年间，</p>

<p>Web技术产生了翻天覆地的变化，</p>

<p>那些过去的辉煌，</p>

<p>现在怎么样了。</p>

<p><br/></p>

<p>虽然我们没有机会改变世界，</p>

<p>但是可以见证它的发展，</p>

<p>同时代的新同学们，</p>

<p>可能没有这么幸运。</p>

<p><br/></p>

<p>浪潮的一个短暂扰动，</p>

<p>就可能让我们以为发现了真理，</p>

<p>紧握手中的冰刃，</p>

<p>看不到更尖端的科技。</p>

<p><br/></p>

<p>无所谓了，</p>

<p>世界以前就是这样的，</p>

<p>今后还是会如此。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Call/cc是怎样实现的]]></title>
    <link href="https://thzt.github.io/blog/2015/08/20/implementation-of-callcc/"/>
    <updated>2015-08-20T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/08/20/implementation-of-callcc</id>
    <content type="html"><![CDATA[<p>想象力比知识更重要。</p>

<p>——爱因斯坦</p>

<p><br/></p>

<p><strong>在大脑中第一个构想出来的人是天才，</strong></p>

<p><strong>后人只是一遍又一遍实现它最初的设想罢了。</strong></p>

<p><br/></p>

<p>call/cc如此，</p>

<p>lisp语言本身又何尝不是？</p>

<p><br/></p>

<p>一堆括号字母和空格，</p>

<p>构筑了美妙的外观。</p>

<p><br/></p>

<p>才有了后来者各种各样的实现。</p>

<p><br/></p>

<p><strong>这是一种自顶向下的设计思路，</strong></p>

<p>用构想作为目的，</p>

<p>用实现来支撑。</p>

<p><br/></p>

<p>与测试驱动开发，</p>

<p>有异曲同工之妙。</p>

<p><br/></p>

<h2><strong>放飞自己的想象力</strong></h2>

<p><strong>假如</strong>，我们有了一堆符号，</p>

<p>如何手动控制程序跳转？</p>

<p><br/></p>

<p>这个跳转方式，既然可以手动触发，</p>

<p>那一定是可以调用的。(k)</p>

<p><br/></p>

<p>k是哪来的？</p>

<p>一定是从什么地方创建的。</p>

<p><br/></p>

<p>跳转到哪里？</p>

<p>一定是跳转到创建它的位置之后。</p>

<p><br/></p>

<p>这个k是怎么过来的？</p>

<p>它一定当做参数传递过来的。</p>

<p><br/></p>

<p>k需要传递参数过去吗？</p>

<p>最好是需要，我们不想纯粹依赖副作用编程。(k 1)</p>

<p><br/></p>

<p><strong>假如</strong>我们已经有k了，</p>

<p>并且在一个函数执行过程中调用了它，</p>

<p>(lambda (x)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;0</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(k 2)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;3)</p>

<p>执行完(k 2)后面的3还执行吗？</p>

<p>不执行了。</p>

<p>当前执行的这个函数还返回吗？</p>

<p>我们希望直接跳转到k定义的位置了。</p>

<p><br/></p>

<p>那么函数的执行过程就要重新理解了，</p>

<p>先求值函数体，</p>

<p>然后跳转到给定的位置。</p>

<p><br/></p>

<p>函数执行的结果，</p>

<p>并不一定是“返回”到调用的位置了。</p>

<p><br/></p>

<p>这个跳转可否理解成调用了k呢？</p>

<p>在函数调用处定义k，</p>

<p>执行完以后，用函数体的值v，调用k，</p>

<p>(k v)。</p>

<p><br/></p>

<p>嗯嗯，</p>

<p>就这么干，先从函数体执行后，</p>

<p>可以控制跳转位置开始。</p>

<p><br/></p>

<h2><strong>把以后要做什么当做参数传过去</strong></h2>

<p>我们先看看，</p>

<p>旧观念中的“函数返回”是怎么绑架我们思维的。</p>

<p><strong>为什么函数一定要“返回”？</strong></p>

<p><br/></p>

<p>实际上，从机器的角度来看，</p>

<p>并不存在自动的返回机制，</p>

<p>调用一个函数，会把调用前的代码位置，先存起来。</p>

<p>然后去执行函数体的中代码，这可能在代码段的其他位置，</p>

<p>执行完后，再把以前存起来的位置恢复，</p>

<p>就完成了“返回”操作。</p>

<p><br/></p>

<p>现在我们不想这么干了，</p>

<p>我们不想让底层实现自动决定如何返回。</p>

<p><br/></p>

<p>例如：</p>

<p>(define (fn x)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(+ x 1))</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;</p>

<p>(define (gn y)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(fn y))</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;</p>

<p>(gn 2)</p>

<p><br/></p>

<p>我们调用了gn，gn又调用了fn，</p>

<p>fn执行完以后，返回gn，然后gn又返回，</p>

<p>像fn这样返回以后，调用者也返回的调用，称为<strong>尾调用</strong>。</p>

<p><br/></p>

<p>尾调用fn，本来没有必要返回gn内部，</p>

<p>直接返回gn该返回的位置就行了。</p>

<p><br/></p>

<p><strong>这就要求我们把函数执行完以后，</strong></p>

<p><strong>把“要做什么”当做参数传过去。</strong></p>

<p><br/></p>

<p>(define (final-cont v)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(display v))</p>

<p><br/></p>

<p>(define (fn x cont)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(cont (+ x 1)))</p>

<p><br/></p>

<p>(define (gn y cont)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(fn y (lambda (v)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(cont v))))</p>

<p><br/></p>

<p>我们在REPL中，一个表达式求值以后，就是打印它。</p>

<p>所以，我们创建一个最终要做的事情，final-cont</p>

<p><br/></p>

<p>先调用fn试试。</p>

<p>(fn 2 final-cont)</p>

<p>果然打印出了3。</p>

<p><br/></p>

<p>因为我们把打印这件事当做函数传过去了，</p>

<p>随时都可以调用。</p>

<p><br/></p>

<p>至于(cont (+ x 1))执行完后，fn不是还要返回的吗？</p>

<p>我们暂时可以认为是无用的数据，丢弃了，</p>

<p>后面再深入讨论。</p>

<p><br/></p>

<p>然后再调用(gn 2)试试。</p>

<p>(gn 2 final-cont)</p>

<p>就会去调用</p>

<p>(fn y (lambda (v)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(cont v)))</p>

<p>这里cont是final-cont</p>

<p><br/></p>

<p>然后调用fn了，(cont (+ x 1))</p>

<p>fn中的cont就是</p>

<p>(lambda (v)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(final-cont v))</p>

<p><br/></p>

<p>结果也是打印了3，正确输出。</p>

<p><br/></p>

<p>这是一个常函数，为什么要执行呢，</p>

<p>这是模拟fn执行完以后返回gn。</p>

<p>实际上，因为fn是尾调用，</p>

<p>我们只需要把gn中的cont传递给fn即可。</p>

<p><br/></p>

<p>(define (gn y cont)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(fn y cont))</p>

<p><br/></p>

<p>gn中的cont本来是final-cont，</p>

<p>是gn执行完以后要做的事情，</p>

<p>现在不加改变的，传递给了fn，</p>

<p>是不是相当于fn直接返回到gn该返回的位置了呢？</p>

<p>非常巧妙。</p>

<p><br/></p>

<p>其中，作为参数传递的cont，称为<strong>Continuation</strong>，</p>

<p>这种把“要做什么”当做参数传递的手法，称为<strong>Continuation传递风格（CPS）</strong>。</p>

<p><br/></p>

<h2><strong>用call/cc设置跳转点</strong></h2>

<p>我们实际上不想每次都传递continuation，</p>

<p>只想在需要的时候调用它，</p>

<p>怎样产生我们需要的跳转点呢？</p>

<p><br/></p>

<p>call/cc就是做这个的。</p>

<p><br/></p>

<p>;before</p>

<p>(call/cc (lambda(k)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(define (fn x)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(k (+ x 1)))</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(define (gn y)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(fn y))</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(gn 2))</p>

<p>;after</p>

<p><br/></p>

<p>用call/cc产生了一个跳转点，</p>

<p>它把call/cc位置处“以后要做什么”，包装成了参数k。</p>

<p><br/></p>

<p>对的，k虽然是函数的参数，</p>

<p>但是它也可以是一个函数。</p>

<p><br/></p>

<p><strong>其实k不是函数，是一个包装了continuation的对象，</strong></p>

<p><strong>它的调用机制，就是把包装的continuation提取出来调用一下。</strong></p>

<p><br/></p>

<p>反正k可以当做函数的参数传递，</p>

<p>像这样可以当做参数传递，可以作为函数的返回值的，k</p>

<p>称为first-class的，<strong>first-class continuation</strong>。</p>

<p><br/></p>

<p>我们看下执行流程，</p>

<p>先调用call/cc，设置了跳转点。</p>

<p><br/></p>

<p>然后，就进入(lambda (k) &hellip;)中了，</p>

<p>其中k是call/cc处的continuation，</p>

<p>可以表示为</p>

<p>k = (lambda (v)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;;after</p>

<p>)</p>

<p><br/></p>

<p>拿着call/cc的值，再执行after操作，</p>

<p>不就是“要做什么”的意思吗？</p>

<p><br/></p>

<p>进入(lambda (k) &hellip;)以后，</p>

<p>定义了两个函数，fn和gn，</p>

<p>然后调用gn。</p>

<p><br/></p>

<p>gn调用了fn，fn又调用了k，</p>

<p>那么call/cc就直接返回了，程序跑到了k所示的跳转点了，</p>

<p>接着执行after操作。</p>

<p><br/></p>

<h2><strong>一种实现方式</strong></h2>

<p>有了用例，</p>

<p>实现起来就简单多了。</p>

<p><br/></p>

<p>call/cc有很多方式实现，</p>

<p>我们只看下简单的解释实现。</p>

<p><br/></p>

<p>首先解释器的入口eval-exp要改，</p>

<p>(eval-exp &lsquo;1 *env* *cont*)</p>

<p>需要传递一个最原始的“以后要做什么”，</p>

<p>(define *cont* (lambda (v)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(display v)))</p>

<p><br/></p>

<p>然后，遇到(call/cc &hellip;)，我们这样处理，</p>

<p><br/></p>

<p>(define (eval-call/cc exp env cont)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(display &ldquo;eval-call/cc\n&rdquo;)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let ((fn (cadr exp))</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(continuation (make-continuation cont)))</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eval-function-call-list `(,fn ,continuation) env cont)))</p>

<p><br/></p>

<p>先拿到call/cc后面的那个lamabda，</p>

<p>然后用一个包装过的对象调用它，</p>

<p><strong>k就是这个包装过的对象continuation了</strong>。</p>

<p><br/></p>

<p>我们再看看continuation对象调用的时候怎么处理，</p>

<p><br/></p>

<p>(define (eval-continuation-call exp env cont)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(display &ldquo;eval-continuation-call\n&rdquo;)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(eval-exp (car exp) env</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda (continuation)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let ((wrapped-cont (continuation-cont continuation)))</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eval-exp (cadr exp) env</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda (arg)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(wrapped-cont arg)))))))</p>

<p><br/></p>

<p>嵌套很深嘛，</p>

<p>没关系，其实只是解开continuation对象的封装，</p>

<p>把原始的cont拿出来，</p>

<p>然后先求值(k (+ x 1))中的(+ x 1)，</p>

<p>求值完了以后，</p>

<p>再调用包装中的cont。</p>

<p><br/></p>

<p><strong>这里比较新颖的地方是，因为整个解释器已经改成了CPS方式</strong>，</p>

<p><strong>所以，顺序结构都要改成回调方式，</strong></p>

<p>(let ((arg (eval-exp (cadr exp) env)))</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(wrapped-cont arg))</p>

<p><br/></p>

<p>要变成，</p>

<p>(eval-exp (cadr exp) env</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(lambda (arg)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(wrapped-cont arg)))</p>

<p><br/></p>

<p>然后呢，</p>

<p>还需要做什么呢？</p>

<p>没有了。</p>

<p>就完了。</p>

<p><br/></p>

<h2><strong>偷偷借用的Scheme尾调用优化机制</strong></h2>

<p><strong>我们前面埋了一个雷。</strong></p>

<p><br/></p>

<p>重新来看看，</p>

<p>(define (final-cont v)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(display v))</p>

<p><br/></p>

<p>(define (fn x cont)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(cont (+ x 1)))</p>

<p><br/></p>

<p>(define (gn y cont)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(fn y cont))</p>

<p><br/></p>

<p>(gn 2)</p>

<p><br/></p>

<p>感觉上的执行过程是这样的，</p>

<p>gn调用了fn，fn调用cont，</p>

<p>cont返回，fn返回，gn返回，</p>

<p>回到了top-level。</p>

<p><br/></p>

<p>并非我们想的，</p>

<p>gn调用fn，fn调用cont，</p>

<p>cont直接返回到top-level。</p>

<p><br/></p>

<p>其实，在Scheme语言中，后者是对的。</p>

<p>确实直接返回到了top-level。</p>

<p><br/></p>

<p>因为语言规范指定，</p>

<p><strong>Scheme必须实现尾调用优化，</strong></p>

<p>指的就是这个。</p>

<p><br/></p>

<p>如果是尾调用，那么不用返回到调用处了，</p>

<p>只需要返回到调用者该返回的地方即可。</p>

<p><br/></p>

<p>这样我们解释器里面实现的call/cc，</p>

<p>更理直气壮了。</p>

<p>哪怕我们把*cont*传的再远，</p>

<p>也会直接返回到top-level，</p>

<p>不会导致一系列的调用栈弹栈操作。</p>

<p><br/></p>

<p>因为解释器实现中所有的函数调用都是尾调用。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>实际上，call/cc的编译实现还是比较麻烦的，</p>

<p><br/></p>

<p>本来调用结构是<strong>栈型</strong>的，</p>

<p>函数调用时，新建一个frame，添加到环境顶端，</p>

<p>返回时，弹栈。</p>

<p><br/></p>

<p>后来，为了实现闭包，</p>

<p>因为闭包具有无限生存期，</p>

<p>这个frame有可能以后还会用到，</p>

<p>所以，我们必须用<strong>链表</strong>来表示环境了，</p>

<p>函数返回后，并不会删除frame，只是暂时不链接到它了，</p>

<p>等待垃圾回收器来处理。</p>

<p><br/></p>

<p>再以后，</p>

<p>我们的执行过程，可以往前跳转了，</p>

<p>跳转到设置好的点，再分叉执行，</p>

<p>结果，环境就是一个<strong>树型</strong>结构了。</p>

<p><br/></p>

<p>每调用一个函数，</p>

<p>树增加了一个子节点，</p>

<p>函数返回，或者调用k，返回到以前的某个父节点，</p>

<p>因为还可能再回来，也可能重新执行一遍，</p>

<p>所以，再回来和重新执行必须同时保存下来，</p>

<p>成了两个分支。</p>

<p><br/></p>

<p>然而，这种<strong>树型调用图</strong>，</p>

<p>比<strong>goto语句</strong>更容易控制，</p>

<p>这也是call/cc的巧妙之处。</p>

<p><br/></p>

<p>当然call/cc用的时候，最好也封装一下，</p>

<p>免得k传递的到处都是。</p>

<p>不是吗，工具早就有了，</p>

<p>用的好不好，体现了工程师的水平。</p>

<p><br/></p>

<p>参考：</p>

<p><a href="https://github.com/thzt/scheme-interpreter/tree/master/continuation">源码</a></p>

<p><a href="https://github.com/ultimate-lambda/book-reviews/wiki/Essentials-of-Programming-Languages">Essentials of Programming Languages</a></p>

<p><a href="https://github.com/ultimate-lambda/book-reviews/wiki/Concepts-in-Programming-Languages">Concepts in Programming Languages</a></p>

<p><a href="http://book.douban.com/subject/1456904/">Lisp in small pieces</a></p>

<p><a href="http://book.douban.com/subject/1762126/">Compiling with Continuations</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[思想与表达]]></title>
    <link href="https://thzt.github.io/blog/2015/08/17/express-your-mind/"/>
    <updated>2015-08-17T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/08/17/express-your-mind</id>
    <content type="html"><![CDATA[<p>Math is about ideas, formulas are just a way to express them.</p>

<p><strong>数学研究的是思想，公式只是表达思想的一种方式。</strong></p>

<p><br/></p>

<p>看到这句话时，感觉它内涵非常深刻，</p>

<p>从模型论的高度，</p>

<p>表达了语法和语义的深层联系。</p>

<p><br/></p>

<p>我们尝试修改一下，</p>

<p>就会得出对程序员们帮助很大的一句话。</p>

<p><br/></p>

<p>Programming is about ideas, languages are just a way to express them.</p>

<p><strong>编程也是一种思维活动，编程语言只是表达思想的一种手段。</strong></p>

<p><br/></p>

<h2><strong>抓住闪光</strong></h2>

<p>当我们被要求做一件事的时候，</p>

<p>其实并不是在实现自己的想法。</p>

<p><br/></p>

<p>我们似乎，没有自己的想法，</p>

<p>一直在按别人说的做。</p>

<p><br/></p>

<p>然而，</p>

<p>找理由是没有用的。</p>

<p><br/></p>

<p>没有自己的想法，</p>

<p>不是教育的悲哀，</p>

<p>而是学生的悲哀。</p>

<p><br/></p>

<p><strong>没有人能限制我们考虑什么，</strong></p>

<p><strong>只有自己能导致懒得去考虑什么。</strong></p>

<p><br/></p>

<p>因此，我们要学会捕捉新奇的观点，</p>

<p>并记录下来，</p>

<p>偶尔拿出一些来实现。</p>

<p><br/></p>

<h2><strong>多说无益</strong></h2>

<p>和人类的语言一样，</p>

<p>表达同一个思想，可能有多种方式，</p>

<p>甚至用多种语言表达同一个观点。</p>

<p><br/></p>

<p>很多人知道这些，但是奇怪的是，</p>

<p><strong>每个人都认为自己的方法才是最好的。</strong></p>

<p><br/></p>

<p>编程语言之争，就是这样，</p>

<p>通常发生在不了解另一个语言的时候。</p>

<p><br/></p>

<p><strong>人们只会争执自己不熟悉的东西。</strong></p>

<p>而对熟悉的东西，往往觉得各有利弊。</p>

<p><br/></p>

<p>因此，</p>

<p>我们要开阔自己的视野，</p>

<p>想办法站在同一个高度，看待问题的双方。</p>

<p><br/></p>

<h2><strong>言简意赅</strong></h2>

<p>清晰的表达自己的思想，</p>

<p>并不是件容易的事情。</p>

<p><br/></p>

<p>和人类语言不同，</p>

<p>代码不能写成针对某个人看的，</p>

<p>因为意想不到的读者太多了。</p>

<p><br/></p>

<p>而且，代码是活的生命体，</p>

<p>读者也是不断进步的人群。</p>

<p><br/></p>

<p><strong>把复杂的细节，隐藏在简洁的表象下面，</strong></p>

<p>是个好主意。</p>

<p><br/></p>

<p>这让我们有能力面对以后更复杂的场景。</p>

<p><br/></p>

<h2><strong>轻装上阵</strong></h2>

<p>和能工巧匠一样，</p>

<p>良好的设计，诚然重要，</p>

<p>而精湛的技艺也不可缺少。</p>

<p><br/></p>

<p>代码是要经过打磨和润色的，</p>

<p>编程技艺体现在每一次的修改中。</p>

<p><br/></p>

<p>它是否向着更精巧别致的方向发展了，</p>

<p>是否潜在的扩展能力发生了变化。</p>

<p><br/></p>

<p><strong>好的代码，</strong></p>

<p><strong>让以后的演进，都好像从零开始那么简单，</strong></p>

<p>没有负担的前进。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>抱怨需求变更太快的人们，</p>

<p>通常一开始没有做好应对变更的准备。</p>

<p><br/></p>

<p>因为，早就应该识别出这个易变的特点，</p>

<p>不是吗？</p>

<p><br/></p>

<p>这就是考验技艺的时候了，</p>

<p>来自能工巧匠之手的代码，可以响应需求的变更。</p>

<p><br/></p>

<p><strong>拙劣的实现，</strong></p>

<p><strong>阻碍思想的演变。</strong></p>
]]></content>
  </entry>
  
</feed>
