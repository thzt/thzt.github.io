<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[何幻]]></title>
  <link href="https://thzt.github.io/atom.xml" rel="self"/>
  <link href="https://thzt.github.io/"/>
  <updated>2016-05-12T13:59:57+08:00</updated>
  <id>https://thzt.github.io/</id>
  <author>
    <name><![CDATA[thzt]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何突破瓶颈]]></title>
    <link href="https://thzt.github.io/blog/2016/05/12/break-through-the-bottleneck/"/>
    <updated>2016-05-12T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/05/12/break-through-the-bottleneck</id>
    <content type="html"><![CDATA[<p>经常遇到有人说，</p>

<p>我现在处于『<strong>瓶颈期</strong>』，无法突破。</p>

<p><br/></p>

<p>什么是瓶颈期呢？</p>

<p>维基百科上这样解释：</p>

<p>瓶颈期为事物在变化发展过程中因无法改变<strong>自身条件</strong>和<strong>外部环境</strong>的情况下，而产生的一个停滞时期。</p>

<p><br/></p>

<p>这个停滞期在学习过程中会出现很多次，</p>

<p>每次遇到都会觉得无处发力，不能超越自己，</p>

<p>而每次突破，都能感觉到明显的进步。</p>

<p><br/></p>

<p>既然，瓶颈期是一个经常出现的现象，</p>

<p>那么突破它的策略，就有<strong>规律</strong>可循了。</p>

<p>通过仔细的分析，我们下文将看到。</p>

<p><br/></p>

<p>是什么造成了瓶颈期？</p>

<p>为什么无法突破瓶颈？</p>

<p>下一个瓶颈为什么更难突破？</p>

<p><br/></p>

<h2><strong>原因</strong></h2>

<p>所谓学习和进步，实际上指的是<strong>对自己有利的改变。</strong></p>

<p>之所以出现停滞期，是因为我们无法做出这些改变了，</p>

<p>我们无法改变自身或者环境，无法更新自己。</p>

<p><br/></p>

<p>对于大多数人而言，环境只能选择，无法迅速改变它，</p>

<p>而选择环境的过程，也是先从改变自己开始的。</p>

<p><br/></p>

<p>所以，停滞期的原因一下子就明朗了，</p>

<p>那就是<strong>行为习惯造成了我们的惰性，使我们不想或无法做出改变。</strong></p>

<p><br/></p>

<p>不主动做出改变，只依靠环境来影响自己，</p>

<p>长此以往，当我们<strong>适应环境</strong>的时候，</p>

<p>瓶颈期就来了，不可避免的来了。</p>

<p><br/></p>

<p>环境已经无法给我们带来新知识了，</p>

<p>内在的更新意识也没有形成，也没有改变环境的契机出现，</p>

<p>一切还是跟昨天一样，那么的平淡无奇，这就是瓶颈。</p>

<p><br/></p>

<p>因此，不要再沉迷过去了，不要再停留了，</p>

<p><strong>做出改变吧，不要等明天，就从现在开始。</strong></p>

<p><br/></p>

<h2><strong>策略</strong></h2>

<p>我们已经决定做出改变了，不达目的誓不罢休。</p>

<p>可是，为什么我们不知道做什么，向哪个方向改变呢？</p>

<p><br/></p>

<p>往往这个时候，<strong>并不是没有改变的方向，</strong></p>

<p><strong>而是，可以改变的方向太多了，我们不知道选择哪个。</strong></p>

<p>哪个选择是最好的，我一直纠结这个，</p>

<p>于是，我什么都不想做，一直纠结到了明天。</p>

<p><br/></p>

<p>放弃吧，骚年。</p>

<p><strong>何不对每个可能的选择做出敏捷的尝试呢？</strong></p>

<p>我们总是对神秘的事物保持自卑和敬畏，</p>

<p>是因为我们从未主动向前探出一步。</p>

<p><br/></p>

<p>因此，我们的策略也就清晰了。</p>

<p>首先，对每个可能的改变，全部做出<strong>试探</strong>，寻找兴趣点，</p>

<p>然后，找到兴趣点后，确立未来的<strong>目标</strong>，</p>

<p>第三，分析目前的状态和目标之间的<strong>差距</strong>，</p>

<p>最后，制定行之有效的短期<strong>计划</strong>，逐步实现它。</p>

<p><br/></p>

<p>这其实是一个<strong>目标管理过程</strong>，</p>

<p>是管理专家彼得·德鲁克（Peter Drucker）在1954年的名著《管理实践》中最先提出的，</p>

<p>德鲁克认为，<strong>并不是有了工作才有目标，而是相反，有了目标才能确定工作内容。</strong></p>

<p><br/></p>

<p>诚然，目标管理对大多数人来说是一个生疏的概念，</p>

<p>可是，<strong>确定目标</strong>，仍然是大环境下同学们的难题，</p>

<p>无法走出第一步，寻找到<strong>兴趣点</strong>，是应试教育的悲剧。</p>

<p><br/></p>

<h2><strong>包袱</strong></h2>

<p>可能，某些人已经越过了好多个瓶颈期了，</p>

<p>从技术修炼，到团队管理，</p>

<p>从不善交流，到布道表达，</p>

<p>从独善其身，到兼济天下。</p>

<p><br/></p>

<p>他们会发现，<strong>每一个瓶颈期的突破都更难一分</strong>，</p>

<p>我虽然知道要做出改变了，为何还是无法行动？</p>

<p>这是因为历史的包袱和惯性。</p>

<p><br/></p>

<p>可能，曾经对某个领域进行了尝试，心灰意冷，</p>

<p>就失去了以后<strong>再次尝试</strong>的热情。</p>

<p>可能，改变工作地点，会导致拖家带口的行动，</p>

<p>这么大的<strong>麻烦</strong>，会阻碍我们做出最有利的决策。</p>

<p>可能，某个知识点太难了，如果学它，</p>

<p>那意味着我要开始画更大的圆，我<strong>没那么多精力</strong>。</p>

<p><br/></p>

<p>这些都是心理包袱，是一切没有尝试的懒惰者的借口。</p>

<p><br/></p>

<p><strong>是我们的每一次决定，而不是努力，</strong></p>

<p><strong>改变了我们的人生轨迹。</strong></p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>与其说，我们谈论了瓶颈期，</p>

<p>不如说，我们讨论了<strong>改变自己的方法论</strong>。</p>

<p><br/></p>

<p>这个方法，不仅适用于个人，</p>

<p>还适用于团队，企业，等团体组织。</p>

<p><br/></p>

<p>大胆试错，是一个必要的环节，</p>

<p>如何降低试错成本，如何提高试错的速度，</p>

<p>是另一个不小的话题。</p>

<p><br/></p>

<p><strong>失敗固然痛苦，但更糟糕的是从未去尝试。——西奧多·罗斯福</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[出奇制胜]]></title>
    <link href="https://thzt.github.io/blog/2016/04/27/surprise-move/"/>
    <updated>2016-04-27T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/04/27/surprise-move</id>
    <content type="html"><![CDATA[<p>孙子兵法『兵势篇』中提到，</p>

<p>凡战者，以正合，以奇胜。</p>

<p><br/></p>

<p>战争一开始时局势不太明朗，双方旗鼓相当时就是『以正合』的阶段，</p>

<p>而到后来局势开始明朗，到了决战时刻就是『以奇胜』的时候。</p>

<p><br/></p>

<p>对于『以奇胜』，不同的人有不同的解释，这很正常，</p>

<p>有人说『奇』读作ji，表示预备队，</p>

<p>然而，理解为qi，也无碍，只看目前哪种理解对我们有用。</p>

<p><br/></p>

<p>学习过程，就好像一场持久战，</p>

<p>个人的竞争力与我们采用的学习策略紧密相关。</p>

<p>出奇制胜，指的是用对方意料不到的方法取得胜利。</p>

<p><br/></p>

<p>如何做到这一点呢？</p>

<p>还要从几个层面来说明。</p>

<p><br/></p>

<h2><strong>先不败而后谋胜</strong></h2>

<p>无论从事什么行业，学习什么领域的知识，</p>

<p>扎实的基本功都是很重要的，</p>

<p>为什么呢？</p>

<p><br/></p>

<p>因为，首先要做到不被轻易打败，才能抓住获胜的机会。</p>

<p><br/></p>

<p>以正兵合战，就是这个道理。</p>

<p>合战时输了，奇兵就没有用武之地了。</p>

<p><br/></p>

<p>这个道理还可以用来指导团队建设，</p>

<p>只有在平时不溃败，在关键时期才能发挥更大力量。</p>

<p><br/></p>

<p>怎样才能做到不败呢？</p>

<p>这就要求我们乐于向其他人学习，关注别人在做什么，</p>

<p>用别人的优点，对比自己的弱点，努力弥补。</p>

<p><br/></p>

<p>正面看没有弱点，是制胜的先决条件。</p>

<p><br/></p>

<h2><strong>行进中开火</strong></h2>

<p>Joel Spolsky在『Fire And Motion』中提到，</p>

<p>在进行中开火，你要一边开火一边朝着敌人冲过去，</p>

<p>火力让敌人抬不起头来，不能朝你开火。</p>

<p>前进了，你就可以占领阵地接近敌人，从而搞清楚形势，增加胜算。</p>

<p><br/></p>

<p>在学习过程中，有很多敌军向我方开火的例子。</p>

<p><br/></p>

<p>各路大神发表了数不胜数的文章，会让我们乱了阵脚，</p>

<p>我们无法达到他们中任何一个人的高度。</p>

<p>各个公司，发布了眼花缭乱的类库，框架，开发工具，</p>

<p>让我们沉浸在跟风中无法自拔。</p>

<p><br/></p>

<p>这是敌军在向我们开火呀。</p>

<p><br/></p>

<p>根据别人的优势来规划自己的学习路线，</p>

<p>就会时刻处于被动。</p>

<p>没有自己的优势，就好比刺刀没有开刃一样。</p>

<p><br/></p>

<p>因此，我们要认识自己，找到，</p>

<p>行业的需要，自己的优势，别人的劣势，</p>

<p>三线合一，敢于亮剑。</p>

<p><br/></p>

<h2><strong>后劲十足</strong></h2>

<p>司马懿说过，『夫处世之道，亦即应变之术，岂可偏执一端？』</p>

<p>我们再来看下，如果『奇』理解为ji，我们还有什么收获。</p>

<p><br/></p>

<p>奇兵，指的是预备队，</p>

<p>『以正合，以奇ji胜』，可以解释为，</p>

<p>不要一下子把所有的牌都打完，留一些在手上，关键时候打出去。</p>

<p><br/></p>

<p>这就告诉我们，要留有余地，保持后劲。</p>

<p>做人的道理也是如此，学习和成长都是悄悄完成的。</p>

<p>后劲也必须要有顽强的毅力才能打造出来。</p>

<p><br/></p>

<p>互联网时代，碎片化知识遍布，分散了我们的精力，</p>

<p>让我们没有时间系统的学习任何一块知识，</p>

<p>以奇ji胜，指导我们，在课下静下心来系统学习，维持后劲。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>大家都在学习，那么学习的策略就有了意义，</p>

<p>大家都在努力，那么努力的方向就有了意义。</p>

<p><br/></p>

<p>知识只是学习内容的一种，</p>

<p>对学习策略的调整，本身也是一种学习吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[教育和职业]]></title>
    <link href="https://thzt.github.io/blog/2016/03/18/education-and-career/"/>
    <updated>2016-03-18T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/03/18/education-and-career</id>
    <content type="html"><![CDATA[<p><link href="https://thzt.github.io/stylesheets/p.css" rel="stylesheet"/></p>

<p>随着工作年限的增加，职业路线的明确，越来越多关心我的朋友，对我大学专业和现在从事的职业产生了疑问。
我是一个物理学专业的学生，研究生专业也选择了理论物理，可为什么目前从事软件开发工作呢？
当我被问及此事时，总是难以简要的回答。</p>

<p>职业的选择是一个重要的事情，我明白失败的方式只有一种那就是半途而废。
经过一段时间的仔细考虑，我决定用这篇文章说清我心里的想法。
我区分开了教育的目的，和职业的需要，教育的目的并不是为了就业，而是为就业做好准备。</p>

<p><br/></p>

<h2><strong>教育的目的是为了打好基础</strong></h2>

<p>1693年，洛克在他的《教育漫话》中提出，『英国教育的目的是培养绅士，这种绅士，其实就是社会精英。』
我非常认可这种观点，教育的目的应该是给未来的职业发展打好基础，学那些在社会中无法静下心来学的知识。
教育和社会需要脱节，是当今社会浮躁的表现。</p>

<p>我庆幸自己学了基础学科，学习了自然科学，物理学专业的课表是把日程全占满的，我由衷的自豪。
我学过高等数学，线性代数，数学物理方法，概率论，学过力热光电原子物理，四大力学，激光原理，固体物理，学过模拟电路，数字电路，单片机，VB，C++。
这让我掌握了一套科学方法去理解这个世界，让我学会了用严谨的治学态度去做看待任何事情。
读研以后，我又学了高量，广相，李代数，学过微分流形，纤维丛，量子场论。
我对物理学有浓厚的兴趣，并且学了它，没有留下任何遗憾，我不用一辈子纠结自然界的科普问题了。</p>

<p>在这个过程中，最重要的是，我锻炼了学习能力，学会了把知识传递给别人，学会了交流，以及学会了把钻研精神用于生活中的方方面面。</p>

<p><br/></p>

<h2><strong>职业发展过程中需要坚持学习</strong></h2>

<p>在毕业时，我面临着两种选择，要么继续研究物理，要么走向社会。
经过仔细分析自己的优势和劣势，以及家庭条件，还有进行了市场调研，包括自己的兴趣，我选择了程序员这个职业。
软件是一个低门槛，但是后期学习曲线非常陡峭的行业，这就是为何程序员总是容易『吃青春饭』的原因了。</p>

<p>刚入行时，我查询到计算机专业的本科生学了这些知识，离散数学，编程语言，计算机组成原理，数据库，数据结构与算法，操作系统，计算机网络，编译原理，软件工程。
专业方面还有，数据挖掘，机器学习，人工智能等等。
于是，我找到了相应的书籍，努力学习，软件绝不是编程这么简单，我要做专业人士。</p>

<p>这才发现，当我有了物理学的基础和学习能力之后，自学它们并不困难。
经过3年多的努力，自我感觉已经达到计算机专业本科生的水平了，在部分自己感兴趣的领域也学的较为深入。
比如，lambda演算，类型理论，逻辑学。
编程语言方面，Scheme和Haskell也看得比较多，能在社区帮助一些初学者，回答一些简单的问题了。</p>

<p>到这里为止，在这个行业我算才入门了。后面的职业发展，才可以围绕这些基础建立起来。
以上的学习过程以及书单，请浏览：<a href="http://thzt.github.io/blog/2016/01/29/computer-science/">真实在哪里</a></p>

<p>我想，如果就业时，我选择的不是计算机行业，比如，教师行业，或者任何其他行业，我也会先把领域中的基础知识学好，再谋求发展。
学校教育学到的基础知识，以及锻炼出来的学习能力，原来如此重要啊。
教育的目的确实不应该向某个特定行业提供开箱即用的专才。</p>

<p><br/></p>

<h2><strong>有强大的学习能力才能做好前端</strong></h2>

<p>我从进入计算机行业起，就选择了前端，当时做过大量的调研，也查阅了很多圈内人士的文章。
学习前端与学习其他任何知识并没有什么不同，我只是把当时市面上能找到的关于JavaScript的好书看了一遍。
JavaScript权威指南，JavaScript高级编程，JavaScrip DOM高级程序设计，JavaScript模式，JavaScript精粹，高性能JavaScript，JavaScript异步编程，JavaScript设计模式，Secrets of the JavaScript Ninja，基于MVC的JavaScript Web富应用开发。</p>

<p>看完这些我心里就有底气了。CSS方面，我看的书较少，这里就不列了，工作需要的那些而已。
前端方面有一个特点，因为JavaScript这个语言细节特别多，对语言规范EcmaScript的学习就至关重要。
我从EcmaScript 3，看到了EcmaScript 5，然后就是最近的EcmaScript 2015，和Draft版的EcmaScript 2017。</p>

<p>看着前端这个方向发展迅猛，不禁又一次感叹基本功的重要性，当大家同时学一个知识点的时候，我有能力更快的学会它。
一些新兴的名词，immutable，flux，redux，FRP，等等，有了函数式语言的基础后，很容易理解它们。
这样才能做到心不乱，于是脚步才不会乱。</p>

<p>关于前端技术栈和编程语言对我的影响，请浏览：<a href="http://thzt.github.io/blog/2015/09/01/an-introduction-to-web-front-end/">前端程序员的自我修养</a>，<a href="http://thzt.github.io/blog/2015/06/04/language/">语言的威力</a></p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>当我列举书单的时候，我自己都觉得这看起来太浮躁了，我们无法通过言语来看出一个人背后的努力。</p>

<p>还记得，刚入行时早晨6点爬起来，看完50页书才去上班，还得保证是部门去的最早的那个；
还记得，晚上制定的50页计划，读完了才可以睡觉；
还记得，在项目组各处流窜，就是为了遇到更多的问题，赶紧学习并记录下来；
还记得，过年在家时，医院陪床时，地铁上，手机中闪亮的电子书；
还记得，无数次晚上忽然醒了，拿起手机，记下关于编程方法的点点滴滴。</p>

<p>如果不得不用十年才能学会编程，我情愿每天多花一个小时，让这个梦想早些实现。</p>

<p>蚓无爪牙之利，筋骨之强，上食埃土，下饮黄泉，用心一也。蟹六跪而二螯，非蛇鳝之穴无可寄托者，用心躁也。——荀子《劝学》</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[观看AlphaGo与李世石比赛有感]]></title>
    <link href="https://thzt.github.io/blog/2016/03/14/alphago/"/>
    <updated>2016-03-14T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/03/14/alphago</id>
    <content type="html"><![CDATA[<p>在这之前，我对围棋一窍不通，</p>

<p>但是深信任何领域都可以对其他领域产生触类旁通的影响。</p>

<p>为了能多学些道道，体会大师的精髓，</p>

<p>这次对人机大战关注了不少。</p>

<p><br/></p>

<p>在此之前，几乎为了同样的目的，</p>

<p>我专门看过一部叫做《棋魂》的漫画，</p>

<p>它使我印象深刻，获益良多。</p>

<p><br/></p>

<p>讲的是一个小学生——近藤光，</p>

<p>无意间被旧棋盘上的古代围棋高手——藤原佐为，灵魂附体，</p>

<p>小光有了和佐为进行心灵对话的能力。</p>

<p><br/></p>

<p>由于佐为对『神之一手』的执着追求，</p>

<p>小光的生活产生了变化，</p>

<p>从接触围棋，到理解围棋，最后甚至达到了佐为所追求的最高境界。</p>

<p><br/></p>

<p>漫画中介绍了一群人，</p>

<p>他们为了同一个目的，不怕困难，不断努力。</p>

<p><br/></p>

<p>小光进入到专业棋坛之后，深深体会到了专业人士的辛酸和泪水，</p>

<p>这种体会让读者可以联想到任一行业，联想到自己现在所做的事情。</p>

<p>任何领域达到专业，都不是容易的事情，甚至对某些人来说根本不可能，哪怕再努力。</p>

<p><br/></p>

<p>然而，我们仍然要有追求『神之一手』的执着，</p>

<p>像佐为一样，历经千年仍旧灵魂不散。</p>

<p><br/></p>

<h2><strong>机器学习</strong></h2>

<p>这次人机大战的看点，莫过于人工智能的噱头了。</p>

<p>机器学习领域再一次吸引了大众的眼球。</p>

<p><br/></p>

<p>这个领域在学术圈一直很火，</p>

<p>去年为了了解它，我读了两本简单的入门书，</p>

<p>《集体智慧编程》和《统计学习方法》。</p>

<p><br/></p>

<p>阅读的目的其实是为了消除神秘性和盲目性，</p>

<p>能脚踏实地的理解这些新概念。</p>

<p><br/></p>

<p>机器学习领域水很深，远不是几本书几十本书就可以窥探的，</p>

<p>但是，对我来说，最明显的认识就是，</p>

<p>这些神秘的概念，其实是一些数学方法，</p>

<p>结合统计学，计算机科学，以及大数据，所进行的计算。</p>

<p><br/></p>

<p>比如，AlphaGo集以下方法于一身，</p>

<p>蒙特卡洛树搜索，估值网络，强化学习，等等。</p>

<p><br/></p>

<p>这让我认识到了知识的作用，</p>

<p>不但能用于改变世界，还能用于维持心态的平和。</p>

<p>知道原理后，就不会对人工智能产生恐慌，</p>

<p>就好比我们并不会惊讶计算器也可以得到1+1=2一样。</p>

<p><br/></p>

<h2><strong>人类的经验</strong></h2>

<p>与人对弈和与计算机对弈，确实是不同的。</p>

<p>不禁让人们反思，人类这么多年里总结的围棋经验，到底还有没有用。</p>

<p><br/></p>

<p>前三局，AlphaGo赢了李世石，打击了每一个人。</p>

<p>那些前人总结出来的所谓『定式』，是否本来就是有问题的？</p>

<p><br/></p>

<p>因为围棋涉及到博弈，涉及到资源的管理，涉及到统筹与规划，</p>

<p>如果数千年积累的经验，被机器证明了有更好的方法，</p>

<p>不知道是要高兴还是悲伤啊。</p>

<p><br/></p>

<p>这在一定程度上动摇了人们的自信，</p>

<p>人们越来越怀疑自己在局部进行决策的能力了，</p>

<p>如果不能看得更远，那么现在的决定还有没有用呢？</p>

<p><br/></p>

<p>这确实是一个值得反思的方面。</p>

<p><br/></p>

<p>另一方面，AlphaGo的表现，也让我们看到了科技的力量，</p>

<p>受大数据和机器学习的影响，用经验和感觉来指导实践的套路可能会改变，</p>

<p>数据和计算对决策来说，将占据越来越大的比重。</p>

<p><br/></p>

<p>这无疑是非常大进步。</p>

<p><br/></p>

<h2><strong>神之一手</strong></h2>

<p>第四局，李世石终于赢了。</p>

<p><br/></p>

<p>不少行家指出，李世石的第78手，下了一招妙棋，</p>

<p>导致AlphaGo决策失误，后面连续走出『臭棋』。</p>

<p><br/></p>

<p>且不管原因是什么，先看看我们的收获。</p>

<p><br/></p>

<p>这不禁让人感叹人类的直觉能力，</p>

<p>有很多东西是不能或者难以通过数据计算得到的，</p>

<p>人类更擅长在资源不足的情况下，通过直觉给出大致的选择。</p>

<p><br/></p>

<p>这时候，如果面面俱到，可能更慢，甚至是不可行的。</p>

<p><br/></p>

<p>那些行家们也指出，很多时候，</p>

<p>专业棋手，所追求的，不只是『赢了比赛』，</p>

<p>还有『赢得漂亮』，有审美因素包含其中。</p>

<p><br/></p>

<p>我觉得直觉是人类创造力的源泉，</p>

<p>美学的追求，能让人类看到从数据上无法预言的东西，</p>

<p>它指引我们去发现新事物，开辟新领域。</p>

<p><br/></p>

<p>创造力，是人与机器的重大区别。</p>

<p>穷举所有的选择，并不能有效的完成创造。</p>

<p><br/></p>

<h2><strong>胜败</strong></h2>

<p>围棋还关系到人们对胜败的理解，</p>

<p>怎样获胜，怎样韬光养晦，怎样示弱，都是兵法的精髓。</p>

<p><br/></p>

<p>第四局李世石能够胜利，跟布局阶段的隐忍有关。</p>

<p>他一反常态，并没有表现出那么强烈的攻击力，</p>

<p>而是稳扎稳打，先做到不败，才能有胜利的可能。</p>

<p><br/></p>

<p>这对我们为人处世，有很大的借鉴意义，</p>

<p>没有常胜将军，只有不可战胜的军队。</p>

<p><br/></p>

<p>做学问，搞项目，也是如此，</p>

<p>只有在平时努力训练，加强团队能力的建设，</p>

<p>才能打好基础，在关键时候扛住压力，不被击垮。</p>

<p><br/></p>

<p>胜兵先胜而后求战，败兵先战而后求胜，就是这个道理。</p>

<p><br/></p>

<p>另外，与竞技体育类似，讲究做好防守引诱对方发力，</p>

<p>借着破绽，才有机会获胜。</p>

<p>同时，也只有打好基础，才能在对方发力的时候不被一击致命，</p>

<p>留下有翻盘的可能。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>写这篇文章的时候，第五局还没有进行。</p>

<p>我迫不及待的写出此篇，因为收获简直是太大了。</p>

<p><br/></p>

<p>正如兵家所言，</p>

<p>胜败乃兵家常事。</p>

<p><br/></p>

<p>然而，这胜败之理，人们对『神之一手』的追求，</p>

<p>可是历经千年而不变啊。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[论工具]]></title>
    <link href="https://thzt.github.io/blog/2016/03/11/tools/"/>
    <updated>2016-03-11T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/03/11/tools</id>
    <content type="html"><![CDATA[<p>中学的历史课本上曾经讲过，</p>

<p>学会制作工具，是人类进步的标志。</p>

<p><br/></p>

<p>我深以为然。</p>

<p>可是现实生活中，<strong>存在着对工具很多的误解</strong>。</p>

<p><br/></p>

<p>有的人，认为制作工具浪费时间和精力，做了不必要的事情，</p>

<p>有的人，认为既然有现成的工具可用，为什么还要自己造轮子。</p>

<p>有的人，认为应该专门区分开制作工具的人和使用工具的人。</p>

<p><br/></p>

<p>这些看法，在各自的角度来讲，都说的通，</p>

<p>可以没有对工具有个<strong>全面的</strong>认识。</p>

<p><br/></p>

<p>下面，我们仔细分析一下，</p>

<p>看能不能从更高的角度来看待它，</p>

<p>做好工具，用好工具。</p>

<p><br/></p>

<h2><strong>工具就是解决方案</strong></h2>

<p>无论是日常生活中，还是在软件开发中，</p>

<p>我们经常有直接解决问题的场景，</p>

<p>貌似并没有使用工具。</p>

<p><br/></p>

<p>这就给了人们一种<strong>假象</strong>，</p>

<p>那种特意找来的才叫工具，</p>

<p>用了别人的东西，才叫用了工具。</p>

<p><br/></p>

<p>其实不然。</p>

<p>一个<strong>解决方案</strong>，实际上就是一个具体的工具了，</p>

<p>只不过它只能用来解决那个问题罢了。</p>

<p><br/></p>

<p>好的解决方案，就好比适用的工具，</p>

<p>用最直接的办法解决了问题，</p>

<p>不拖泥带水，不带来附加的问题。</p>

<p><br/></p>

<h2><strong>不得已而造轮子</strong></h2>

<p>着手实施的过程，</p>

<p>实际上就是将目前的项目问题<strong>还原</strong>成历史上已经解决过问题的过程。</p>

<p><br/></p>

<p>这个阶段，我们在进行问题求解。</p>

<p>为了尽可能的少耗费精力，我们总会优先选择已经成型的工具，</p>

<p>在软件开发中，相当于找到各种类库，框架来用。</p>

<p><br/></p>

<p>可是，市面上广为流传的那些通用工具，</p>

<p>并不一定非常切题，我们必须做出调整，甚至废弃一部分功能，</p>

<p>这个时候，就有点造轮子的萌芽了。</p>

<p><br/></p>

<p>随着业务的发展，业务模型逐渐清晰起来了，</p>

<p>没有趁手的工具，也无法跟得上业务的发展需要了，</p>

<p><strong>只能从基础开始，借用各种工具的设计思想，让工具和业务共同发展。</strong></p>

<p><br/></p>

<p>此之所谓，重新造轮子。</p>

<p><br/></p>

<p>这样不好吗？</p>

<p>在项目初期，诚然不太合适，</p>

<p>但是，全程中我们的目的都是为了找到合适的工具解决问题呀，</p>

<p>并没有偏离主题，并没有为了造而造。</p>

<p><br/></p>

<p>这也是<strong>不得已而为之</strong>的事情。</p>

<p><br/></p>

<h2><strong>工具的创造者和使用者</strong></h2>

<p>在大多数人眼中，</p>

<p>工具都是一些人造出来，给另外一些不同的人来使用的，</p>

<p>这里就又有误区了。</p>

<p><br/></p>

<p>其实不必强制如此，</p>

<p>一个能工巧匠，必然有<strong>自己的</strong>一套工具箱，</p>

<p>这些工具箱中都是他趁手的工具。</p>

<p><br/></p>

<p>这些工具，全是跟别人一样的吗？</p>

<p>未必啊。</p>

<p>有雷同的，有调整过的，更有自创的。</p>

<p><br/></p>

<p>工具完全可以自己造给自己用，是<strong>为了给自己的工作助力</strong>，</p>

<p>在软件行业，这有一个名词叫『dog fooding』，</p>

<p>很多软件公司都深谙此道。</p>

<p><br/></p>

<p>比如，Visual Studio本来只是Microsoft内部使用的一个编辑器，</p>

<p>随着不断完善，它完全可以作为一个产品来卖了，</p>

<p>那么就可以拿出来了，面向普通大众开放了。</p>

<p><br/></p>

<p>再比如，Facebook很多项目都主张尽量开源，</p>

<p>首先解决本公司自己的问题，</p>

<p>再通过解决社区的问题逐渐完善，同时也降低了维护成本。</p>

<p><br/></p>

<p>此外，如果不事先限定工具的未来使用者的话，</p>

<p>还会促进人们对工具进行更好的设计。</p>

<p><br/></p>

<p>另一方面，有些人喜欢写工具给别人用，</p>

<p>但是，<strong>眼高手低，只是解决一些假想的问题</strong>，过于理想主义。</p>

<p><br/></p>

<p>不能解决问题的工具，还不如没有，</p>

<p>它会造成解决方案的混乱，加大原始问题的难度。</p>

<p><br/></p>

<p>因此，工具的创造者和使用者，必须紧密合作。</p>

<p>工具才能发挥它最大的作用。</p>

<p><br/></p>

<h2><strong>业务逻辑并不啰嗦</strong></h2>

<p>有些人不喜欢写业务逻辑，说是因为它繁琐。</p>

<p>我觉得这是对编程认识的<strong>偏见</strong>。</p>

<p><br/></p>

<p>因为编程就是用代码解决问题的，</p>

<p>业务逻辑繁琐，本身就是一个问题。</p>

<p><br/></p>

<p>我们完全可以写一个业务逻辑的管理器，</p>

<p>把这些复杂业务逻辑分离开，然后用这个管理器统筹规划，</p>

<p>非常干净清爽了，不是吗？</p>

<p><br/></p>

<p>因此，这种情况下，代码要做的事情不是关键，</p>

<p><strong>关键在于，怎样写，用什么样的策略来写，</strong></p>

<p><strong>没有注定繁琐的代码，只有不合理的繁琐表述。</strong></p>

<p><br/></p>

<h2><strong>工具还可以用来制造工具</strong></h2>

<p>只要存在问题，我们就可以想到借助工具来解决它，</p>

<p>那么假设这里有好多人需要斧子这种工具，</p>

<p>就要造出那么多斧子来吗，好累啊。</p>

<p><br/></p>

<p>其实，这引出了另外一个问题，</p>

<p>那就是如何制造多个斧子的问题。</p>

<p><br/></p>

<p>我们可以造一个机器，它用来生产斧子，</p>

<p>这个机器，就是<strong>用来制造工具的工具</strong>，</p>

<p>而制作这个机器所用的道具，同样也是工具。</p>

<p><br/></p>

<p>原来，世界这么奇妙，</p>

<p>工具可以组合，还可以互相影响。</p>

<p><br/></p>

<h2><strong>学会别人的设计思想</strong></h2>

<p>当我们定位问题后，怎样将适用工具制造出来呢？</p>

<p>现存的解决方案是怎样想出来的呢？</p>

<p><br/></p>

<p>这就得求助历史了，求助于同行们前辈们的经验教训。</p>

<p><br/></p>

<p>我们要先找到类似的工具，</p>

<p><strong>看它是如何解决问题的，用了什么办法，它的作者是怎么想的。</strong></p>

<p><br/></p>

<p>学会了这些，抓住思考问题的方式，</p>

<p>我们就能<strong>随机应变，灵活处理</strong>，做出趁手适用的工具来。</p>

<p><br/></p>

<p>其他工具中任何有用的部分，都可以借来，只要能达到目的。</p>

<p>即，目的明确后，方法可以灵活多变。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>过分的依赖工具和过度的排斥工具，都是盲目的。</p>

<p><strong>做到正视一个事物，是非常困难的。</strong></p>

<p><br/></p>

<p>jQuery的作者在《Secrets of the JavaScript Ninja》中所言，</p>

<p>很多人都被教导说，不要使用eval，这是不对的，</p>

<p>相反，<strong>我们应该学会它，从而才有能力善用它。</strong></p>

<p><br/></p>

<p>对于其他事物也是如此啊，</p>

<p>全盘接受和全盘否定，都会丢掉半壁江山，</p>

<p>我们要深入理解，目的是把它用到可以用的地方，发挥它的作用。</p>

<p><br/></p>

<p>不理解它，怎么做到在需要的时候使用呢？</p>

<p><br/></p>

<p>君子生非异也，善假于物也。</p>

<p>——荀子《劝学》</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件工程师的前瞻性]]></title>
    <link href="https://thzt.github.io/blog/2016/03/08/forward-looking-engineer/"/>
    <updated>2016-03-08T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/03/08/forward-looking-engineer</id>
    <content type="html"><![CDATA[<p>受过多年学校教育的我们，容易产生一个误区。</p>

<p>我们学会了很多知识，学会了怎样解决问题，</p>

<p>但是却不知道这些问题是怎么来的，</p>

<p>以后将要如何发展。</p>

<p><br/></p>

<p>我们要解决的问题都是静态的，</p>

<p>只要我们给出方案，</p>

<p>那它就永远是这个问题的解。</p>

<p><br/></p>

<p>然而，现实生活中的问题，却复杂得多。</p>

<p><br/></p>

<p>我们不仅需要考虑问题的解法，</p>

<p>而且更重要的还要考虑问题本身。</p>

<p>我们当前是否在把精力用于解决一个正确的问题，还说不定，</p>

<p>我们的方案是否在一段时间内仍然有效，也未可知。</p>

<p><br/></p>

<p>这也是软件行业的主要特点。</p>

<p><br/></p>

<h2><strong>困难的软件工程</strong></h2>

<p>人们常把软件工程比作建筑，我认为这极不合理。</p>

<p>完全忽视了软件的本质特点。</p>

<p><br/></p>

<p>与建筑行业不同的是，软件所解决的问题都是动态的，</p>

<p>楼还没有盖完，我们的图纸就变了，</p>

<p>怎样在这种情况下把楼盖起来，才是软件工程所面临的问题。</p>

<p><br/></p>

<p>诚然，用户的需求是不稳定的，今天说这个，明天说那个，</p>

<p>但这并不是一个主要方面。</p>

<p>短期内，需求的稳定性取决于我们的挖掘和控制。</p>

<p><br/></p>

<p>然而，从长远来看，市场在变，业务在变，</p>

<p>用户使用软件的目的就会改变，</p>

<p>软件岂能不变？</p>

<p><br/></p>

<p>采取什么样的方案，应对这些发展中的业务需要，</p>

<p>才是软件要解决的本质问题。</p>

<p><br/></p>

<p>这是困难的。</p>

<p><br/></p>

<p>且不谈增加新功能了，</p>

<p>甚至对于有缺陷的地方进行修改，也得慎重考虑。</p>

<p>所有依赖这个错误的特性而表现良好的程序，都是有问题的。</p>

<p><br/></p>

<p>每改一处都可能意味着全盘重写。</p>

<p><br/></p>

<h2><strong>编程层面的技术修炼</strong></h2>

<p>好的软件工程师，可以隔离变化，简化依赖关系。</p>

<p>他们通过抽象搭建框架，通过组装分离影响，</p>

<p>让每一个功能点都是可拆卸的。</p>

<p><br/></p>

<p>为了抽象，就得理解问题背后的数学结构，</p>

<p>为了封装，就得理解子问题之间的逻辑关联。</p>

<p><br/></p>

<p>好的代码，行云流水，层次分明，逻辑清晰，赏心悦目，</p>

<p>更重要的是，解决了当前问题，并留有余地。</p>

<p><br/></p>

<p>到了这一步，才可以谈论软件是如何进行设计的了，</p>

<p>的确，编程是一门设计手法，</p>

<p>更多的是考虑如何描述，如何组织，如何扩展等等问题。</p>

<p><br/></p>

<p>不但如此，一个架构师，还要考虑如何量产，</p>

<p>如何并行开发，如何降低抽象层次，</p>

<p>如何交流，如何推广。</p>

<p><br/></p>

<p>这绝对是一门手艺。</p>

<p><br/></p>

<h2><strong>工程师需要前瞻性</strong></h2>

<p>要想给出一个灵活可扩展的方案，</p>

<p>只是知道用动态的观点看待问题，作用是微小的。</p>

<p>我们还需要明白业务场景，分析它的趋势，看到它的未来。</p>

<p><br/></p>

<p>随着业务规模扩大，软件越来越复杂，</p>

<p>前瞻性将是衡量一个软件工程师的首要标准了，</p>

<p>这也是工程与编程的重要区别。</p>

<p><br/></p>

<p>可是，要想获得前瞻性是很难的，</p>

<p>我们必须先认识当前，明白现状，</p>

<p>必须跳出当前的生活，从更高的角度俯视它。</p>

<p><br/></p>

<p>我们得看到，现行方案已经帮助问题解决到了什么程度，</p>

<p>当前的痛点在哪，客观约束条件有哪些，</p>

<p>只有看清这些，才能确定目的地和实现路线。</p>

<p><br/></p>

<p>没有前瞻性的工程师是可怕的，</p>

<p>因为他自己都不知道要去哪，以及正在做什么，</p>

<p>那么他当前选择的路线就可能是盲目的，有风险的。</p>

<p><br/></p>

<p>只有确定目标，并逐步实现，</p>

<p>才有达到目标的可能。</p>

<p><br/></p>

<p>世界上，可没有那么多的巧合出现。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>知道自己在哪里，有计划要去哪里，</p>

<p>并努力付诸实践，才能达成目标。</p>

<p><br/></p>

<p>人们在计划出行时，总是这么考虑，</p>

<p>然而在其他问题上却容易迷茫</p>

<p><br/></p>

<p>其实，当不知道自己要去哪里的时候，</p>

<p>往往是对现在做的事情，不求甚解。</p>

<p><br/></p>

<p>还是从认识自己开始吧，</p>

<p>锻炼有前瞻性的思维习惯，</p>

<p>才能越走越稳，看尽沿途的风光美景。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[团队建设中的博弈论]]></title>
    <link href="https://thzt.github.io/blog/2016/03/06/game-theory-in-team-building/"/>
    <updated>2016-03-06T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/03/06/game-theory-in-team-building</id>
    <content type="html"><![CDATA[<p>博弈论又称为对策论（Game Theory），</p>

<p>既是现代数学的一个分支，也是运筹学的一个重要学科。</p>

<p><br/></p>

<p>博弈论思想古已有之，</p>

<p>中国古代的《孙子兵法》等著作就不仅是一部军事著作，</p>

<p>而且算是最早的一部博弈论著作。</p>

<p><br/></p>

<p><strong>故我欲战，敌虽高垒深沟，不得不与我战者，攻其所必救也；</strong></p>

<p><strong>我不欲战，画地而守之，敌不得与我战者，乖其所之也。</strong></p>

<p>我想与敌交战，虽然敌人高筑防御工事也不得不出来与我交战，</p>

<p>是因为我攻击它必然要救援的地方；</p>

<p>我不想同敌交战，只要在地上画个界线便可守住，敌人无法与我交锋，</p>

<p>是因为我设法调动它，使它背离所要进攻的方向。</p>

<p><br/></p>

<p>敌军怎么肯听从调遣呢？</p>

<p>原因就在于，敌军可进行的所有选择中，</p>

<p>我们安排了一条<strong>利益最大</strong>的选择使之中招。</p>

<p><br/></p>

<p>这就是《孙子兵法》讲究的<strong>『势』</strong>了。</p>

<p><br/></p>

<p><strong>故善战者，求之于势，不责于人。</strong></p>

<p>高明的指挥员，总是从自己造『势』中去追求胜利，而不苛求部下以苦战取胜。</p>

<p><br/></p>

<p>可是，这是战争，和团队建设有什么关系呢？</p>

<p>和博弈论又有什么关系呢？</p>

<p><br/></p>

<p>这还要从一个例子说起。</p>

<p><br/></p>

<h2><strong>势：囚徒困境与纳什均衡</strong></h2>

<p>两个共谋犯罪的人被关入监狱，不能互相沟通。</p>

<p>如果两个人都不揭发对方，则由于证据不确定，每个人都坐牢一年；</p>

<p>若一人揭发，而另一人沉默，则揭发者因为立功而立即获释，沉默者因不合作而入狱五年；</p>

<p>若互相揭发，则因证据确实，二者都判刑两年。</p>

<p><br/></p>

<p>在这种情况下，每个囚徒，都是这样考虑的。</p>

<p>如果对方不揭发，自己不揭发，判刑两年，自己揭发，免刑。</p>

<p>如果对方揭发，自己不揭发，判刑五年，自己揭发，判刑两年。</p>

<p><br/></p>

<p><strong>可见，无论对方怎样选择，自己选择揭发总是最优的。</strong></p>

<p>最终两个人由于互相揭发，各判两年。</p>

<p><br/></p>

<p>从博弈论来看，</p>

<p>囚徒们所采取的这种策略，是囚徒困境中的一个<strong>纳什均衡</strong>。</p>

<p><br/></p>

<p>所谓纳什均衡，指的是参与人的这样一种策略组合，</p>

<p>在该策略组合上，任何参与人单独改变策略，都不会得到好处。</p>

<p><br/></p>

<p>可惜的是，纳什均衡并不一定是整体最优的。</p>

<p>但是局中人所受的影响却是巨大的。</p>

<p><br/></p>

<h2><strong>险：团队凝聚之道</strong></h2>

<p>团队合作是一个老生常谈的问题，</p>

<p>怎样打造有凝聚力的团队，是重中之重。</p>

<p><br/></p>

<p>《孙子兵法》有这样的一个例子。</p>

<p><br/></p>

<p><strong>夫吴人与越人相恶也，当其同舟而济，遇风，其相救也如左右手。</strong></p>

<p><strong>故善用兵者，携手若使一人，不得已也。</strong></p>

<p>吴人与越人是相互仇视的，当他们同船过渡突遇大风时，他们相互救助起来如同左右手。</p>

<p>因此，古代善于用兵的人，能使部队携手如同一个人一样服从指挥，是将部队置于不得已的情况下形成的。</p>

<p><br/></p>

<p>这样看来，与其相信团队天生默契，</p>

<p>不如把默契看做成员们不得已而为之的选择。</p>

<p><br/></p>

<p><strong>故兵之情，围则御，不得已则斗，过则从。</strong></p>

<p>士兵的心理变化规律是：</p>

<p>被包围就会合力抵御，不得已时就会殊死奋战，陷于深重危难境地就非常听从指挥。</p>

<p><br/></p>

<p>因此，要想让团队凝聚，就得营造一种危难的局势，</p>

<p>出于自救，大家才不得不团结起来。</p>

<p><br/></p>

<h2><strong>动：机会把握的三种境界</strong></h2>

<p>在其他领域，也会涉及团队和执行。</p>

<p>例如，在篮球比赛中，怎么样评价一个战术执行者的优劣呢？</p>

<p>（组织后卫是篮球比赛中的战术执行者）</p>

<p><br/></p>

<p>能力差的后卫，<strong>错过机会</strong>。</p>

<p>他的表现是，一直追赶之前错过的时间，</p>

<p>让团队处于被动局面。</p>

<p><br/></p>

<p>可以类比，表现差的团队领导者，</p>

<p>使成员们仓促救火，疲于奔命。</p>

<p><br/></p>

<p>能力合格的后卫，<strong>抓住机会</strong>。</p>

<p>他目光敏锐，不错过任何可乘之隙，</p>

<p>是一个好的观察者。</p>

<p><br/></p>

<p>正如合格的领导者一样，</p>

<p>带领团队成员在正确的时间做着正确的事情。</p>

<p><br/></p>

<p>能力超群的后卫，<strong>创造机会</strong>。</p>

<p>他擅长打开局面，化腐朽为神奇，</p>

<p>整个团队焕然一新。</p>

<p><br/></p>

<p>优秀的团队领导者，正是如此，</p>

<p>出奇制胜，力挽狂澜。</p>

<p><br/></p>

<p>这就是把握机会的三种境界了。</p>

<p>那么如何做到优秀呢？</p>

<p><br/></p>

<h2><strong>变：应对与顺势</strong></h2>

<p><strong>水因地而制流，兵因敌而制胜。</strong></p>

<p><strong>故兵无常势，水无常形，能因敌变化而取胜者，谓之神。</strong></p>

<p>水流根据地形决定流向，用兵根据敌情采取致胜方略。</p>

<p>战争无固定不变的态势，流水无固定不变的流向。</p>

<p>能随着敌情发展变化而采取灵活变化的措施取胜的人，才称得上是神秘莫测的高明者。</p>

<p><br/></p>

<p>知道了『势』决定发展方向之后，</p>

<p>就可以随机应变了。</p>

<p><strong>造势，使团队向着健康的方向发展，</strong></p>

<p><strong>设险，让团队更加团结。</strong></p>

<p><br/></p>

<p>方向健康，大家团结，</p>

<p>才是一个有战斗力的团队。</p>

<p><br/></p>

<p>影响成员做出决定的外部条件是关键，</p>

<p>我们怎样改变它，就能怎样改变团队的未来。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>对于一个企业来说，</p>

<p>不获益，等待它的就只能是破产和灭亡，</p>

<p>对于团队，甚至对于个人的成长来说，更是如此。</p>

<p><br/></p>

<p>利用好囚徒的心理，就可以顺势而为，</p>

<p>巧妙的调整得失，甚至还能做到全局最优。</p>

<p><br/></p>

<p>相反，僵硬的改变，</p>

<p>往往不尽人意，一事无成。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[形式证明与逻辑推理]]></title>
    <link href="https://thzt.github.io/blog/2016/03/01/proof-and-deduction/"/>
    <updated>2016-03-01T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/03/01/proof-and-deduction</id>
    <content type="html"><![CDATA[<script src="https://thzt.github.io/thirdpart/jQuery/jquery-1.11.1.js"></script>


<p><link href="https://thzt.github.io/thirdpart/KaTeX/katex.min.css" rel="stylesheet"/></p>

<script src="https://thzt.github.io/thirdpart/KaTeX/katex.min.js"></script>


<script src="https://thzt.github.io/javascripts/katex.js"></script>


<p>小时候，我就对侦探非常着迷，</p>

<p>买了很多介绍破案的漫画书，故事书，小说。</p>

<p><br/></p>

<p>什么《大宇神秘惊奇系列》啊，</p>

<p>《名侦探柯南》啊，</p>

<p>《福尔摩斯探案全集》啊，等等。</p>

<p><br/></p>

<p>可是，对于<strong>什么是推理</strong>，</p>

<p>以及怎样进行推理，</p>

<p>并没有清晰系统的认识。</p>

<p><br/></p>

<p>学生时代，从平面几何开始，</p>

<p>我们就知道了证明题。</p>

<p>经过一步一步的推导，</p>

<p>最后证明结论成立。</p>

<p><br/></p>

<p>可是，对于<strong>什么是证明</strong>，</p>

<p>并没有人能说出精确的定义。</p>

<p><br/></p>

<p>这一切，难道真是只是个谜吗？</p>

<p>是人类的未知领域吗？</p>

<p><br/></p>

<p>其实不然。</p>

<p><strong>逻辑学</strong>就是研究推理和证明的学科，</p>

<p>研究思维的形式，规律和方法。</p>

<p><br/></p>

<p>其中，数理逻辑是逻辑学与数学的交叉学科，</p>

<p>用数学的方法研究逻辑，</p>

<p>我想，答案应该在这里吧。</p>

<p><br/></p>

<h2><strong>大局观</strong></h2>

<p>数理逻辑虽然博大精深，</p>

<p>但是研究方法却非常简洁优美。</p>

<p><br/></p>

<p>给定一套逻辑系统，</p>

<p>分别从两个侧面来描述这个系统的性质。</p>

<p>语法层面，语义层面。</p>

<p><br/></p>

<p><strong>语法</strong>，指的是构成这个逻辑系统的符号规则，</p>

<p>由公理和定理的推导规则组成，</p>

<p>让我们可以从一串合法的符号得到另一串合法符号，</p>

<p>称之为<strong>形式证明</strong>。</p>

<p><br/></p>

<p><strong>语义</strong>，指的是用什么样的数学对象可以解释这些符号，</p>

<p>由论域和解释函数组成，我们得到的是一些代数结构，</p>

<p>而且，从已知符号串的语义性质得到了其他符号串的性质，</p>

<p>称之为<strong>逻辑推理</strong>。</p>

<p><br/></p>

<p>学校中的数理逻辑教科书，介绍了<strong>命题演算</strong>和<strong>一阶谓词演算</strong>这两个典型的逻辑系统。</p>

<p>它们各自的语义解释，恰好描述了日常生活中推理问题。</p>

<p><br/></p>

<p>总之，数理逻辑，用一套符号，对生活中常见的逻辑问题，进行了数学建模，</p>

<p>研究它，希望得到与证明和推理相关的更多性质和结论。</p>

<p><br/></p>

<h2><strong>形式证明</strong></h2>

<p>为了说明问题，而又不引入过多的逻辑学概念，</p>

<p>我们从命题逻辑开始。</p>

<p><br/></p>

<p>命题逻辑的形式化演算系统大体上可分为两种类型，</p>

<p>一是<strong>希尔伯特式</strong>的公理化演算系统，</p>

<p>二是<strong>甘岑(Gentzen)式</strong>的自然推理系统。</p>

<p><br/></p>

<p>这两个系统各有所长，</p>

<p>前者更能体现公理化的思想，但其推理过程比较繁琐，</p>

<p>后者形式推理比较自然，但是规则较多。</p>

<p><br/></p>

<p>下面只说<strong>命题演算的自然推理系统</strong>。</p>

<p><br/></p>

<p><strong>语法：</strong></p>

<p>（1）可数个命题符号：<span data-katex="p_1,p_2,\cdots"></span></p>

<p>（2）5个联接词符号：<span data-katex="\neg,\lor,\land,\to,\leftrightarrow"></span></p>

<p>（3）2个辅助符号：<span data-katex="),("></span></p>

<p><br/></p>

<p><strong>公式：（BNF）</strong></p>

<p><span data-katex="\alpha::=p|(\neg\alpha)|(\alpha_1\lor\alpha_2)|(\alpha_1\land\alpha_2)|(\alpha_1\to\alpha_2)|(\alpha_1\leftrightarrow\alpha_2)"></span></p>

<p><br/></p>

<p><strong>推导规则：</strong></p>

<p>（1）<span data-katex=""></span>包含律：<span data-katex="\frac{\alpha\in\Gamma}{\Gamma\vdash\alpha}"></span></p>

<p>（2）<span data-katex="\neg"></span>消去律：<span data-katex="\frac{\Gamma,\neg\alpha\vdash\beta;\Gamma,\neg\alpha\vdash\neg\beta}{\Gamma\vdash\alpha}"></span></p>

<p>（3）<span data-katex="\to"></span>消去律：<span data-katex="\frac{\Gamma\vdash(\alpha\to\beta);\Gamma\to\alpha}{\Gamma\vdash\beta}"></span></p>

<p>（4）<span data-katex="\to"></span>引入律：<span data-katex="\frac{\Gamma,\alpha\vdash\beta}{\Gamma\vdash\alpha\to\beta}"></span></p>

<p>（5）<span data-katex="\lor"></span>消去律：<span data-katex="\frac{\Gamma,\alpha\vdash\gamma;\Gamma,\beta\vdash\gamma}{\Gamma,\alpha\lor\beta\vdash\gamma}"></span></p>

<p>（6）<span data-katex="\lor"></span>引入律：<span data-katex="\frac{\Gamma\vdash\alpha}{\Gamma\vdash\alpha\lor\beta;\Gamma\vdash\beta\lor\alpha}"></span></p>

<p>（7）<span data-katex="\land"></span>消去律：<span data-katex="\frac{\Gamma\vdash\alpha\land\beta}{\Gamma\vdash\alpha;\Gamma\vdash\beta}"></span></p>

<p>（8）<span data-katex="\land"></span>引入律：<span data-katex="\frac{\Gamma\vdash\alpha;\Gamma\vdash\beta}{\Gamma\vdash\alpha\land\beta}"></span></p>

<p>（9）<span data-katex="\leftrightarrow"></span>消去律：<span data-katex="\frac{\Gamma\vdash\alpha\leftrightarrow\beta;\Gamma\vdash\alpha}{\Gamma\vdash\beta}"></span>，<span data-katex="\frac{\Gamma\vdash\alpha\leftrightarrow\beta;\Gamma\vdash\beta}{\Gamma\vdash\alpha}"></span></p>

<p>（10）<span data-katex="\leftrightarrow"></span>引入律：<span data-katex="\frac{\Gamma,\alpha\vdash\beta;\Gamma,\beta\vdash\alpha}{\Gamma\vdash\alpha\leftrightarrow\beta}"></span></p>

<p><br/></p>

<p><strong>例子：</strong></p>

<p>使用这些推理规则，我们就可以从一些合法的符号串，</p>

<p>推导出另一些合法的符号串了。</p>

<p><br/></p>

<p>（1）<span data-katex="\alpha\to\beta,\beta\to\gamma,\alpha\vdash\alpha\to\beta"></span>：<span data-katex=""></span>包含律</p>

<p>（2）<span data-katex="\alpha\to\beta,\beta\to\gamma,\alpha\vdash\alpha"></span>：<span data-katex=""></span>包含律</p>

<p>（3）<span data-katex="\alpha\to\beta,\beta\to\gamma,\alpha\vdash\beta"></span>：<span data-katex="\to"></span>消去律，式（1），式（2）</p>

<p>（4）<span data-katex="\alpha\to\beta,\beta\to\gamma,\alpha\vdash\beta\to\alpha"></span>：<span data-katex=""></span>包含律</p>

<p>（5）<span data-katex="\alpha\to\beta,\beta\to\gamma,\alpha\vdash\gamma"></span>：<span data-katex="\to"></span>消去律，式（3），式（4）</p>

<p>（6）<span data-katex="\alpha\to\beta,\beta\to\gamma,\alpha\vdash\alpha\to\gamma"></span>：<span data-katex="\to"></span>引入律，式（5）</p>

<p><br/></p>

<p>有了这些以后，我们就可以定义什么是一个<strong>证明</strong>了。</p>

<p><strong>证明序列：</strong></p>

<p>若有限序列，<span data-katex="\Gamma_1\vdash\alpha_1,\Gamma_2\vdash\alpha_2,\cdots ,\Gamma_n\vdash\alpha_n"></span>满足，</p>

<p>（1）<span data-katex="\Gamma_1,\Gamma_2,\cdots ,\Gamma_n"></span>为有限公式集</p>

<p>（2）<span data-katex="\alpha_1,\alpha_2,\cdots ,\alpha_n"></span>为公式</p>

<p>（3）每个<span data-katex="\Gamma_i\vdash\alpha_i(1\leq i\leq n)"></span>都是它之前若干个<span data-katex="\Gamma_j\vdash\alpha_j(1\leq j<i\leq n)"></span>应用某条推导规则得到的</p>

<p><br/></p>

<p>则称这个有限序列为<span data-katex="\Gamma_n\vdash\alpha_n"></span>的一个<strong>（形式）证明序列</strong>。</p>

<p>此时，也称<span data-katex="\alpha_n"></span>可由<span data-katex="\Gamma_n"></span><strong>（形式）证明</strong>，</p>

<p>记为<span data-katex="\Gamma_n\vdash_N\alpha_n"></span>，其中<span data-katex="N"></span>表示自然推理系统。</p>

<p><br/></p>

<h2><strong>逻辑推理</strong></h2>

<p>上文提到的是命题演算的自然推理系统，</p>

<p>这是一个形式系统，我们介绍了它的语法和推导规则，</p>

<p>根据这些推导规则，可以从一些合法的符号串推导出另一些，</p>

<p>在这个基础上，我们定义了什么叫做（形式）证明。</p>

<p><br/></p>

<p>如何<strong>解释</strong>这些符号呢？</p>

<p>它们有什么含义呢？</p>

<p><br/></p>

<p>我们给每一个合法的<strong>公式</strong>指定一个<strong>逻辑命题</strong>，作为这个公式的解释。</p>

<p>为每一个<strong>联接词符号</strong>指定一个<strong>真值函数</strong>，作为这个联接词符号的解释。</p>

<p><br/></p>

<p><strong>命题：</strong></p>

<p>命题是可以判断真假值的句子。</p>

<p><br/></p>

<p><strong>真值函数：</strong></p>

<p><span data-katex="\{0,1\}"></span>上的<span data-katex="n"></span>元函数，<span data-katex="f:\{0,1\}^n\to\{0,1\}"></span></p>

<p>称为一个<span data-katex="n"></span>元真值函数。</p>

<p><br/></p>

<p>我们将每个联接词与一个真值函数一一对应起来，</p>

<p>那么，复合命题的真假值就可以通过子命题的真假值计算出来了。</p>

<p><br/></p>

<p><strong>指派：</strong></p>

<p>设<span data-katex="\alpha"></span>为一个命题，<span data-katex="\alpha"></span>中出现的所有命题变元构成了一个序列<span data-katex="p_1,p_2,\cdots ,p_n"></span>，</p>

<p>对该序列指定的任一真假值序列<span data-katex="t_1,t_2,\cdots ,t_n"></span>称为<span data-katex="\alpha"></span>关于<span data-katex="p_1,p_2,\cdots ,p_n"></span>的一个<strong>指派</strong>，</p>

<p>其中<span data-katex="t_i=0,1"></span>。</p>

<p><br/></p>

<p><strong>真值表：</strong></p>

<p>命题在所有可能的指派下，所取值列成的表，称为真值表。</p>

<p><br/></p>

<p><strong>永真式：</strong></p>

<p>如果命题关于其中出现命题变元的所有指派均为真，则称该命题是一个永真式。</p>

<p><br/></p>

<p>有了这些以后，我们就可以定义<strong>推理</strong>了。</p>

<p>设<span data-katex="\alpha_1,\alpha_2,\cdots ,\alpha_n,\beta"></span>都是命题，</p>

<p>称<strong>推理『<span data-katex="\alpha_1,\alpha_2,\cdots ,\alpha_n"></span>推出<span data-katex="\beta"></span>』是有效的</strong>，</p>

<p>如果对<span data-katex="\alpha_1,\alpha_2,\cdots ,\alpha_n,\beta"></span>中出现的命题变元的任一指派，</p>

<p>若<span data-katex="\alpha_1,\alpha_2,\cdots ,\alpha_n"></span>都为真，则<span data-katex="\beta"></span>也为真，</p>

<p>记为<span data-katex="\alpha_1,\alpha_2,\cdots ,\alpha_n\models\beta"></span></p>

<p>否则，称推理『<span data-katex="\alpha_1,\alpha_2,\cdots ,\alpha_n"></span>推出<span data-katex="\beta"></span>』是无效的。</p>

<p><br/></p>

<p><strong>例子：</strong></p>

<p><span data-katex="\alpha\to\beta,\alpha\models\beta"></span></p>

<p><span data-katex="\alpha\lor\beta,\neg\alpha\models\beta"></span></p>

<p><br/></p>

<h2><strong>证明与推理之间的关系</strong></h2>

<p>命题演算的自然推理系统，有很多性质，其中，</p>

<p><br/></p>

<p><strong>可靠性</strong></p>

<p><span data-katex="\Gamma\vdash\alpha\Rightarrow\Gamma\models\alpha"></span></p>

<p><br/></p>

<p><strong>完备性</strong></p>

<p><span data-katex="\Gamma\models\alpha\Rightarrow\Gamma\vdash\alpha"></span></p>

<p><br/></p>

<p>它们表明，如果一个公式可以被证明，那么它所对应命题的推理就是有效的，</p>

<p>如果某些命题的推理是有效的，那么它就可以被证明。</p>

<p><br/></p>

<p>然而，形式化系统这种研究方法，并不是完美无缺的。</p>

<p><strong>哥德尔不完全性定理</strong></p>

<p>如果<span data-katex="\Gamma"></span>是一个有穷并包含初等算术<span data-katex="\Pi"></span>的形式理论，那么<span data-katex="\Gamma"></span>是一个不完全的形式理论。</p>

<p><br/></p>

<p><strong>哥德尔协调性定理</strong></p>

<p>如果形式理论<span data-katex="\Gamma"></span>包含初等算术<span data-katex="\Pi"></span>，那么<span data-katex="\Pi"></span>的协调性不能在<span data-katex="\Gamma"></span>中被证明。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>证明和推理也是可以研究的，</p>

<p>并且，一直以来都是人们的感兴趣的研究对象。</p>

<p><br/></p>

<p>逻辑学对自动定理证明，程序设计语言中的类型系统，</p>

<p>协议验证，软硬件的安全等领域，</p>

<p>有很重要的理论价值。</p>

<p><br/></p>

<p>以命题逻辑和一阶谓词逻辑为基础，</p>

<p>人们构造出了各式各样种类繁多的逻辑系统，</p>

<p>包括模态逻辑，直觉主义逻辑，时序逻辑，动态逻辑，</p>

<p>多值逻辑，模糊逻辑，非单调逻辑，λ演算，组合逻辑等等。</p>

<p><br/></p>

<p>现代逻辑学已经应用到了越来越多的学科之中。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[真实在哪里]]></title>
    <link href="https://thzt.github.io/blog/2016/01/29/computer-science/"/>
    <updated>2016-01-29T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/01/29/computer-science</id>
    <content type="html"><![CDATA[<h2><strong>引子</strong></h2>

<p>以下，我总结了这些年对理想的追求，以及看的一些书，还有走的一些弯路，目的是为了把回忆保存起来，过几年再仔细品味。</p>

<p><br/></p>

<h2><strong>导火线</strong></h2>

<p>游客问毕加索：为什么你的画不像照片上的那么真实呢？毕加索说：你觉得照片上的，就是真实的你吗？</p>

<p>是啊，到底什么是真实的，什么是虚幻的？这句话是我初中时看到的，影响了我十几年，一直为我指引方向。</p>

<p><br/></p>

<h2><strong>学生时代</strong></h2>

<p>我找到了当时在国内很火的『第一推动系列』，《时间简史》《皇帝新脑》《黑洞与时间弯曲》。</p>

<p>当我认识到物理学是一门研究大自然的学科时，不顾父母发对，选择了冷门的大学专业。</p>

<p>与很多调剂过来的同学不同的是，我的收获简直是太大了，每一门课都认真的学着，并努力向这个『真实』的方向靠拢。</p>

<p>除了把基础物理学好之外，我又对编程产生了浓厚的兴趣，我依稀记得当时，通宵的编写VB，彻夜的学习汇编，仔细的理解C与C++。</p>

<p>终于到了毕业季，本来已经找到工作的我，由于社会的压力，父亲良言相劝，让我读研，至今我觉得这件事情非常正确。</p>

<p>当时有两个选择，跨专业考计算机或者继续学习物理，对物理学我还是比较执着，于是就选择了理论物理。并且，至今我也没有后悔这个决定。</p>

<p>研究生阶段，学的最多的其实是数学，数学基本功渐渐体现出来了。然而，当我了解到国内的科研现状后，我决定还是不要读博了。</p>

<p><br/></p>

<h2><strong>厚积而薄发</strong></h2>

<p>毕业后，我找了一个程序员的工作，不为什么，因为社会需要。能力再大也没用，社会稀缺才是重要的，这能保证我的生活一直很轻松。</p>

<p>既然选择了程序员的道路，我就决定好好研究一下编程，把基础打牢，同时不忘自己对『真实性』的追求。编程不就是写写代码吗？有什么基础可言？我不这么认为。</p>

<p>因为已经有了很多年的编程经验，一万小时定律已经不算什么了，这才让我能更清醒的做出选择。把基础再打牢一些，基础决定了最后的高度，欲速则不达。</p>

<p>我先是重新研读了《计算机程序的构造与解释》，这本圣经早有耳闻，但只是翻着看了看，我后悔一开始没有认真的阅读，否则可能就改写我当时的学习路线了。</p>

<p>这本书让我对Lisp语言产生了好感，于是，开始疯狂学习大法，『把市面上所有能找到的书都看一遍』。当然，这是不可能的，这不过是一种决心罢了。</p>

<p>不过在这之前，我面临了一个选择，Lisp两大方言中，到底是学Common Lisp还是Scheme？不错，当时Racket还没有这么火。</p>

<p>我做出了艰难的决定，选择大而全的Common Lisp，不为别的，就是因为他可能『更不必需』。</p>

<p>这一向是我的决策准则，在大方向上，总是选择『更不必需』的方案，广度优先。否则，如果不这么做，就可能一辈子都不会再接触它了，总是有更重要的事情等着我。</p>

<p>《ANSI Common Lisp》《Land of Lisp》《Pratical Common Lisp》《On Lisp》《Let Over Lambda》《Lisp语言（马希文）》《Lisp in small pieces》</p>

<p>好了，这些看完后，对Common Lisp有了一个基本的认识了，于是该学Scheme了吧，这个『更必需』一点，看吧，必需的东西早晚会去学的。</p>

<p>《R5RS》《The Litter Schemer》《The Scheme Promgramming Language》《Essentials of Programming Languages》《An Introduction to Scheme and its Implementation》</p>

<p>可以看到Scheme的书更学术一些，如果没有Common Lisp的基础，这里就比较费力了。</p>

<p>在读Scheme的过程中，发现了自己编译原理很弱，于是恶补了一下，不懂形式语言和编译原理，都不敢说自己学计算机的。</p>

<p>《编程语言实现模式》《程序设计语言·实践之路》《形式语言与自动机》《自动机理论，语言和计算导论》《编译原理》《编译器设计》</p>

<p>然后，又发现自己算法很弱，恶补了几本算法。不懂算法，都不敢做工程啊。《算法导论》《算法》《具体数学》</p>

<p>这些刷完之后，我马上发现了更基础的薄弱环节，那就是Lambda演算。Lisp是函数式语言的一种，一门很像Lambda演算的语言，究竟有什么渊源呢，还得看书，同时各种语言的实现原理也吸引了我。</p>

<p>《Lambda-Calculus and Combinators, an Introduction》《Concept in Programming Languages》《Compiling Continuations》《Lecture notes on the Lambda Calculus》《数学·计算·逻辑（陆汝钤）》《哥德尔·爱舍尔·巴赫 集异璧之大成》</p>

<p>刷怪的途中，是不可能绕过Haskell的，身为函数式家族的一朵奇葩，必须得学，是该死磕一下的时候了。</p>

<p>《Learn you a Haskell for Great good》《Real world Haskell》《A History of Haskell》《Beginning Haskell》《Programming in Haskell》《Haskell函数式编程入门》《Parallel and Concurrent Programming in Haskell》《Haskell: The Craft of Functional Programming》</p>

<p>好吧，我承认，Lisp中遇到Continuation，Haskell中遇到Monad的时候，我真的跪了，只能硬着头皮看，谁叫我不知道别人也跪了呢。这其实也表明学习时最好不要看别人，自己学才能走的更远。</p>

<p><br/></p>

<h2><strong>放松一下</strong></h2>

<p>把这些放一放，容我先把其他主流语言刷一遍，压压惊。</p>

<p>《C与指针》《C专家编程》《程序员的自我修养》《Rust Essentials》《Realm of Racket》《Seven Concurrency Models in Seven Weeks》《Programming in Standard ML》《Learn you some Erlang for Great Good》《Scala编程》《C++模板元编程》</p>

<p>各种工业级的语言就不说了，语法过一下就行了，反正以后有的是机会学的，这些不是『更不必需』的。</p>

<p>Go，Java，C#，PHP，Python，Ruby，JavaScript，Clojure，Swift，C++。</p>

<p><br/></p>

<h2><strong>数学与逻辑学交相呼应</strong></h2>

<p>好了，有了这些『基本功』之后，让我们再来一战吧。那我必须先把类型理论搞一搞，这个始终是个没有填的坑。</p>

<p>《类型和程序设计语言》《Type Systems》《The Litter Prover》</p>

<p>然后，发现类型其实和逻辑学有一腿，难道我不得不跨界了吗，这可是一个大的方向，琢磨了好几天，我决定还是先尝试一下吧。</p>

<p>《Teach yourself Logic 2015》《Logic and Structure》《数理逻辑》</p>

<p>其实，决定后发现并不是那么难，难的是决定不是决定后的行动。让我感到惊讶的是，逻辑学的很多结论都暗示着人们对『真实性』问题的探索，我非常幸运走到了这里。</p>

<p>以集合论，证明论，递归论，模型论为基础的逻辑学，完美的诠释了『真实性』问题的最新进展。</p>

<p>感叹之余，可以绕回来了，读读范畴论，然而还要从抽象代数开始。</p>

<p>《近世代数基础》《Categories for the Working Mathematician》</p>

<p>幸亏研究生阶段数学基础打的较为牢固，群论，集合论，拓扑学，微分流形，都已经学过，这里就容易了些。</p>

<p><br/></p>

<h2><strong>其他的</strong></h2>

<p>其实以上过程中，我故意的隐藏了作为一个软件工程师应该读的那部分书。</p>

<p>让我们来看看吧，软件工程是一个不小的领域，也是需要修炼的，幸亏是工作需要，让我不得不学好它。</p>

<p>从哪开始呢，当然是设计模式了，不懂设计模式，怎么进行『面向对象』的编程呢？《大话设计模式》《设计模式之禅》《软件架构模式》</p>

<p>然后是代码质量，《测试驱动开发》《代码大全》《程序员修炼之道》《重构》《重构与模式》</p>

<p>软件开发方法论，《快速软件开发》《软件需求模式》《人月神话》《大教堂与市集》《没有银弹》《敏捷软件开发: 原则，模式与实践》</p>

<p>编程思想，《UNIX编程艺术》《代码之殇》《高效程序员的奥秘》《理解专业程序员》《软件随想录》《程序员的呐喊》《黑客与画家》《代码的未来》《图灵的秘密》《你的灯亮着吗》</p>

<p>新潮的东西也该玩玩，《大数据时代》《集体智慧编程》《统计学习方法》</p>

<p>有过Lisp的基础，Emacs应该是正常的选择了吧，《GNU Emacs Lisp Reference Manual》</p>

<p>还有很多没有看完的书，太难的太无聊的，或者印象不够深刻的书，没有提到，希望以后能够再有机会拿起来读一下。不过，也可能根本就没有这个机会了。</p>

<p>总结一下，Scheme和Haskell绝对是两个正确的切入点，越早接触越好。同时也会更早接触到领域内的大神，粉碎自尊与自傲，含着泪跪着走完剩下的路。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>那么，言归正传，到底什么是真实呢？我的理解是，科学方法就是目前最有效的对真实性的保障。</p>

<p>科学方法讲究从假设出发，约定一套推理规则，那么就可以推导出很多结论来了。然而这些结论并不是现实世界本身，这些结论与现实世界之间的解释关系构成了一个数学模型。</p>

<p>我们看到，不同的假设和推理规则构成了不同的公理系统，连同对它们的解释又构成了不同的模型，所解释的现实世界是公理系统的语义。</p>

<p>怎样证明某个公理系统是『对』的呢？不幸的是，无法证明，只能证伪。而且，只需要找出一个反例即可。</p>

<p>这就是科学方法。以上是数学（集合论），逻辑学（一阶逻辑），哲学（科学哲学），自然科学（物理学），计算机科学（可计算性理论）的交汇点。</p>

<p>我庆幸之前的所有选择，给了我这样的认识，我还会一直坚持下去，直到有更深入的理解。</p>

<p>我觉得一个人终究会走到自己想要去的地方，不管经过何种途径，沿途中任何我们所做的积累都是有用的，未来的某一天真的就能用上。</p>

<p>人们也不可能在一个阶段同时抓住两件东西，只能舍弃一个，没关系，舍弃说明你得到了更重要的那个，过后你完全可以再有机会得到失去的那个，只要你坚持自己的梦想。</p>

<p>相反，如果当时你拥有了失去的那个，应得的就会被错过，人生本来就是不完美的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[多做不如少做，不做不如去做]]></title>
    <link href="https://thzt.github.io/blog/2016/01/26/less-is-more/"/>
    <updated>2016-01-26T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/01/26/less-is-more</id>
    <content type="html"><![CDATA[<p>喜欢忙碌并不是勤奋。——塞内加</p>

<p><br/></p>

<p>在生活节奏日益加快的今天，</p>

<p>忙碌似乎已经成了普遍现象了，</p>

<p>大家急匆匆的做这个，</p>

<p>忙着做那个，口里说着<strong>没时间</strong>。</p>

<p><br/></p>

<p>且不说对自身的影响，</p>

<p><strong>我们这么忙，真的对要做的事情有益吗</strong>？</p>

<p><br/></p>

<p>有人说，</p>

<p>初级人才，完成任务。</p>

<p>中级人才，解决问题。</p>

<p>高级人才，<strong>带来价值</strong>。</p>

<p><br/></p>

<p>我十分同意这种说法。</p>

<p><br/></p>

<p>上帝安排我们来到这个世界上，</p>

<p>是希望我们有自己的活法，</p>

<p>给世界带来不同。</p>

<p><br/></p>

<p>公司雇佣我们，</p>

<p>是因为我们数十年的人生积累，</p>

<p>可以帮助公司为客户带来价值，</p>

<p>而不是仅仅忙起来这么简单。</p>

<p><br/></p>

<p>相似的，</p>

<p>程序员应该把自己定位成解决方案的提供者，</p>

<p>而不是帮助别人实现想法的人。</p>

<p><br/></p>

<p><strong>带来更大价值的事情是思考</strong>，</p>

<p>要有成效，而不是忙碌起来。</p>

<p><br/></p>

<h2>有效的思考时间</h2>

<p>如果回顾一下的话，</p>

<p>每天中，我们的有效思考时间，</p>

<p>实际上只占很少一部分，</p>

<p><strong>可能只有短短几秒钟</strong>。</p>

<p><br/></p>

<p>那么，我们经过这么多年的，</p>

<p>科学教育，人生阅历，挑灯苦读，</p>

<p>都白白浪费了。</p>

<p><br/></p>

<p>事实上，<strong>多思考才对得起别人支付的薪水</strong>，</p>

<p>否则，为什么请我们来做这件事情呢？</p>

<p>好吧，我们其实并不是那么重要。</p>

<p>不过，要先有这个自信。</p>

<p><br/></p>

<p>如果我们做的事情，</p>

<p>当初不必努力学习，现在就可以做，</p>

<p>那对企业来说就是资源浪费，</p>

<p>也可能我们并不适合这个地方。</p>

<p><br/></p>

<p>因此，要<strong>尽可能的延长自己每天中的有效思考时间</strong>，</p>

<p>这些通过思考而得来的结论，是我们的王牌，</p>

<p>也是我们唯一的价值所在。</p>

<p><br/></p>

<p>与此同时，也不要走到另一个极端。</p>

<p><strong>空想没有任何好处</strong>，</p>

<p>还必须为自己的想法给出实现，</p>

<p>落到实处。</p>

<p><br/></p>

<p>所以，我们一定是在实现自己的想法，</p>

<p>而不是别人的想法。</p>

<p><br/></p>

<p>想法也必须由自己实现，</p>

<p>才可以得到最直接的反馈，</p>

<p>做出<strong>快速的调整</strong>。</p>

<p><br/></p>

<h2>学会拒绝</h2>

<p>一个人的底线是什么，</p>

<p>他在社会中对外界的表现就是什么。</p>

<p><br/></p>

<p>无论他能力超群，</p>

<p>还是技高一筹，</p>

<p>或者出类拔萃，</p>

<p>这些都没有用。</p>

<p><br/></p>

<p><strong>同别人合作时</strong>，</p>

<p><strong>迟早会迫使退回自己的底线</strong>，</p>

<p>无法完全施展。</p>

<p><br/></p>

<p>所以说，在现实项目中，</p>

<p>一个程序员的代码好坏，</p>

<p>不止取决于自身的编码水平，</p>

<p>还取决于他的底线。</p>

<p><br/></p>

<p>没有不紧的工期，</p>

<p>没有资源足够的工程，</p>

<p>如果一个程序员不坚守底线，哪怕水平再高，</p>

<p>也只能编写劣质的软件。</p>

<p><br/></p>

<p>因为，实际安排工作的人，</p>

<p>并不会面面俱到，亲自落实每一件事情，</p>

<p>总会有一个折衷处理。</p>

<p><br/></p>

<p>学会拒绝吧。</p>

<p><br/></p>

<p>压力是我们自己造成的，</p>

<p>除了吃饭睡觉之外，</p>

<p>再<strong>没有不得不做的事情</strong>了。</p>

<p><br/></p>

<p>拒绝，还可以让安排工作的人清晰的认识到，</p>

<p>他<strong>对资源的可控程度</strong>。</p>

<p><br/></p>

<p>很简单，<strong>要想有时间，那就少做点事情</strong>。</p>

<p>如果可以多做，</p>

<p>就不会考虑怎样在少做的情况下，</p>

<p>达到相同的效果了。</p>

<p><br/></p>

<p>人们都会多做，很忙，</p>

<p>然而对<strong>结果</strong>可能并没有什么帮助。</p>

<p><br/></p>

<h2>勇气</h2>

<p>勇者，气也。</p>

<p>气之所至，力亦至焉。</p>

<p><strong>心</strong>之所至，气乃至焉。</p>

<p><br/></p>

<p>首先要有想法去做某件事情，</p>

<p>又很想把它做好，才会有勇气。</p>

<p><br/></p>

<p>如果说从多做到少做，是第一步，</p>

<p>从少做到不做，是第二步，</p>

<p>那么从不做到<strong>去做</strong>，就是第三步了。</p>

<p><br/></p>

<p>在选择不做的前提下，</p>

<p>在仔细分析了后果的条件下，</p>

<p>我们要<strong>勇于做一些自认为正确的事情</strong>。</p>

<p><br/></p>

<p>对于所有的事情而言，</p>

<p>如果不主动说出来，就没有人会理解，</p>

<p>如果没有人开始，就不可能继续下去。</p>

<p><br/></p>

<p>没有勇气的人，</p>

<p>对社会没有价值，</p>

<p>对他人没有帮助。</p>

<p><br/></p>

<p><strong>有拈叶飞花都可以伤人的武功，却消极逃避</strong>，</p>

<p><strong>不如，一把钝剑，勇于济世</strong>。</p>

<p><br/></p>

<h2>结语</h2>

<p>如果心脏病发作了，</p>

<p>每天只能工作4个小时，</p>

<p>我们会怎样工作？</p>

<p><br/></p>

<p>怎么可能每天的工作，都恰好8个小时可以做完？</p>

<p><br/></p>

<p>人生不是通过加速就可以体味到更多。——莫罕达斯·甘地</p>

<p>忙碌的人忙于任何事情，除了生活。——塞内加</p>

<p><br/></p>

<p>参考：</p>

<p>《<a href="http://book.douban.com/subject/10786476/">每周工作4小时</a>》</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件开发的节奏]]></title>
    <link href="https://thzt.github.io/blog/2016/01/21/the-rhythm-of-the-development/"/>
    <updated>2016-01-21T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/01/21/the-rhythm-of-the-development</id>
    <content type="html"><![CDATA[<p>有时候，在软件项目的巨大压力下，</p>

<p>我们会不由自主的做出，违反<strong>自然规律</strong>的事情。</p>

<p><br/></p>

<p>短期来看，确实受益了，</p>

<p>然而，长期看来，无异于<strong>揠苗助长</strong>，</p>

<p>流毒无穷。</p>

<p><br/></p>

<p>人们以为，</p>

<p>软件行业中，<strong>加班</strong>是家常便饭，</p>

<p>但实际上，这是管理上缺陷。</p>

<p><br/></p>

<p>处于底层的程序员们，无力涉足管理，</p>

<p>但也可以认真想一想，<strong>如何高效的加班</strong>。</p>

<p><br/></p>

<p>我们先从几个角度来看看加班这件事吧。</p>

<p><br/></p>

<h2>从收支上看加班</h2>

<p>长期加班并不是一件好事，</p>

<p>因为，它增加了投入。</p>

<p><br/></p>

<p>这还不好吗？</p>

<p>其实不然。</p>

<p><br/></p>

<p>因为一件事情的<strong>代价</strong>，</p>

<p>在很大程度上，影响了我们的<strong>决策</strong>。</p>

<p><br/></p>

<p>如果在计划阶段，</p>

<p>认为不加班可以做完，</p>

<p>最后结果是加班做完的。</p>

<p><br/></p>

<p>这只能说明我们低估了成本，</p>

<p>那么做这件事情就可能不是那么值得了。</p>

<p><br/></p>

<p>因此，<strong>加班会影响我们去评判某一选择的正确性</strong>，</p>

<p><strong>还会让我们继续做出错误的决定</strong>。</p>

<p><br/></p>

<h2>从工作性质上看加班</h2>

<p>短期加班，是很有效果的，</p>

<p>但是，人不能不休息，</p>

<p>软件工程师也不能不重新思考自己的设计。</p>

<p><br/></p>

<p>加班会迫使人们把工作赶出来，</p>

<p>那么任何有创造力的事情都将被错过。</p>

<p><br/></p>

<p>而且，代码质量会变差，</p>

<p><strong>添加新功能的成本也会越来也大</strong>。</p>

<p><br/></p>

<p>经常发生的事情是，</p>

<p>本来很简单的一个功能，因为有历史原因，</p>

<p>才不得不使用复杂的实现方案。</p>

<p><br/></p>

<p>加班会让这件事更频繁的发生。</p>

<p><br/></p>

<h2>从工作总量上看加班</h2>

<p>短期内，工作总量是会增加的，</p>

<p>因为前几天人们都不累，</p>

<p>延长了工作时间，代码总量肯定是会增加的。</p>

<p><br/></p>

<p>然而，长期加班会导致人们效率下降，</p>

<p>在明知道要加班的情况下，</p>

<p>会更有意识的降低自己的工作效率，</p>

<p>反正要加班嘛。</p>

<p><br/></p>

<p>因此，工作总量不增反降。</p>

<p><br/></p>

<p>另外，人是不可能违背自然规律的，</p>

<p><strong>没有必要用第二天一整天的无精打采</strong>，</p>

<p><strong>来换取今天几个小时的加班</strong>。</p>

<p><br/></p>

<p>只是改变了生物钟，</p>

<p>没有什么意义呀。</p>

<p><br/></p>

<p>而且，代码多一定不是好事，</p>

<p><strong>错的越多，要改的就越多</strong>。</p>

<p><br/></p>

<h2>从软件工程来看加班</h2>

<p>如果去饭店吃饭，</p>

<p>厨师说做一个鱼香肉丝要10分钟，</p>

<p>我们再急，也不会要求厨师5分钟把它做出来，</p>

<p>让他加班也没用。</p>

<p><br/></p>

<p>一个女人，必须经过10月怀胎，</p>

<p>才能生下小孩，</p>

<p>肯定不会有人强迫她5个月就生下来，</p>

<p>让她加班，给她加人手也没用。</p>

<p><br/></p>

<p>经验表明，</p>

<p><strong>有些事情经历的时间是不可压缩的</strong>。</p>

<p><br/></p>

<p>因此可以说，</p>

<p>当工期足够短的情况下，</p>

<p>加再多的人也是徒劳的。</p>

<p><br/></p>

<p>这时候，我们应该努力反思了，</p>

<p><strong>为什么我们要做那么多的事</strong>，</p>

<p><strong>却还剩下了这么少的时间</strong>？</p>

<p><br/></p>

<h2>工程师的价值</h2>

<p>以上的分析不少了，</p>

<p>我相信如果有领导看到这里，</p>

<p>还是想让你加班，那就是故意的了。</p>

<p><br/></p>

<p>在不可抗拒的情况下，</p>

<p>底层程序员们，实际上应该考虑，</p>

<p><strong>高效加班的办法</strong>。</p>

<p><br/></p>

<p>因为，只有我们明白软件，</p>

<p>知道它的生命周期，</p>

<p>了解它的特性，</p>

<p>更知道怎么做好它。</p>

<p><br/></p>

<p>我们在工期紧的情况下，</p>

<p>最应该做的事情就是，</p>

<p><strong>管理好自己的时间，调节好工作状态</strong>。</p>

<p><br/></p>

<p>用正确的姿势走好每一步。</p>

<p><br/></p>

<h2>保持节奏</h2>

<p>无论外界有多么大的压力，</p>

<p>我们都要<strong>保持自己的节奏</strong>。</p>

<p><br/></p>

<p>这不但是对自己负责，</p>

<p>也是从专业的角度对项目负责。</p>

<p><br/></p>

<p><strong>我们只有保持节奏的产出</strong>，</p>

<p><strong>才能帮助项目成功</strong>。</p>

<p><br/></p>

<p>不能为了速度一味的牺牲质量，</p>

<p>也不能因为洁癖，减缓前进的步伐。</p>

<p><br/></p>

<p>其实，更多情况下，我们是自乱阵脚。</p>

<p><br/></p>

<p>别人不了解软件，让我们精疲力尽，让项目走向失败，</p>

<p>如果就听之任之的话，那就只能怪我们自己了。</p>

<p><br/></p>

<p><strong>身为一名软件工程师</strong>，</p>

<p><strong>没有努力把项目调整到正确的轨道</strong>，</p>

<p><strong>而是选择傻傻的加班</strong>。</p>

<p><br/></p>

<p><strong>我觉得，这才是团队的悲哀</strong>。</p>

<p><br/></p>

<h2>结语</h2>

<p>再多的加班，</p>

<p>也比不上想人们在主观上想把它做好。</p>

<p><br/></p>

<p>可惜，可惜。</p>

<p><br/></p>

<p>欲将心事付瑶筝，</p>

<p>知音少，弦断有谁听？</p>

<p>——《小重山》岳飞</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[第四重境界]]></title>
    <link href="https://thzt.github.io/blog/2016/01/18/the-fourth-level/"/>
    <updated>2016-01-18T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/01/18/the-fourth-level</id>
    <content type="html"><![CDATA[<p>人们对事物的认知，具有螺旋上升的特点，</p>

<p>与其说质变改变了现状，</p>

<p>倒不如说，<strong>质变让我们重新回到了历史上的今天</strong>。</p>

<p><br/></p>

<p>佛家有人生三重境界的说法：</p>

<p>看山是山，看水是水；</p>

<p>看山不是山，看水不是水；</p>

<p>看山还是山，看水还是水。</p>

<p><br/></p>

<p>一个人的外在表现，也具有这样的特点。</p>

<p><br/></p>

<p>新手，朴实无华；</p>

<p>熟手，锋芒毕露；</p>

<p>高手，含蓄内敛。</p>

<p><br/></p>

<p>新手们，天真无邪，</p>

<p>没有一点让人感到不快的地方，</p>

<p><strong>然而却不能委以重任</strong>。</p>

<p><br/></p>

<p>熟手门，展示着自己的才华，</p>

<p>哪怕你不想看，他们也在证明自己，</p>

<p><strong>让人不太放心</strong>。</p>

<p><br/></p>

<p>高手们，没办法探出真实水平，</p>

<p>他们说不会的，可能只是不想说罢了，</p>

<p><strong>指望不上</strong>。</p>

<p><br/></p>

<p>这些都不是我们所向往的。</p>

<p><br/></p>

<p>西游记中提起过，</p>

<p>小乘佛法，渡己；</p>

<p>大乘佛法，渡人。</p>

<p><br/></p>

<p><strong>自己的境界再高，也比不上对别人一点小小的帮助</strong>。</p>

<p>因此，高手的境界还远远不够，</p>

<p>还需要向第四重境界努力。</p>

<p><br/></p>

<p>我们回顾历史，</p>

<p>古今中外的那些伟人们，</p>

<p>他们的事迹为什么能够流传到今天？</p>

<p><br/></p>

<p>是因为他们做出了有巨大影响力的事情。</p>

<p>他们并没有隐瞒实力，</p>

<p>而是<strong>做出改变</strong>。</p>

<p><br/></p>

<p>看到满目苍夷的世界，</p>

<p>心中有一片美好的蓝图，</p>

<p>并逐步的实现它。</p>

<p><br/></p>

<p>只有这样，才能成为领袖，才有追随者，</p>

<p>自发的汇聚一些志同道合的人们，</p>

<p>让世界变得更好。</p>

<p><br/></p>

<p><strong>改变自己容易，改变别人太难</strong>。</p>

<p><strong>适应环境容易，改变环境太难</strong>。</p>

<p><br/></p>

<p>不但自身要有压倒性的实力优势，</p>

<p>而且还要有号召力，领导力，人格魅力。</p>

<p><br/></p>

<p>不能锋芒毕露，因为会失去朋友，</p>

<p>也不能含蓄内敛，因为被动注定失败。</p>

<p><br/></p>

<p>需要把自己的想法说出来，</p>

<p>需要沟通和演讲，需要分享和交流。</p>

<p><br/></p>

<p>既要有看山是看，看水是水的<strong>成熟心态</strong>，</p>

<p>也要有看山不是山，看水不是水的<strong>洞察力</strong>。</p>

<p><br/></p>

<p>这就是人生的第四重境界了吧。</p>

<p><br/></p>

<p>我们应该努力学习，同时戒骄戒躁，</p>

<p>不能愤世嫉俗，还不能消极避世。</p>

<p><br/></p>

<p>把大智若愚放下，把大巧若拙收起来。</p>

<p><br/></p>

<p><strong>是时候该出招了吧，勇士们</strong>。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hask范畴上的Monad]]></title>
    <link href="https://thzt.github.io/blog/2016/01/11/monad-in-hask-category/"/>
    <updated>2016-01-11T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/01/11/monad-in-hask-category</id>
    <content type="html"><![CDATA[<p>范畴论是一个迷人的领域，</p>

<p>它是一门研究<strong>数学结构</strong>以及<strong>结构之间关系</strong>的理论。</p>

<p><br/></p>

<p>不知道我们学群论时，</p>

<p>是否感觉到了群同态与集合间映射的相似性。</p>

<p>学拓扑学时，</p>

<p>是否感觉到了连续映射与微分流形间光滑映射的相似性。</p>

<p><br/></p>

<p>范畴论统一了这些相似结构。</p>

<p>然而，这还要从抽象代数说起。</p>

<p><br/></p>

<h2>幺半群（monoid）</h2>

<p>在抽象代数中，<strong>幺半群</strong>是这样定义的。</p>

<p><br/></p>

<p>集合S和S上满足结合律的封闭二元运算"•"，</p>

<p>所形成的代数结构称为<strong>半群</strong>，记为(S, •)，简记为S</p>

<p><br/></p>

<p>设S是半群，元素e∈S，称为半群S的<strong>幺元素</strong>，</p>

<p>如果对于每一个x∈S，有xe=ex=x</p>

<p><br/></p>

<p>如果半群S有幺元素e，则它是唯一的。</p>

<p>含有幺元素的半群称为<strong>幺半群</strong>。</p>

<p><br/></p>

<p>注：</p>

<p>半群G如果有幺元素，且每个元素均可逆，</p>

<p>则称G为<strong>群</strong></p>

<p><br/></p>

<h2>图示法（diagram）</h2>

<p>一个幺半群M，可以描述为一个集合M，和两个函数</p>

<p>µ : M × M -> M</p>

<p>η : 1 -> M</p>

<p><br/></p>

<p>其中，1 = {0}是只有一个元素的集合。</p>

<p><br/></p>

<pre>           1 × µ<br>M × M × M -------&gt; M × M<br>    |                |<br>    | µ × 1          | µ<br>    |                |<br>    v                v<br>  M × M   -------&gt;   M<br>             µ</pre>




<pre>        η × 1          1 × η<br>1 × M -------&gt; M × M &lt; ------- M × 1<br>  |              |               |<br>  | α            | µ             | β<br>  |              |               |<br>  v              v               v<br>  M      =       M        =      M</pre>


<p><br/></p>

<p>用元素来表示图表，可以写为，</p>

<p><br/></p>

<pre>&lt;x,y,z&gt; |-------&gt;    &lt;x,yz&gt;<br>   -                   -<br>   |                   |<br>   |                   |<br>   v                   v<br>&lt;xy,z&gt;  |-------&gt; (xy)z=x(yz)</pre>




<pre>&lt;0,x&gt; |-------&gt; &lt;e,x&gt;    &lt;x,e&gt; &lt;-------| &lt;x,0&gt;<br>  -               -        -               -<br>  |               |        |               |<br>  |               |        |               |<br>  v               v        v               v<br>  x       =      ex       xe       =       x</pre>


<p><br/></p>

<p>可以看出，(xy)z=x(yz)表示了群乘法的结合律，</p>

<p>x=ex,xe=x表示了幺元e，因此图表展示了幺半群的结构。</p>

<p><br/></p>

<h2>范畴（category）</h2>

<p>一个<strong>范畴</strong>C由一系列<strong>对象</strong>（object）和<strong>箭头</strong>（arrow）组成。</p>

<p>对于每一个箭头f，有两个对象与之关联，</p>

<p>称为箭头f的定义域（domain）和值域（codomain）。</p>

<p>并且，满足以下几条规则，</p>

<p>（1）对于每一个对象a，存在恒等箭头（identity arrow），i:a->a</p>

<p>（2）箭头满足结合律，对于任意的箭头f,g,h有(f•g)•h=f•(g•h)</p>

<p>（3）箭头的集合在箭头组合运算下是封闭的</p>

<p><br/></p>

<p>注：</p>

<p>f•g表示g和f的组合运算，它也是一个箭头，其中g的值域是f的定义域</p>

<p><br/></p>

<p>例：</p>

<p>所有的集合，以集合作为对象，集合间的映射作为箭头，构成了一个范畴，</p>

<p>所有的群，以群作为对象，群同态作为箭头，构成了一个范畴，</p>

<p>所有的拓扑空间，以拓扑空间作为对象，拓扑空间之间的连续映射为箭头，构成了一个范畴，</p>

<p>所有的微分流形，以微分流形作为对象，流形间的光滑映射为箭头，构成了一个范畴，</p>

<p>Haskell中，以类型作为对象（类型是值的集合），函数作为箭头，构成了一个范畴（<strong>Hask范畴</strong>）。</p>

<p><br/></p>

<h2>函子（functor）</h2>

<p>如果把范畴看做对象，则函子可以看做箭头。</p>

<p><br/></p>

<p>一个<strong>函子</strong>F是范畴C到范畴D的箭头，F:C -> D，</p>

<p>它满足以下条件，</p>

<p>F把C中的对象c映射为D中的对象F c，把C中的箭头f映射为D中的箭头F f。</p>

<p>且满足分配律，F (f•g)=(F f)•(F g)</p>

<p><br/></p>

<p>注：</p>

<p>等式左边的"•"表示C中的箭头组合运算，</p>

<p>等式右边的"•"表示D中的箭头组合运算。</p>

<p><br/></p>

<p>范畴C到自身的函子，称为<strong>自函子</strong>（endofunctor）。</p>

<p><br/></p>

<p>Hask范畴的自函子把Haskell中的类型a映射为另一个类型f a，</p>

<p>把类型a到类型b的函数，映射为类型f a到类型f b的函数。</p>

<p><br/></p>

<p>class Functor f where</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmap :: (a -> b) -> f a -> f b</p>

<p><br/></p>

<p>class Functor f => Applicative f where</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pure :: a -> f a</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;*>) :: f (a -> b) -> f a -> f b</p>

<p><br/></p>

<p>我们看到，pure和fmap放在一起，</p>

<p>构成了一个Hask范畴的自函子。</p>

<p><br/></p>

<h2>自然变换（natural transformation）</h2>

<p>如果把函子看做对象，则自然变换可以看做箭头。</p>

<p><br/></p>

<p>若F和G是范畴C到D的函子，则<strong>自然变换</strong>τ是一个箭头，τ: F -> G，</p>

<p>它满足以下条件，</p>

<p><br/></p>

<pre>     f<br>a -------&gt; b</pre>




<pre>      F f<br>F a -------&gt; F b<br>|            |<br>| τ a        | τ b<br>|            |<br>v            v<br>G a -------&gt; G b<br>      G f</pre>


<p><br/></p>

<p>注：</p>

<p>F a是D中与a对应的对象，F b是D中与b对应的对象，F f是D中与f对应的箭头</p>

<p><br/></p>

<h2>函子范畴（functor category）</h2>

<p>以范畴C到D的函子为对象，以函子间的自然变换为箭头，</p>

<p>构成了一个范畴，称为<strong>函子范畴</strong>。</p>

<p><br/></p>

<p>易知，自然变换可以进行组合运算，</p>

<p>设µ a : F a -> G a，η a : G a -> H a</p>

<p>则可以定义一个新的自然变换(η • µ) a = F a -> H a</p>

<p>可证自然变换的组合运算满足结合律。</p>

<p><br/></p>

<p>注：</p>

<p>函子范畴的对象，不是一个集合，</p>

<p>函子范畴的箭头，也不是映射。</p>

<p><br/></p>

<h2>Monad</h2>

<p>范畴C上的monad，是一个<strong>三元组</strong>(F,µ,η)，其中</p>

<p>F是范畴C上的自函子，</p>

<p>µ是F<sup>2</sup>到F的自然变换，µ:F<sup>2</sup>->F，</p>

<p>η是单位自函子I到F的自然变换，η:I->F</p>

<p><br/></p>

<p>且满足以下条件</p>

<p><br/></p>

<pre>           F • µ<br>F • F • F -------&gt; F • F<br>    |                |<br>    | µ • F          | µ<br>    |                |<br>    v                v<br>  F • F   -------&gt;   F<br>             µ</pre>




<pre>        η • F          F • η<br>I • F -------&gt; F • F &lt; ------- F • I<br>                 |                <br>  ||             | µ            ||<br>                 |               <br>                 v                <br>  F      =       F        =      F</pre>


<p><br/></p>

<p>在Haskell中可以这样表示：</p>

<p><br/></p>

<p>{- 自函子F，作用在对象上时 -}</p>

<p>fObj :: (Applicative f) => a -> f a</p>

<p>fObj = pure</p>

<p><br/></p>

<p>{- 自函子F，作用在箭头上时 -}</p>

<p>fArr :: (Applicative f) => (a -> b) -> (f a -> f b)</p>

<p>fArr = fmap</p>

<p><br/></p>

<p>{- 自函子F<sup>2</sup> -}</p>

<p><br/></p>

<p>f2Obj :: (Applicative f) => a -> f (f a)</p>

<p>f2Obj = fObj . fObj</p>

<p><br/></p>

<p>f2Arr :: (Applicative f) => (a -> b) -> (f (f a) -> f (f b))</p>

<p>f2Arr :: fArr . fArr</p>

<p><br/></p>

<p>{- 单位自函子，作用到对象上时 -}</p>

<p>iObj :: a -> a</p>

<p>iObj = id</p>

<p><br/></p>

<p>{- 单位自函子，作用到箭头上时 -}</p>

<p>iArr :: (a -> b) -> (a -> b)</p>

<p>iArr = id</p>

<p><br/></p>

<p>{- 自然变换µ:F<sup>2</sup>->F，（µ a:F<sup>2</sup> a->F a） -}</p>

<p>µ :: (Applicative f) => a -> f (f a) -> f a</p>

<p><br/></p>

<p>{- 自然变换η:I->F，（η a:I a->F a） -}</p>

<p>η :: (Applicative f) => a -> a -> (f a)</p>

<p><br/></p>

<h2>自函子范畴上的幺半群</h2>

<p>以范畴C上的自函子为对象，自然变换为箭头，</p>

<p>构成的函子范畴，称为<strong>自函子范畴</strong>。</p>

<p><br/></p>

<p>对比Monad定义中的自函子F与幺半群中的集合M，</p>

<p><br/></p>

<p><strong>结合律</strong>：</p>

<pre>           1 × µ<br>M × M × M -------&gt; M × M<br>    |                |<br>    | µ × 1          | µ<br>    |                |<br>    v                v<br>  M × M   -------&gt;   M<br>             µ</pre>




<pre>           F • µ<br>F • F • F -------&gt; F • F<br>    |                |<br>    | µ • F          | µ<br>    |                |<br>    v                v<br>  F • F   -------&gt;   F<br>             µ</pre>


<p><strong>幺元</strong>：</p>

<pre>        η × 1          1 × η<br>1 × M -------&gt; M × M &lt; ------- M × 1<br>  |              |               |<br>  | α            | µ             | β<br>  |              |               |<br>  v              v               v<br>  M      =       M        =      M</pre>




<pre>        η • F          F • η<br>I • F -------&gt; F • F &lt; ------- F • I<br>                 |                <br>  ||             | µ            ||<br>                 |               <br>                 v                <br>  F      =       F        =      F</pre>


<p><br/></p>

<p>可知，自函子F相当于群的集合M，自然变换µ相当于群乘法，单位自函子相当于幺元，它们构成了一个<strong>幺半群</strong>，</p>

<p>即<strong>Monad是Hask自函子范畴上的幺半群</strong>。</p>

<p><br/></p>

<p>注：</p>

<p>M × M × M表示集合M的笛卡尔积，</p>

<p>而F • F • F表示自函子F的组合。</p>

<p><br/></p>

<h2>幺半群范畴（monoidal category）</h2>

<p>幺半群在范畴论中是有了新的意义，</p>

<p>比群论中的概念更一般化。</p>

<p><br/></p>

<p>我们可以为范畴增加一个满足结合律的二元函子，</p>

<p>构成一个『范畴论意义上的』<strong>幺半群</strong>（monoid）。</p>

<p><br/></p>

<p>说一个范畴是具有幺半群结构的（monodial），</p>

<p>如果它有一个像笛卡尔积，或者直和，张量积，那样的『乘积』，</p>

<p>并且，这个『乘积』满足结合律，还有一个单位元。</p>

<p><br/></p>

<p>即，一个<strong>严格幺半群范畴</strong>（strict monoidal category）是范畴B上的一个结构&lt;B,□,e&gt;，</p>

<p>其中□是一个满足结合律的二元函子，□: B × B -> B，</p>

<p>□ (□ × 1) = □ (1 × □) : B × B × B -> B</p>

<p>而且存在对象e是二元函子□的单位元，</p>

<p>□ (e × 1) = id(B) = □ (1 × e)</p>

<p><br/></p>

<p>然后就可以在任意的幺半群范畴&lt;B,□,e&gt;中定义幺半群了。</p>

<p><br/></p>

<p>幺半群范畴B上的<strong>幺半群</strong>由三部分组成，&lt;c,µ,η&gt;，</p>

<p>其中c是B中的对象，µ : c □ c -> c，η : e -> c是范畴B中的箭头，</p>

<p>且满足以下条件</p>

<pre>               σ                  µ □ 1<br>c □ (c □ c) -------&gt; (c □ c) □ c -------&gt; c □ c<br>    |                                       |<br>    | 1 □ µ                                 | µ<br>    |                                       |<br>    v                                       v<br>  c □ c ----------------------------------&gt; c<br>                        µ</pre>




<pre>        η □ 1          1 □ η<br>e □ c -------&gt; c □ c &lt; ------- c □ e<br>  |              |               |<br>  | α            | µ             | β<br>  |              |               |<br>  v              v               v<br>  c      =       c        =      c</pre>


<p><br/></p>

<h2>结语</h2>

<p>『All told, a monad in X is just a monoid in the category of endofunctors of X,</p>

<p>with the product × replaced by composition of endofunctors</p>

<p>and unit set by the identity endofunctor.』</p>

<p><br/></p>

<p>一语成谶，很多人都是因为这句话入坑的，</p>

<p>然而理解它真的很不容易，</p>

<p>原来这个『幺半群』应该在范畴论意义上进行理解，</p>

<p>已经不是集合论基础上群论的内容了。</p>

<p><br/></p>

<p>在写这篇文章时，我甚至还没有入门，有错误在所难免，</p>

<p>但是多年坚持下来，似乎对这个问题有些眉目了，</p>

<p>于是就赶紧整理了一下，希望接下来以此为起点继续努力，勇往直前。</p>

<p><br/></p>

<p><strong>参考</strong>：</p>

<p>《<a href="http://book.douban.com/subject/4201293/">近世代数引论</a>》</p>

<p>《<a href="http://book.douban.com/subject/1823110/">Categories for the Working Mathematician 2nd</a>》</p>

<p><a href="https://medium.com/@brettwines/implementing-a-category-theoretic-hask-monad-in-haskell-7bf662f2e98b">Implementing a category-theoretic Hask-monad in Haskell</a></p>

<p><a href="http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem">A monad is just a monoid in the category of endofunctors, what&rsquo;s the problem?</a></p>

<p><a href="http://slides.com/julientournay/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-what-s-the-problem/fullscreen">A MONAD IS JUST A MONOID IN THE CATEGORY OF ENDOFUNCTORS. WHAT&rsquo;S THE PROBLEM ?</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[积极成长]]></title>
    <link href="https://thzt.github.io/blog/2015/12/22/grow-up-positively/"/>
    <updated>2015-12-22T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/12/22/grow-up-positively</id>
    <content type="html"><![CDATA[<p>飞机晚点了。</p>

<p><br/></p>

<p>正好趁这个机会，整理下思路，</p>

<p>这些天居然以技术人员的身份杀入到<strong>产品和需求的讨论</strong>中了，</p>

<p>真是一个挑战。</p>

<p><br/></p>

<p>对我来说，</p>

<p>之前看的一些软件工程，需求分析，产品设计的知识终于用上了。</p>

<p>即使这样，<strong>给我带来的改变是仍旧是巨大的</strong>。</p>

<p><br/></p>

<p>第一次因为公事出差，</p>

<p>第一次说这么多话，</p>

<p>第一次忙的没时间写代码。</p>

<p><br/></p>

<h2><strong>学会沟通</strong></h2>

<p>这些经历，让我理解到，</p>

<p><strong>一开始把自己定位成一个程序的编写者，</strong></p>

<p><strong>是多么的狭隘。</strong></p>

<p><br/></p>

<p>也让我认识到，</p>

<p><strong>软件工程师自称的不善言辞，</strong></p>

<p><strong>其实更多的是一种借口。</strong></p>

<p><br/></p>

<p>当我们不得不了解用户的问题，</p>

<p>当我们不得不修正根本不解决问题的解决方案时，</p>

<p>就<strong>必须学会沟通</strong>。</p>

<p><br/></p>

<h2><strong>以身试毒</strong></h2>

<p>语言是思想的交流媒介，不是思想本身，</p>

<p>因此，即使进行再多的交流，</p>

<p><strong>两个人的理解总是会有偏差的</strong>。</p>

<p><br/></p>

<p>业务人员不知道我们能为他们做到什么程度，</p>

<p>技术人员不知道我们是否真的解决了问题。</p>

<p>这些都是需要交流的。</p>

<p><br/></p>

<p>武侠小说中，</p>

<p>经常出现，神医为了解毒，以身试毒。</p>

<p>我现在觉得，<strong>这种胆略，才是真正想要解决问题的态度</strong>。</p>

<p><br/></p>

<h2><strong>我做的了</strong></h2>

<p>当客观条件不允许时，</p>

<p>达不到专业的标准，是情有可原的。</p>

<p>正如一个软件系统，</p>

<p>如果工期太短，那么<strong>短期内</strong>的质量低下是不可避免的。</p>

<p><br/></p>

<p>然而，当解决了用户的主要问题后，</p>

<p><strong>剩下大把的空闲时间，如果不努力提高品质，</strong></p>

<p><strong>就是主观原因了。</strong></p>

<p><br/></p>

<p>经历这次讨论，让我学到无论做什么事，</p>

<p>都应该用专业的标准要求自己。</p>

<p><strong>任何形式的『我做不了』，短期来看可原谅，长期来看就是慵懒。</strong></p>

<p><br/></p>

<p>成功者想办法，失败者找理由。</p>

<p><br/></p>

<h2><strong>先活下来</strong></h2>

<p>最后，让我理解到的是，</p>

<p><strong>软件必须首先能解决问题，能创造效益，</strong></p>

<p><strong>才有存活下来的可能。</strong></p>

<p><br/></p>

<p>一开始可能很丑陋，但是活下来了。</p>

<p>胜过一切漂亮的框架，优雅的结构。</p>

<p><br/></p>

<p>一方面，通过分析需求的优先级，</p>

<p>解决<strong>真正困扰用户的难题</strong>。</p>

<p>另一方面，用这仅有的争取得来的时间，</p>

<p>提高扩展性，以适应业务的发展。</p>

<p><br/></p>

<h2><strong>不要急躁</strong></h2>

<p>努力用最短的时间解决问题，是好样的，</p>

<p>然而，这并不能消除后期<strong>修正方案</strong>的可能性。</p>

<p><br/></p>

<p>尤其是沟通过程中，</p>

<p>这很重要，</p>

<p><strong>别人总是担心我们给他们看的就是最终的解决方案。</strong></p>

<p><br/></p>

<p>实际上，软件是活的，</p>

<p>事情是发展的，</p>

<p>业务场景，以及别人的理解也是变化的，</p>

<p>甚至市场氛围也是瞬息万变。</p>

<p><br/></p>

<p>我学会了<strong>着眼于程度</strong>，</p>

<p>而不是<strong>判断</strong>。</p>

<p><br/></p>

<p>如果没有完全解决，那么<strong>是否比昨天更好</strong>，</p>

<p>有没有进步。</p>

<p><br/></p>

<h2><strong>逐步调整</strong></h2>

<p>理想中，只要切题，我们的方案一出，</p>

<p>用户的问题，马上就能得到解决。</p>

<p>它是那么有效，那么一阵见血。</p>

<p><br/></p>

<p>然而，<strong>现实并不是这样的</strong>。</p>

<p><strong>能做出什么样的改变，完全取决于目前的项目状态。</strong></p>

<p><br/></p>

<p>我们想的很好，</p>

<p>然而，能做的，只是进行<strong>有限范围</strong>上的调整。</p>

<p><br/></p>

<p>要落到实处，方案就必须能和现有的系统接轨，</p>

<p>完全废弃一个系统是不可能的，</p>

<p>代价也太高了。</p>

<p><br/></p>

<p>此外，我们必须能够改善现状，</p>

<p>才能证明我们可以做的更好。</p>

<p><br/></p>

<p>把现在的事情做好，是证明自己能把其他事情做好的唯一办法。</p>

<p><br/></p>

<h2><strong>团队无价</strong></h2>

<p>随着年龄的增长，我发现个人的作用越来越小了，</p>

<p>因为，<strong>同龄人是其他行业专家的可能性越来越大</strong>。</p>

<p><br/></p>

<p>你在这个领域深入研究了10年，</p>

<p>另外一个人就完全有可能在其他领域深入研究了10年。</p>

<p>而从外表上是看，是无法区分的。</p>

<p><br/></p>

<p>这跟学生阶段是完全不同的，</p>

<p><strong>学生之间的差距更多的是同领域深入程度的差距</strong>。</p>

<p><br/></p>

<p>因此，为了把事情做好，</p>

<p><strong>我们需要各领域的专家一起交流</strong>，</p>

<p>这样的团队是无价的，一个人不可能面面俱到。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>飞机要起飞了。</p>

<p><br/></p>

<p>先总结到这里，继续努力。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[守住天赋]]></title>
    <link href="https://thzt.github.io/blog/2015/12/01/defend-the-advantage/"/>
    <updated>2015-12-01T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/12/01/defend-the-advantage</id>
    <content type="html"><![CDATA[<p>人们的智商其实都差不多，</p>

<p>谁能比谁笨呢，</p>

<p>但是每个人的<strong>天赋</strong>却各有不同。</p>

<p><br/></p>

<p>在自己有天赋的领域努力，</p>

<p>会成长迅猛，事半功倍，</p>

<p>收获到意想不到的成果。</p>

<p><br/></p>

<p>随着现代社会节奏的加快，</p>

<p>随着人们交流方式的进步发展，</p>

<p>我们更容易看到别人在做着什么了。</p>

<p><br/></p>

<p>有的人擅长这个，</p>

<p>有的人擅长那个，</p>

<p><strong>我们自己的呢？好像什么都很差。</strong></p>

<p><br/></p>

<p>这时候，我们该怎么办呢？</p>

<p>我们想努力，</p>

<p>可是努力的方向在哪呢？</p>

<p><br/></p>

<p><strong>不是我不努力，</strong></p>

<p><strong>而是我不知道该努力做什么。</strong></p>

<p><br/></p>

<h2><strong>保住优势</strong></h2>

<p>中学时代，我很偏科，</p>

<p>对于自己喜欢的课程，会不留余力的学习，</p>

<p>这就导致在考试时，有几门弱科丢分严重。</p>

<p><br/></p>

<p>班主任是一个喜欢开导人的好老师，</p>

<p>又一次谈到了偏科问题。</p>

<p>我不由得问到，</p>

<p><strong>我是不是该放弃某些强势科目的学习，</strong></p>

<p><strong>花时间把弱科补好？</strong></p>

<p><br/></p>

<p>班主任说，不要那么做。</p>

<p><strong>你应该保住优势，学到出类拔萃，</strong></p>

<p><strong>同时把弱科学到不是太弱就行了。</strong></p>

<p><br/></p>

<p>我瞬间觉得，事情简单多了，</p>

<p>对弱科我对自己有了<strong>不一样的要求</strong>了。</p>

<p><br/></p>

<p>没有弱科，<strong>别人就无法轻易击败我</strong>，</p>

<p>有强科，就能轻松的拿到高分。</p>

<p><br/></p>

<h2><strong>防守赢得冠军</strong></h2>

<p>学打篮球时，经常听到这样的说法，</p>

<p>进攻赢得比赛，防守赢得冠军。</p>

<p><br/></p>

<p>是说最终获胜的队伍，</p>

<p>靠的是坚不可摧的防守，</p>

<p>而不是犀利的进攻。</p>

<p><br/></p>

<p><strong>防守不好的话，就会很被动，疲于奔命。</strong></p>

<p><strong>只有防守不是那么弱，进攻方面才有发挥的余地。</strong></p>

<p><br/></p>

<p>个人懂得防守，可以坚定自己，</p>

<p>团队懂得防守，可以稳定自己，</p>

<p>公司懂得防守，可以稳固自己。</p>

<p><br/></p>

<p>总是被别人指使，</p>

<p>没有自己的<strong>灵魂</strong>，</p>

<p>是经不住风吹雨打的。</p>

<p><br/></p>

<h2><strong>建立自我意识</strong></h2>

<p>认识自己，是一件很难的事情，</p>

<p>拥有<strong>自我意识</strong>和<strong>独立的知识体系</strong>，</p>

<p>才能避免被碎片化的信息淹没。</p>

<p><br/></p>

<p>科技发展革新太快，</p>

<p>一看到什么火起来，</p>

<p>都会一窝蜂的跑过去。</p>

<p><br/></p>

<p>可悲的是，人们只看到了短期效益，</p>

<p>长远看来，却未必是好事。</p>

<p><strong>经常救火的会一直救火，</strong></p>

<p><strong>经常加班的会一直加班，</strong></p>

<p><strong>经常跟风的会一直跟风，</strong></p>

<p><strong>因为缺少自我意识。</strong></p>

<p><br/></p>

<p>有独立人格的人们，</p>

<p>会分析自己的优势和弱势，更加理智客观，</p>

<p><strong>明白自己需要什么，</strong></p>

<p><strong>有选择的接触新的知识。</strong></p>

<p><br/></p>

<p>只有根深蒂固，才能避免随波逐流，</p>

<p>才能产生自己的<strong>价值</strong>，而不是为浪潮贡献死水。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>学习，是一种<strong>进攻</strong>手段，</p>

<p>我们可以掠夺本来别人擅长的知识。</p>

<p>具有优秀的学习能力，是好事。</p>

<p><br/></p>

<p>然而，与此同时，</p>

<p>我们仍然<strong>不要忘记防守</strong>，</p>

<p><strong>要保住自己的天赋，不要方方面面平民化。</strong></p>

<p><br/></p>

<p>天赋是上天给予我们的礼物，</p>

<p>我们总会要拿来做一番事业的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[问题洁癖]]></title>
    <link href="https://thzt.github.io/blog/2015/11/25/fanatic-for-cleanliness-on-solving-problems/"/>
    <updated>2015-11-25T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/11/25/fanatic-for-cleanliness-on-solving-problems</id>
    <content type="html"><![CDATA[<p>我们遇到过大大小小的困难，</p>

<p>它们经常蜂拥而至，</p>

<p>我们很想把这些恼人的事情处理好，</p>

<p><strong>不想堵在这里</strong>。</p>

<p><br/></p>

<p>我们目光很敏锐，</p>

<p>似乎看到了别人发现不了的失误，</p>

<p>我们操碎了心想改善它，</p>

<p><strong>不想放任不管</strong>。</p>

<p><br/></p>

<p>我们想做一桩买卖，</p>

<p>因为明显有了一个好主意，且时间紧迫，</p>

<p>我们会<strong>不计成本，不惜代价</strong>，</p>

<p>也要赶出来。</p>

<p><br/></p>

<p>这一切是不是很熟悉？</p>

<p><br/></p>

<p>当我们遇到问题，受到压力时，</p>

<p>通常的反应是不择手段的，</p>

<p><strong>不够冷静</strong>，是失败的前兆。</p>

<p><br/></p>

<p>为什么会这样呢？</p>

<p>是因为我们有<strong>问题洁癖</strong>。</p>

<p><br/></p>

<h2><strong>冷静下来</strong></h2>

<p>保持冷静的唯一办法就是，</p>

<p><strong>做好准备</strong>。</p>

<p><br/></p>

<p>有些时候，事情比较多，</p>

<p>这是正常的，</p>

<p>不全是自己的原因。</p>

<p><br/></p>

<p>孙子兵法说：</p>

<p>打仗的原则是，不要寄希望于敌人不来，</p>

<p>而要依靠自己有充分准备，严阵以待；</p>

<p>不要寄希望于敌人不会进攻，</p>

<p>而要依靠自己有敌人不可攻破的条件。</p>

<p><br/></p>

<p>因此，要事先分析一下，</p>

<p>各种紧急态势的应对方案，</p>

<p><strong>有备而无患</strong>。</p>

<p><br/></p>

<h2><strong>考虑效益</strong></h2>

<p>不计成本，往往成本高昂。</p>

<p>不择手段，往往用的不是最佳的办法。</p>

<p><br/></p>

<p>在决定做一件事情的时候，</p>

<p>我们不得不考虑<strong>成本，风险和收益</strong>，</p>

<p>否则运转下去就难以维持了。</p>

<p><br/></p>

<p>在决定做一件事情的时候，</p>

<p>我们还不得不考虑<strong>价值</strong>，</p>

<p>解决了什么问题，对现状有没有改善，</p>

<p>这决定别人是否可以参与进来。</p>

<p><br/></p>

<p>有些问题，只有我们自己想把它解决，</p>

<p>却并不带来任何效益和价值，</p>

<p>那么这件事也只是为了解开自己的<strong>心结</strong>罢了。</p>

<p><br/></p>

<h2><strong>排优先级</strong></h2>

<p>另一个慌乱的原因是，</p>

<p>我们没有理清事情的优先级。</p>

<p>而强迫自己处理能力之外的事情，</p>

<p>显然是在<strong>冒险</strong>。</p>

<p><br/></p>

<p>因此，秉着对自己乃至别人负责的原则，</p>

<p>我们要<strong>专业的处理事情</strong>。</p>

<p>哪些问题是不重要的，</p>

<p>哪些问题事关生死存亡，</p>

<p>我们要心里清楚。</p>

<p><br/></p>

<p>事情是做不完的。</p>

<p>因此<strong>不要考虑怎样做完</strong>，</p>

<p><strong>而是要考虑做到什么程度</strong>。</p>

<p><br/></p>

<p>有了优先级，</p>

<p>我们就有了完成度的标准，</p>

<p>有了评判合格，良好，优秀的准绳。</p>

<p><br/></p>

<h2><strong>保持顺畅</strong></h2>

<p>问题洁癖，</p>

<p>意指那些<strong>急于解决一切问题的行为习惯</strong>。</p>

<p><br/></p>

<p>这是不专业的，</p>

<p>也是容易被事情驱动的，</p>

<p>每天的生活就是做任务，赶进度。</p>

<p><br/></p>

<p>优秀的商务人士，</p>

<p>总是会说，<strong>请把事情安排到我的日程中</strong>。</p>

<p>这是非常值得我们学习的地方。</p>

<p><br/></p>

<p>我们要保持顺畅，</p>

<p>但不是没有事情可做，</p>

<p>而是<strong>有条不紊的处理</strong>它们。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>越紧急就越慌张，</p>

<p>越急迫就越得不到。</p>

<p>这是人性的弱点。</p>

<p><br/></p>

<p>每个人都会有弱点，</p>

<p>不同的是，有的人可以<strong>控制</strong>它。</p>

<p>佛家的修行，就是管控能力的训练。</p>

<p><br/></p>

<p>能在不断涌现的琐事中<strong>保持心态平和</strong>，</p>

<p>就已然<strong>成功</strong>了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数理逻辑定义汇总]]></title>
    <link href="https://thzt.github.io/blog/2015/11/23/introduction-to-mathematical-logic/"/>
    <updated>2015-11-23T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/11/23/introduction-to-mathematical-logic</id>
    <content type="html"><![CDATA[<script src="https://thzt.github.io/thirdpart/jQuery/jquery-1.11.1.js"></script>


<p><link href="https://thzt.github.io/thirdpart/KaTeX/katex.min.css" rel="stylesheet"/></p>

<script src="https://thzt.github.io/thirdpart/KaTeX/katex.min.js"></script>


<script src="https://thzt.github.io/javascripts/katex.js"></script>


<p><strong>逻辑学</strong>真是博大精深，</p>

<p>first-order logic，propositional logic，predicate logic，</p>

<p>mathematical logic，second-order Logic，intuitionistic logic，</p>

<p>modal logic，free logic，plural logic&hellip;</p>

<p><br/></p>

<p>所涉及的内容也很广，</p>

<p>set theory，proof theory，model theory，recursion theory，</p>

<p>theory of computation，computability and decidability&hellip;</p>

<p><br/></p>

<p>学习它，对<strong>数学</strong>，<strong>计算机科学</strong>或其他学科都有指导意义。</p>

<p><br/></p>

<p>例如，哥德尔协调性定理指出了公理化方法的局限性，</p>

<p>它告诉我们，<strong>在理论上就不能通过逻辑推理解决所有的问题</strong>，</p>

<p>必要时，要通过构造模型来进行检验。</p>

<p>对软件进行测试，就是这样的一个例子。</p>

<p><br/></p>

<p>例如，<strong>类型系统</strong>，相当于加在程序语言语法层面上的(谓词)逻辑，</p>

<p>类型系统的<strong>可靠性</strong>保证了语法正确的程序，</p>

<p>语义上也是满足规范的。</p>

<p><br/></p>

<p>这样的例子还有很多，</p>

<p>实际工作中，只有<strong>见多识广</strong>，站在更高的角度，</p>

<p>才能做到庖丁解牛，<strong>游刃有余</strong>。</p>

<p><br/></p>

<p>到此，我们还是从一阶谓词逻辑开始，慢慢打好基础吧。</p>

<p>以下摘自《<a href="http://book.douban.com/subject/2364517/">数理逻辑</a>》——李未</p>

<p><br/></p>

<h2><strong>一阶语言的定义</strong></h2>

<p>每个一阶语言的字符集由两类符号集合组成。</p>

<p>一类称为逻辑符号集合，另一类称为非逻辑符号集合。</p>

<p><br/></p>

<p><strong>逻辑符号集合</strong>包括：</p>

<p><span data-katex="V"></span>：变元符号集合，<span data-katex="x_1, x_2, ..., x_n, ..."></span></p>

<p><span data-katex="C"></span>：逻辑连接词符号集合，<span data-katex="\neg , \wedge , \vee , \rightarrow , \leftrightarrow"></span></p>

<p><span data-katex="Q"></span>：量词符号集合，<span data-katex="\forall , \exists"></span></p>

<p><span data-katex="E"></span>：等词符号集合，<span data-katex="\doteq"></span></p>

<p><span data-katex="P"></span>：括号集合，<span data-katex="(, )"></span></p>

<p><br/></p>

<p><strong>非逻辑符号集合</strong>包括：</p>

<p><span data-katex="\mathscr{L}_c"></span>：常元符号集合，<span data-katex="c_1, c_2, ..."></span></p>

<p><span data-katex="\mathscr{L}_f"></span>：函数符号集合，<span data-katex="f_1, f_2, ..."></span></p>

<p><span data-katex="\mathscr{L}_P"></span>：谓词符号集合，<span data-katex="P_1, P_2, ..."></span></p>

<p><br/></p>

<p><strong>例子：</strong>初等算术语言<span data-katex="\mathscr{A}"></span></p>

<p>初等算术语言是一个一阶语言，</p>

<p>它的常元符号集为<span data-katex="\{0\}"></span>，</p>

<p>函数符号集为<span data-katex="\{S, +, \cdot \}"></span>，</p>

<p>谓词符号集合为<span data-katex="\{<\}"></span>。</p>

<p><br/></p>

<h2><strong>项</strong></h2>

<p>一阶语言<span data-katex="\mathscr{L}"></span>中的项被下述三个规则归纳的定义：</p>

<p><span data-katex="T_1"></span>：每一个常元是一个项</p>

<p><span data-katex="T_2"></span>：每一个变元是一个项</p>

<p><span data-katex="T_3"></span>：如果<span data-katex="t_1, ..., t_n"></span>是项，而f是一个n元函数符号，那么，<span data-katex="ft_1\cdot \cdot \cdot t_n"></span>是一个项</p>

<p><br/></p>

<p>此定义也可以表述成下述形式：</p>

<p><span data-katex="t ::= c | x | ft_1\cdot \cdot \cdot t_n"></span></p>

<p><br/></p>

<p><strong>例子：</strong><span data-katex="\mathscr{A}"></span>的项</p>

<p><span data-katex="S0, Sx_1, +S0SSx, \cdot x_1+Sx_1x_2"></span></p>

<p><br/></p>

<h2><strong>逻辑公式</strong></h2>

<p>语言<span data-katex="\mathscr{L}"></span>中的逻辑公式，简称<strong>公式</strong>，用大写字母<span data-katex="A, B, ..."></span>表示，并用下述五条规则归纳的定义：</p>

<p><br/></p>

<p><span data-katex="F_1"></span>：如果<span data-katex="t_1"></span>和<span data-katex="t_2"></span>为项，那么<span data-katex="t_1\doteq t_2"></span>是公式</p>

<p><span data-katex="F_2"></span>：如果<span data-katex="t_1, ..., t_n"></span>为项，而<span data-katex="R"></span>是一个n元谓词，那么<span data-katex="Rt_1\cdot \cdot \cdot t_n"></span>是公式</p>

<p><span data-katex="F_3"></span>：如果<span data-katex="A"></span>是公式，则<span data-katex="\neg A"></span>是公式</p>

<p><span data-katex="F_4"></span>：若<span data-katex="A, B"></span>是公式，则<span data-katex="A\wedge B, A\vee B, A\rightarrow B, A\leftrightarrow B"></span>都是公式</p>

<p><span data-katex="F_5"></span>：若<span data-katex="A"></span>是公式并且<span data-katex="x"></span>是一个变元，那么<span data-katex="\forall xA"></span>和<span data-katex="\exists xA"></span>也是公式，<span data-katex="x"></span>称为<strong>约束变元</strong></p>

<p><br/></p>

<p>上述结构归纳定义的Backus范式为：</p>

<p><span data-katex="A ::= t_1\doteq t_2 | Rt_1\cdot \cdot \cdot t_n | \neg A | A\wedge B | A\vee B | A\rightarrow B | A\leftrightarrow B | \forall xA | \exists xA"></span></p>

<p><br/></p>

<p><strong>例子：</strong><span data-katex="\mathscr{A}"></span>的公式</p>

<p><span data-katex="\forall x\neg (Sx\doteq 0), \forall x\forall y(< xy\rightarrow(\exists (y\doteq +xz)))"></span></p>

<p><br/></p>

<h2><strong><span data-katex="\mathscr{L}"></span>的结构</strong></h2>

<p>一阶语言<span data-katex="\mathscr{L}"></span>的<strong>结构</strong><span data-katex="M"></span>是一个偶对，记为<span data-katex="M=(\mathbb{M}, I)"></span>，其中，</p>

<p>（1）<span data-katex="\mathbb{M}"></span>是一个非空集合，称为<strong>论域</strong></p>

<p>（2）<span data-katex="I"></span>是从<span data-katex="\mathscr{L}"></span>到<span data-katex="\mathbb{M}"></span>的映射，称为<strong>解释</strong>，记为<span data-katex="I:\mathscr{L} \rightarrow \mathbb{M}"></span>，它满足下面三个条件</p>

<p>a) 对<span data-katex="\mathscr{L}"></span>中的每一个常元符号<span data-katex="c"></span>，<span data-katex="I(c)"></span>是<span data-katex="\mathbb{M}"></span>中的元素</p>

<p>b) 对<span data-katex="\mathscr{L}"></span>中的每一个n元函数符号<span data-katex="f"></span>，<span data-katex="I(f)"></span>是<span data-katex="\mathbb{M}"></span>上的n元函数</p>

<p>c) 对<span data-katex="\mathscr{L}"></span>中的每一个n元谓词符号<span data-katex="P"></span>，<span data-katex="I(P)"></span>是<span data-katex="\mathbb{M}"></span>上的一个n元关系</p>

<p><br/></p>

<p><strong>例子：</strong><span data-katex="\mathscr{A}"></span>的结构</p>

<p><span data-katex="\mathscr{A}"></span>的常元符号为<span data-katex="0"></span>，</p>

<p>函数符号有<span data-katex="\{S, +, \cdot \}"></span>，</p>

<p>谓词符号只有一个，它是<span data-katex="<"></span>。</p>

<p><br/></p>

<p>我们定义偶对<span data-katex="N=(\mathbb{N}, I)"></span>，其中论域<span data-katex="\mathbb{N}"></span>为自然数系。</p>

<p>令<span data-katex="s"></span>为<span data-katex="\mathbb{N}"></span>上的加1函数，即<span data-katex="s(x)=x+1"></span>，</p>

<p><span data-katex="+, \cdot"></span>代表<span data-katex="\mathbb{N}"></span>上的加法和乘法，</p>

<p><span data-katex="<"></span>为<span data-katex="\mathbb{N}"></span>上的小于关系。</p>

<p><br/></p>

<p>我们定义解释映射<span data-katex="I"></span>如下：</p>

<p><span data-katex="I(0)=0, I(S)=s, I(+)=+, I(\cdot )=\cdot , I(<)=<"></span></p>

<p><br/></p>

<p>解释映射<span data-katex="I"></span>将常元符号<span data-katex="0"></span>解释为自然数<span data-katex="0"></span>，</p>

<p>将一元函数符号<span data-katex="S"></span>解释为自然数集合上的加1运算<span data-katex="s"></span>，</p>

<p>将二元函数符号<span data-katex="+"></span>和<span data-katex="\cdot"></span>分别解释为自然数集合上的加法和乘法，</p>

<p>将二元谓词符号<span data-katex="<"></span>解释为自然数集合上的小于关系，</p>

<p>而<span data-katex="N"></span>是初等算术语言<span data-katex="\mathscr{A}"></span>的一个结构。</p>

<p><br/></p>

<h2><strong>赋值</strong></h2>

<p>赋值<span data-katex="\sigma"></span>是一个定义域为变元集合<span data-katex="V"></span>，值域为<span data-katex="\mathbb{M}"></span>的一个映射，记为<span data-katex="\sigma :V\rightarrow \mathbb{M}"></span>。</p>

<p>赋值<span data-katex="\sigma"></span>把<span data-katex="\mathscr{L}"></span>中的每一个变元<span data-katex="x"></span>，赋以论域<span data-katex="\mathbb{M}"></span>中的一个元素<span data-katex="a\in \mathbb{M}"></span>，</p>

<p>记为<span data-katex="\sigma (x)=a"></span>。</p>

<p><br/></p>

<h2><strong>模型</strong></h2>

<p>给定一阶语言<span data-katex="\mathscr{L}"></span>，以及它的结构<span data-katex="M"></span>和赋值<span data-katex="\sigma"></span>，</p>

<p>偶对<span data-katex="(M, \sigma )"></span>称为<span data-katex="\mathscr{L}"></span>的一个<strong>模型</strong>。</p>

<p><br/></p>

<h2><strong>项的语义</strong></h2>

<p>给定一阶语言<span data-katex="\mathscr{L}"></span>，结构<span data-katex="M=(\mathbb{M}, I)"></span>和赋值<span data-katex="\sigma :V\rightarrow \mathbb{M}"></span>。</p>

<p>在模型<span data-katex="(M, \sigma )"></span>下，项<span data-katex="t"></span>的语义是<span data-katex="\mathbb{M}"></span>中的一个元素，它用<span data-katex="t_{M[\sigma]}"></span>表示，并被归纳的定义：</p>

<p>（1）<span data-katex="x_{M[\sigma ]}=\sigma (x)"></span>，<span data-katex="x"></span>为变元符号</p>

<p>（2）<span data-katex="c_{M[\sigma ]}=c_M"></span>，<span data-katex="c"></span>为常元符号</p>

<p>（3）<span data-katex="(ft_1\cdot \cdot \cdot t_n)_{M[\sigma ]}=f_M((t_1)_{M[\sigma ]},\cdot \cdot \cdot (t_n)_{M[\sigma ]})"></span></p>

<p><br/></p>

<p><strong>例子：</strong><span data-katex="\mathscr{A}"></span>项的语义</p>

<p><span data-katex="(+x_1Sx_7)_{N[\sigma ]}=(x_1)_{N[\sigma ]}+(Sx_7)_{N[\sigma ]}=1+((x_7)_{N[\sigma ]}+1)=1+(7+1)=9"></span></p>

<p><br/></p>

<h2><strong>逻辑连接词符号的语义</strong></h2>

<p>为了避免逻辑连接词符号的多义性，我们把每一个逻辑连接词符号的语义都定义为一个真值函数，</p>

<p>此函数的定义域是一个真值集合或两个真值集合的笛卡尔积，而函数值是一个真假值。</p>

<p>对于一阶语言而言，逻辑连接词符号<span data-katex="\neg"></span>的真值函数为<span data-katex="B_\neg"></span>，</p>

<p>其自变量是<span data-katex="X"></span>，<span data-katex="X"></span>只能取<span data-katex="T"></span>和<span data-katex="F"></span>，</p>

<p>而函数值<span data-katex="B_\neg (X)"></span>由下述真值表定义：</p>

<p><span data-katex="B_\neg (T)=F, B_\neg (F)=T"></span></p>

<p><br/></p>

<p>二元函数<span data-katex="B_\wedge, B_\vee, B_\rightarrow, B_\leftrightarrow"></span>分别为逻辑连接词符号<span data-katex="\wedge, \vee, \rightarrow, \leftrightarrow"></span>的真值函数。</p>

<p><br/></p>

<h2><strong>公式的语义</strong></h2>

<p>设<span data-katex="M"></span>和<span data-katex="\sigma"></span>分别为一阶语言<span data-katex="\mathscr{L}"></span>的结构和赋值，而<span data-katex="A"></span>为<span data-katex="\mathscr{L}"></span>的公式。</p>

<p>公式<span data-katex="A"></span>在模型<span data-katex="(M, \sigma )"></span>下的语义是一个真假值，用<span data-katex="A_{M[\sigma ]}"></span>表示，被归纳的定义如下：</p>

<p>（1）<span data-katex="(Pt_1\cdot \cdot \cdot t_n)_{M[\sigma ]}=P_M((t_1)_{M[\sigma ]},\cdot \cdot \cdot ,(t_n)_{M[\sigma ]})"></span></p>

<p>（2）<span data-katex="(t_1\doteq t_2)_{M[\sigma ]}=\begin{cases}T,&\text{if }(t_1)_{M[\sigma ]}=(t_2)_{M[\sigma ]}\\F,&\text{otherwise}\end{cases}"></span></p>

<p>（3）<span data-katex="(\neg A)_{M[\sigma ]}=B_\neg (A_{M[\sigma ]})"></span></p>

<p>（4）<span data-katex="(A\vee B)_{M[\sigma ]}=B_\vee (A_{M[\sigma ]}, B_{M[\sigma ]})"></span></p>

<p>（5）<span data-katex="(A\wedge B)_{M[\sigma ]}=B_\wedge (A_{M[\sigma ]}, B_{M[\sigma ]})"></span></p>

<p>（6）<span data-katex="(A\rightarrow B)_{M[\sigma ]}=B_\rightarrow (A_{M[\sigma ]}, B_{M[\sigma ]})"></span></p>

<p>（7）<span data-katex="(A\leftrightarrow B)_{M[\sigma ]}=B_\leftrightarrow (A_{M[\sigma ]}, B_{M[\sigma ]})"></span></p>

<p>（8）<span data-katex="(\forall x_iA)_{M[\sigma ]}=\begin{cases}T,&\forall a\in M, A_{M[\sigma [x_i:=a]]}=T\\F,&\text{otherwise}\end{cases}"></span></p>

<p>（9）<span data-katex="(\exists x_iA)_{M[\sigma ]}=\begin{cases}T,&\exists a\in M, A_{M[\sigma [x_i:=a]]}=T\\F,&\text{otherwise}\end{cases}"></span></p>

<p><br/></p>

<h2><strong>可满足性</strong></h2>

<p>给定一阶语言<span data-katex="\mathscr{L}"></span>和它的公式<span data-katex="A"></span>以及公式集合<span data-katex="\Gamma"></span>。</p>

<p>如果存在模型<span data-katex="(M, \sigma )"></span>，使得<span data-katex="A_{M[\sigma ]}=T"></span>成立，</p>

<p>那么称公式<span data-katex="A"></span>关于模型<span data-katex="(M, \sigma )"></span>是<strong>可满足的</strong>，</p>

<p>简称<span data-katex="A"></span>可满足，也称为模型<span data-katex="(M, \sigma )"></span>满足<span data-katex="A"></span>，记为<span data-katex="M\models _\sigma A"></span>。</p>

<p>如果<span data-katex="A"></span>是一个语句，那么记为<span data-katex="A"></span>，记为<span data-katex="M\models A"></span></p>

<p><br/></p>

<p>如果<span data-katex="\Gamma"></span>中的每一个公式关于模型<span data-katex="(M, \sigma )"></span>都是可满足的，即，</p>

<p><span data-katex="M\models _\sigma A"></span>对于任意<span data-katex="A\in \Gamma"></span>成立，</p>

<p>那么称为公式集合<span data-katex="\Gamma"></span>关于模型<span data-katex="(M, \sigma )"></span>可满足，</p>

<p>简称公式集合<span data-katex="\Gamma"></span>可满足，</p>

<p>也称模型<span data-katex="(M, \sigma )"></span>满足公式集合<span data-katex="\Gamma"></span>，或<span data-katex="(M, \sigma )"></span>是<span data-katex="\Gamma"></span>的模型，记为<span data-katex="M\models _\sigma \Gamma"></span>。</p>

<p>如果<span data-katex="\Gamma"></span>是由语句组成的集合，那么记为<span data-katex="M\models \Gamma"></span>。</p>

<p><br/></p>

<h2><strong>永真性</strong></h2>

<p>称公式<span data-katex="A"></span>是<strong>永真的</strong>或有效的，如果<span data-katex="A"></span>对<span data-katex="\mathscr{L}"></span>的任意模型<span data-katex="(M, \sigma )"></span>均可满足，</p>

<p>即，对任意结构<span data-katex="M"></span>和赋值<span data-katex="\sigma"></span>，<span data-katex="M\models _\sigma A"></span>成立，记为<span data-katex="\models A"></span>。</p>

<p>称公式集合<span data-katex="\Gamma"></span>是永真的或有效的，如果<span data-katex="\Gamma"></span>中的每一个公式<span data-katex="A"></span>都是永真的，记为<span data-katex="\models \Gamma"></span></p>

<p>永真公式，也称为重言式，是与模型无关的公式，它们在任何模型下都为真。</p>

<p><br/></p>

<p><strong>例子：</strong>重言式</p>

<p><span data-katex="A\vee \neg A, \forall x(x\doteq x)"></span></p>

<p><br/></p>

<h2><strong>逻辑结论</strong></h2>

<p>设<span data-katex="A"></span>为公式，<span data-katex="\Gamma"></span>为公式集合，如果<span data-katex="M"></span>为任意结构，<span data-katex="\sigma"></span>为任意赋值，并且，</p>

<p>如果<span data-katex="M\models _\sigma \Gamma"></span>成立，则有<span data-katex="M\models _\sigma A"></span>成立，</p>

<p>那么称<span data-katex="A"></span>是<span data-katex="\Gamma"></span>的<strong>逻辑结论</strong>或语义结论，记为<span data-katex="\Gamma \models A"></span>，也称<span data-katex="\Gamma \models A"></span>有效。</p>

<p><br/></p>

<p><strong>注：</strong>符号<span data-katex="\models"></span>可以出现在4种不同类型的语义关系式中，它们是，</p>

<p><span data-katex="M\models _\sigma A, M\models A, \models A, \Gamma \models A"></span></p>

<p><span data-katex="\models"></span>在每种语义关系式中的含义不同，</p>

<p>区别这些关系式的简单办法是，</p>

<p>当<span data-katex="M"></span>和<span data-katex="\sigma"></span>同时出现时，表示此式仅对给定的<span data-katex="M"></span>和<span data-katex="\sigma"></span>成立，</p>

<p>当<span data-katex="\sigma"></span>不出现时，表示此式对任意<span data-katex="\sigma"></span>成立，</p>

<p>当<span data-katex="M"></span>及<span data-katex="\sigma"></span>均不出现时，表示此式对任意<span data-katex="M"></span>和任意<span data-katex="\sigma"></span>成立。</p>

<p><br/></p>

<p><span data-katex="\Gamma \models A"></span>也是一个语义关系式，它表示对任意<span data-katex="M"></span>和任意<span data-katex="\sigma"></span>，</p>

<p>如果<span data-katex="\Gamma"></span>为真，那么<span data-katex="A"></span>也为真。</p>

<p><br/></p>

<h2><strong>序贯</strong></h2>

<p>设<span data-katex="\Gamma ,\Delta"></span>为公式的有穷集合，<span data-katex="\Gamma \vdash \Delta"></span>称为<strong>序贯</strong>。</p>

<p><span data-katex="\Gamma"></span>称为序贯的前提，<span data-katex="\Delta"></span>称为序贯的结论。</p>

<p><br/></p>

<h2><strong>公理</strong></h2>

<p>设<span data-katex="\Gamma ,\Delta ,\Lambda ,\Theta"></span>为有穷公式集合，<span data-katex="A"></span>为公式，</p>

<p>则序贯<span data-katex="\Gamma ,A,\Delta \vdash \Lambda ,A,\Theta"></span>称为<strong>公理</strong>。</p>

<p><br/></p>

<p><strong>注：</strong>公理序贯之所以成立，是因为证明结论中至少有一个公式包含在公理序贯的前提之中。</p>

<p><br/></p>

<h2><strong>G推理系统</strong></h2>

<p>（1）<span data-katex="\neg"></span>规则</p>

<p><span data-katex="\neg -L:\frac{\Gamma ,\Delta \vdash A,\Lambda }{\Gamma ,\neg A,\Delta \vdash \Lambda}"></span></p>

<p><span data-katex="\neg -R:\frac{A,\Gamma \vdash \Lambda ,\Delta }{\Gamma \vdash \Lambda ,\neg A,\Delta }"></span></p>

<p>（2）<span data-katex="\vee"></span>规则</p>

<p><span data-katex="\vee -L:\frac{\Gamma ,A,\Delta \vdash \Lambda \quad \Gamma ,B,\Delta \vdash \Lambda }{\Gamma ,A\vee B,\Delta \vdash \Lambda }"></span></p>

<p><span data-katex="\vee -R:\frac{\Gamma \vdash \Lambda ,A,B,\Theta }{\Gamma \vdash \Lambda ,A\vee B,\Theta }"></span></p>

<p>（3）<span data-katex="\wedge"></span>规则</p>

<p><span data-katex="\wedge -L:\frac{\Gamma ,A,B,\Delta \vdash \Lambda }{\Gamma ,A\wedge B,\Delta \vdash \Lambda }"></span></p>

<p><span data-katex="\wedge -R:\frac{\Gamma \vdash \Lambda ,A,\Theta \quad \Gamma \vdash \Lambda ,B,\Theta }{\Gamma \vdash \Lambda ,A\wedge B,\Theta }"></span></p>

<p>（4）<span data-katex="\rightarrow"></span>规则</p>

<p><span data-katex="\rightarrow -L:\frac{\Gamma ,\Delta \vdash A,\Lambda \quad B,\Gamma ,\Delta \vdash \Lambda }{\Gamma ,A\rightarrow B,\Delta \vdash \Lambda }"></span></p>

<p><span data-katex="\rightarrow -R:\frac{A,\Gamma \vdash B,\Lambda ,\Theta }{\Gamma \vdash \Lambda ,A\rightarrow B,\Theta }"></span></p>

<p>（5）<span data-katex="\forall"></span>规则</p>

<p><span data-katex="\forall -L:\frac{\Gamma ,A[t/x],\forall xA(x),\Delta \vdash \Lambda }{\Gamma ,\forall xA(x),\Delta \vdash \Lambda }"></span></p>

<p><span data-katex="\forall -R:\frac{\Gamma \vdash \Lambda ,A[y/x],\Theta }{\Gamma \vdash \Lambda ,\forall xA(x),\Theta }"></span></p>

<p>（6）<span data-katex="\exists"></span>规则</p>

<p><span data-katex="\exists -L:\frac{\Gamma ,A[y/x],\Delta \vdash \Lambda }{\Gamma ,\exists xA(x),\Delta \vdash \Lambda }"></span></p>

<p><span data-katex="\exists -L:\frac{\Gamma ,A[y/x],\Delta \vdash \Lambda }{\Gamma ,\exists xA(x),\Delta \vdash \Lambda }"></span></p>

<p><br/></p>

<h2><strong>可靠性，紧致性，协调性，完全性</strong></h2>

<p><strong>可靠性</strong></p>

<p>如果序贯<span data-katex="\Gamma \vdash \Lambda"></span>可证，那么<span data-katex="\Gamma \models \Lambda"></span>成立。</p>

<p><br/></p>

<p><strong>紧致性</strong></p>

<p>如果<span data-katex="\Gamma"></span>是一个公式集合，<span data-katex="A"></span>是一个公式，并且序贯<span data-katex="\Gamma \vdash A"></span>可证，</p>

<p>那么必然存在有穷公式集合<span data-katex="\Delta"></span>，使得<span data-katex="\Delta \subseteq \Gamma"></span>并且<span data-katex="\Delta \vdash A"></span>可证。</p>

<p><br/></p>

<p><strong>协调性</strong></p>

<p>设<span data-katex="\Gamma"></span>为公式集合，如果不存在一个公式<span data-katex="A"></span>使得序贯<span data-katex="\Gamma \vdash A"></span>与<span data-katex="\Gamma \vdash \neg A"></span>均可证，</p>

<p>那么称<span data-katex="\Gamma"></span>是协调的。</p>

<p><br/></p>

<p><strong>完全性</strong></p>

<p>令<span data-katex="\Gamma"></span>为一个公式集合，<span data-katex="A"></span>为一个公式，</p>

<p>如果<span data-katex="\Gamma \models A"></span>成立，那么<span data-katex="\Gamma \vdash A"></span>可证。</p>

<p><br/></p>

<p><strong>定理：</strong>令<span data-katex="\Gamma"></span>为一个公式集合，<span data-katex="A"></span>为一个公式，</p>

<p>（1）<span data-katex="\Gamma \models A"></span>有效，当且仅当<span data-katex="\Gamma \vdash A"></span></p>

<p>（2）<span data-katex="\Gamma"></span>可满足，当且仅当<span data-katex="\Gamma"></span>协调</p>

<p><br/></p>

<h2><strong>形式理论</strong></h2>

<p>设<span data-katex="\Gamma"></span>是一阶语言<span data-katex="\mathscr{L}"></span>的有穷或可数无穷的语句集合，</p>

<p>如果<span data-katex="\Gamma"></span>协调，则称<span data-katex="\Gamma"></span>是一阶语言的形式理论，简称<strong>形式理论</strong>。</p>

<p>而称<span data-katex="\Gamma"></span>中的语句为<span data-katex="\Gamma"></span>的<strong>公理</strong>。</p>

<p><br/></p>

<p>如果<span data-katex="\Gamma"></span>是一个形式理论，</p>

<p>那么称语句集合，<span data-katex="Th(\Gamma )=\{A|A"></span>是<span data-katex="\mathscr{L}"></span>的语句，并且<span data-katex="\Gamma \vdash A"></span>可证<span data-katex="\}"></span>，</p>

<p>为<span data-katex="\Gamma"></span>的<strong>理论闭包</strong>。</p>

<p><br/></p>

<p>如果<span data-katex="\Gamma =\emptyset"></span>，那么，<span data-katex="Th(\emptyset )=\{A|A"></span>是<span data-katex="\mathscr{L}"></span>的语句，并且<span data-katex="\vdash A"></span>可证<span data-katex="\}"></span>，</p>

<p>是由全体重言式组成的集合。</p>

<p><br/></p>

<p>如果<span data-katex="M"></span>是<span data-katex="\mathscr{L}"></span>的模型，并且<span data-katex="M\models \Gamma"></span>，那么称<span data-katex="M"></span>是<span data-katex="\Gamma"></span>的模型。</p>

<p><br/></p>

<h2><strong>关于模型的形式理论</strong></h2>

<p>如果<span data-katex="M"></span>是一阶语言<span data-katex="\mathscr{L}"></span>的模型，那么称语句集合，</p>

<p><span data-katex="Th(M)=\{A|A"></span>是<span data-katex="\mathscr{L}"></span>的语句，并且<span data-katex="M\models A\}"></span></p>

<p>为<span data-katex="\mathscr{L}"></span>关于模型<span data-katex="M"></span>的形式理论。</p>

<p><br/></p>

<h2><strong>形式理论的完全性</strong></h2>

<p>称形式理论<span data-katex="\Gamma"></span>是完全的，如果对任意语句<span data-katex="A"></span>，</p>

<p><span data-katex="\Gamma \vdash A"></span>及<span data-katex="\Gamma \vdash \neg A"></span>中必有一个可证。</p>

<p><br/></p>

<h2><strong>函数的可表示性</strong></h2>

<p>设<span data-katex="f:\mathbb{N}^k\rightarrow \mathbb{N}"></span>是<span data-katex="\mathbb{N}"></span>上的<span data-katex="k"></span>元函数，</p>

<p>如果存在<span data-katex="\mathscr{A}"></span>公式<span data-katex="A(x_1,...,x_{k+1})"></span>，使得对任意自然数<span data-katex="n_1,...,n_{k+1}"></span>，</p>

<p>如果<span data-katex="f(n_1,...,n_k)=n_{k+1}"></span>，那么<span data-katex="\Pi \vdash A[S^{n_1}0,...,S^{n_{k+1}}0]"></span>可证</p>

<p>如果<span data-katex="f(n_1,...,n_k)\neq n_{k+1}"></span>，那么<span data-katex="\Pi \vdash \neg A[S^{n_1}0,...,S^{n_{k+1}}0]"></span>可证</p>

<p>在这种情况下，称函数<span data-katex="f"></span>在<span data-katex="\Pi"></span>中<strong>可表示</strong>，</p>

<p>并称公式<span data-katex="A(x_1,...,x_k,x_{k+1})"></span>是函数<span data-katex="f"></span>在<span data-katex="\Pi"></span>中的<strong>表示</strong>。</p>

<p><br/></p>

<p><strong>定理：</strong>如果<span data-katex="f:\mathbb{N}^k\rightarrow \mathbb{N}"></span>是<span data-katex="\mathbb{N}"></span>上的<span data-katex="k"></span>元可计算函数，</p>

<p>那么函数<span data-katex="f"></span>在<span data-katex="\Pi"></span>中可表示。</p>

<p><br/></p>

<h2><strong>关系的可表示性</strong></h2>

<p>设<span data-katex="r"></span>是<span data-katex="\mathbb{N}"></span>上的<span data-katex="k"></span>元关系，</p>

<p>如果存在<span data-katex="\mathscr{A}"></span>公式<span data-katex="A(x_1,...,x_{k+1})"></span>，使得对任意自然数<span data-katex="n_1,...,n_{k+1}"></span>，有</p>

<p>如果<span data-katex="r(n_1,...,n_k)=n_{k+1}"></span>，那么<span data-katex="\Pi \vdash A[S^{n_1}0,...,S^{n_{k+1}}0]"></span>可证</p>

<p>如果<span data-katex="r(n_1,...,n_k)\neq n_{k+1}"></span>，那么<span data-katex="\Pi \vdash \neg A[S^{n_1}0,...,S^{n_{k+1}}0]"></span>可证</p>

<p>在这种情况下，称关系<span data-katex="r"></span>在<span data-katex="\Pi"></span>中<strong>可表示</strong>，</p>

<p>并称公式<span data-katex="A(x_1,...,x_k,x_{k+1})"></span>在<span data-katex="\Pi"></span>中表示关系<span data-katex="r"></span>。</p>

<p><br/></p>

<p><strong>定理：</strong>如果<span data-katex="r:\mathbb{N}^k\rightarrow \mathbb{N}"></span>是<span data-katex="\mathbb{N}"></span>上的<span data-katex="k"></span>元可判定关系，</p>

<p>那么<span data-katex="r"></span>在<span data-katex="\Pi"></span>中可表示。</p>

<p><br/></p>

<h2><strong>哥德尔定理</strong></h2>

<p><strong>哥德尔不完全性定理</strong></p>

<p>如果<span data-katex="\Gamma"></span>是一个有穷并包含初等算术<span data-katex="\Pi"></span>的形式理论，</p>

<p>那么<span data-katex="\Gamma"></span>是一个不完全的形式理论。</p>

<p><br/></p>

<p><strong>哥德尔协调性定理</strong></p>

<p>如果形式理论<span data-katex="\Gamma"></span>包含初等算术<span data-katex="\Pi"></span>，</p>

<p>那么<span data-katex="\Pi"></span>的协调性不能在<span data-katex="\Gamma"></span>中被证明。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>以上，只是对谓词逻辑中用到的部分公式，进行了整理，</p>

<p>对建立<strong>用证明论和模型论的观点来理解公理系统</strong>，是很有帮助的。</p>

<p>然而，从更高的角度来看，有些观点很有可能就是<strong>错误</strong>的，</p>

<p>因此，此篇只是一个开始，督促我朝着更广阔的方向努力学习。</p>

<p><br/></p>

<p><strong>参考</strong></p>

<p><a href="http://book.douban.com/subject/2364517/">数理逻辑</a></p>

<p><a href="http://www.logicmatters.net/tyl/">Teach Yourself Logic 2015</a></p>

<p><a href="http://book.douban.com/subject/2878521/">logic and structure</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[论证与直觉]]></title>
    <link href="https://thzt.github.io/blog/2015/11/08/demonstration-and-intuition/"/>
    <updated>2015-11-08T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/11/08/demonstration-and-intuition</id>
    <content type="html"><![CDATA[<p>无论是工业还是科学，</p>

<p>很多领域中，</p>

<p>都需要积极的思考才能推动进步。</p>

<p><br/></p>

<p>在没有扎实的知识储备时，</p>

<p>在没有明确目标导向的情况下，</p>

<p>人们容易产生不切实际的<strong>幻想</strong>。</p>

<p><br/></p>

<p>所谓的民科，</p>

<p>是因为他们的想法，</p>

<p><strong>并没有解决更多的实际问题</strong>。</p>

<p><br/></p>

<p>观点在没有被论证之前，</p>

<p>是难以服众的，</p>

<p>至少不被已有的知识体系所接纳。</p>

<p><br/></p>

<p>因此，<strong>锻炼自己论证的能力</strong>，</p>

<p>是检验想法可靠途径。</p>

<p><br/></p>

<p><strong>然而，直觉也是必不可少的</strong>，</p>

<p>它可以预先设定一个目标，</p>

<p>指导我们去检验。</p>

<p><br/></p>

<h2><strong>实现它</strong></h2>

<p>检验构想的唯一途径，</p>

<p>就是<strong>用实现来证明它</strong>。</p>

<p><br/></p>

<p>尤其是在软件设计中，</p>

<p>在切实实现之前，</p>

<p>我们并不知道某个设计构思是否可行。</p>

<p><br/></p>

<p>总是心中先有了一个蓝图，</p>

<p>然后<strong>在实验室环境中对它进行检验</strong>，</p>

<p>可行的话，就移植到生产环境中。</p>

<p><br/></p>

<p>这就要求我们<strong>具有实现想法的能力</strong>，</p>

<p>锻炼自己的编程水平，</p>

<p>用最有效的方式检验设想。</p>

<p><br/></p>

<p>好的想法从哪里来的呢？</p>

<p><strong>过滤掉不可行的方案，</strong></p>

<p><strong>剩下的才可行。</strong></p>

<p><br/></p>

<p>我们只看到别人提出了一个方案，</p>

<p>却没有看到它已经用实验过滤掉了不行的那些设想。</p>

<p><br/></p>

<h2><strong>想象它</strong></h2>

<p>有了实现能力之后，</p>

<p>还需要<strong>锻炼想象力</strong>。</p>

<p><br/></p>

<p>如果存在的话，应该是怎样的？</p>

<p>假设已经存在了，结果会怎样？</p>

<p>人们期待它是什么样的呢？</p>

<p>如果存在，我们如何验证它呢？</p>

<p><br/></p>

<p><strong>有了想象力，</strong></p>

<p><strong>实现就有了方向。</strong></p>

<p><br/></p>

<p>测试驱动开发，</p>

<p>先思考检验的方式，再考虑实现。</p>

<p><br/></p>

<p>自顶向下开发，</p>

<p>先考虑外在表现，再考虑内部细节。</p>

<p><br/></p>

<p>设计接口，</p>

<p>先考虑别人怎么使用，再实现它。</p>

<p><br/></p>

<p>想象力也是需要锻炼的，</p>

<p>使我们可以<strong>预见事物的发展结果</strong>。</p>

<p><br/></p>

<h2><strong>学习它</strong></h2>

<p>曾经有人说过，</p>

<p>你永远没有自己的想法，</p>

<p>除非在写博士论文。</p>

<p><br/></p>

<p>确实如此。</p>

<p>在产生一个想法的同时，</p>

<p>还要<strong>学习别人的思路</strong>，</p>

<p>尤其是要<strong>关注别人在干什么</strong>。</p>

<p><br/></p>

<p>一方面，很多设想，</p>

<p>是已经被实现检验过的，</p>

<p>没必要走别人的老路。</p>

<p><br/></p>

<p>另一方面，很多设想，</p>

<p>虽然比人已经考虑过了，</p>

<p>但是思路值得学习，有利于我们类比到其他问题。</p>

<p><br/></p>

<p>因此，总是要保持<strong>学习和交流</strong>的态度，</p>

<p>而不是闭门造车。</p>

<p><br/></p>

<p>然而，<strong>又不能被别人的方案冲昏头脑</strong>，</p>

<p><strong>忘记自己知识体系的构建</strong>。</p>

<p><br/></p>

<h2><strong>接受它</strong></h2>

<p>一潭死水，指的是，</p>

<p>没有实现能力，没有想象力，</p>

<p>也没有学习能力。</p>

<p><br/></p>

<p>有的人，一开始就认为别人是错的，</p>

<p>他自己的知识体系已经封闭了，</p>

<p>他们说自己有<strong>怀疑精神</strong>。</p>

<p><br/></p>

<p><strong>而怀疑精神，指的是证否能力，前提要先接受。</strong></p>

<p>很多好的想法，别人没有时间给你证明，</p>

<p>先拒绝，会错过很多新奇的玩意。</p>

<p><br/></p>

<p>有怀疑精神是很难的，</p>

<p>难度在证明上，</p>

<p>而不是在接受上。</p>

<p><br/></p>

<p>只有我们保持开放，</p>

<p>思维才会活跃，</p>

<p>每天的日常就是努力获取更多的知识。</p>

<p><br/></p>

<p>别担心，当知识多了的时候，</p>

<p>鉴别能力也会随之提高，</p>

<p>不用小心翼翼的求稳，</p>

<p>广博的听取多家之言，才是最稳的。</p>

<p><br/></p>

<p><strong>不用担心自己理解错了，</strong></p>

<p><strong>反对者们会抢先告诉你的。</strong></p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>孟子曰，尽信书，不如无书，</p>

<p>坑了太多的人。</p>

<p><br/></p>

<p>人家说<strong>尽</strong>信，而不是信。</p>

<p>在盲目的时候，要提醒自己保持怀疑，</p>

<p>在过度怀疑的时候，要提醒自己接受，</p>

<p>让想象力飞起来吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[先后之分]]></title>
    <link href="https://thzt.github.io/blog/2015/10/30/preparation/"/>
    <updated>2015-10-30T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/10/30/preparation</id>
    <content type="html"><![CDATA[<p>孙子曰：</p>

<p>昔之善战者，<strong>先为不可胜</strong>，以待敌之可胜。</p>

<p><br/></p>

<p>善于指挥作战的人，</p>

<p>总是先创造条件使自己处于不可战胜的地位，</p>

<p>然后等待敌人能被我战胜的时机。</p>

<p><br/></p>

<p>孙子曰：</p>

<p>胜兵<strong>先胜而后求战</strong>，败兵先战而后求胜。</p>

<p><br/></p>

<p>胜利之师是先具备必胜的条件然后再去交战，</p>

<p>失败之师总是先同敌人交战，</p>

<p>然后期求从苦战中侥幸取胜。</p>

<p><br/></p>

<p>诚然，</p>

<p>现代的生活，没有了表面上的战争，</p>

<p>但是隐性的战争却无处不在。</p>

<p><br/></p>

<p>兵，泛指了可以利用资源，</p>

<p>而兵法写了对资源的管理方式。</p>

<p>2500年前的兵家思想，</p>

<p>对现代仍然有战略指导意义。</p>

<p><br/></p>

<h2><strong>先做准备</strong></h2>

<p>毛泽东是一个熟读兵法的领袖人物，</p>

<p>在《目前形势和我们的任务》中提到：</p>

<p><strong>不打无准备之仗</strong>，不打无把握之仗，</p>

<p>每战都应力求有准备，力求在敌我条件对比下有胜利的把握。</p>

<p><br/></p>

<p>日常生活中，我们应该<strong>利用闲余时间做好准备</strong>，</p>

<p>等到机会来临时，才有能力把握住。</p>

<p><br/></p>

<p>运气，只是成功者的谦辞。</p>

<p><br/></p>

<p>听过一个故事，说自己因为2分之差没有入选。</p>

<p>于是就抱怨，说别人只不过比自己多2分而已。</p>

<p><br/></p>

<p>后来父亲教导说，</p>

<p>人啊就是要拼了命努力，</p>

<p>你看着他比你多了2分你不服气，你怎么知道他比你多努力的只是2分啊，</p>

<p><strong>如果你需要靠75分才能入围，那你就要做85分的努力才能保证自己一定会入围</strong>，</p>

<p>侥幸的成功是不稳定的。</p>

<p><br/></p>

<p>事实就是如此，</p>

<p>很多输赢在准备阶段已经确定了，比赛只是走个过场，</p>

<p>没有压倒性的优势，就会陷于焦灼战，</p>

<p>对本身损害极大，又<strong>丧失了进一步做准备的时间</strong>。</p>

<p><br/></p>

<p>孙子兵法在谋攻中指出：</p>

<p>最好的策略是以<strong>谋略</strong>胜敌，其次是<strong>外交</strong>手段，再次是通过<strong>交战</strong>，最下等的是<strong>攻城</strong>。</p>

<p>而善于用兵的人，使敌军屈服而不用交战，夺取敌城而不用攻城，消灭敌国而不用兵。</p>

<p>一定要本着不诉诸兵刃就使敌完整屈服的原则，争横天下。</p>

<p><br/></p>

<h2><strong>任何能力都需要时间的积累</strong></h2>

<p>当想明白了输赢靠准备，不靠交战这一层之后，</p>

<p>我们就要努力<strong>积累</strong>能力了。</p>

<p><br/></p>

<p>我们生存的这个世界，不是瞬变的过程，</p>

<p>任何改变都需要足够多的时间。</p>

<p><br/></p>

<p>学生时代，即使学过了牛顿的惯性定律，</p>

<p>也没有太在意，天真的认为，社会的发展，首先是设计成某个样子，</p>

<p>然后大家再努力建设成那个样子。</p>

<p><br/></p>

<p>而事实上，<strong>怎样从现状做出改变，才是关键</strong>。</p>

<p><strong>一个系统不可能直接废掉，变成其他的系统。</strong></p>

<p>我们得用发展的眼光看待问题，</p>

<p>因势利导，局部调整。</p>

<p><br/></p>

<p>个人的职业发展，也是如此，</p>

<p>一个人不是因为自己成为了领袖，才学会领导才能。</p>

<p>而是<strong>先对领导力进行了主动积累，才有希望成为领袖</strong>。</p>

<p><br/></p>

<p>人的成长，并非仅是知识的获取，</p>

<p>还包括了心智的成熟与人生经验的积累，</p>

<p>而这些都需要足够的时间。</p>

<p><br/></p>

<h2><strong>攻守之战</strong></h2>

<p>我原以为躁进的心态是这些年才有的，</p>

<p>其实不然。</p>

<p><br/></p>

<p>从古至今，都不缺少急功近利的人。</p>

<p>汉代董仲舒对胶西王说过：</p>

<p>仁人者正其道不谋其利，修其理不急其功。</p>

<p>这才是真正的强国之路。</p>

<p><br/></p>

<p>而在追逐利益的同时，必定暴露弱点，</p>

<p>让其他人有机可乘。</p>

<p>相反，<strong>国家昌盛了，有道之士自然会来投奔。</strong></p>

<p><br/></p>

<p>从夯实基础为立足点，稳中求进，</p>

<p>一旦拿下就是压倒性的优势，</p>

<p>别人无法反抗。</p>

<p><br/></p>

<p>孙子兵法中提到：</p>

<p>打仗的原则是，不要寄希望于敌人不来，而要依靠自己有充分准备，严阵以待；</p>

<p>不要寄希望于敌人不会进攻，而要依靠自己有敌人不可攻破的条件。</p>

<p><br/></p>

<p>对啊，就算早别人一步，未必能守住。</p>

<p><strong>能掌握先机，未必不被后来者居上。</strong></p>

<p><br/></p>

<p>躁进的同时，还是先假想一下成功后的结果吧。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>事件的发生顺序，是有先后之分的，</p>

<p>不能因为事件紧迫，就选择冒进的办法。</p>

<p><br/></p>

<p>做好准备，好好积累，</p>

<p>才会有能力应对突发情况。</p>

<p><br/></p>

<p>突发情况处理的不好，并不是应变能力的问题，</p>

<p>而是风险管理的问题。</p>

<p>我们不应该想，时间这么紧，怎么办呢？</p>

<p>而应该想，<strong>为什么任务这么紧急，我们却还剩下这么少的时间？</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[愉快的三天]]></title>
    <link href="https://thzt.github.io/blog/2015/10/15/web-front-end-bug/"/>
    <updated>2015-10-15T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/10/15/web-front-end-bug</id>
    <content type="html"><![CDATA[<p><strong>场景：</strong></p>

<p>两级弹框，第一级是bootstrap的modal，里面有一个jqgrid，第二级是jqgrid添加记录的弹框</p>

<p>第二级弹框中的textarea在IE9中不能换行，而在chrome中可以</p>

<p><br/></p>

<h2><strong>Day 1</strong></h2>

<p>bootstrap的modal和jqgrid全部在实验室环境中搭建起来，比较麻烦，先考虑别的办法</p>

<p>因为IE9调试工具太弱了，看看firefox有没有同样的问题</p>

<p>发现firefox中的问题是textarea不能聚焦</p>

<p>以前遇到过不能获得焦点的问题，跟tabindex有关，把tabindex删掉，没作用</p>

<p>发现一级弹框中加了元素级别的textarea样式，删掉，没作用</p>

<p>因为这个框是jqgrid弹出来的，查看jqgrid源码，有没有劫持回车事件，没有</p>

<p>firefox中逐个删除页面元素，发现可以让textarea获得焦点，可能是元素的问题</p>

<p>把一级对话框内中的jqgrid删掉，再用控制台命令添加纯html二级弹框，还是有问题，说明不是jqgrid的问题</p>

<p>考虑到删除元素会改变子元素的样式，可能是样式问题</p>

<p>firefox中删除所有样式，发现可以获得焦点了，是样式问题</p>

<p>逐步缩小范围，发现是一级弹框有一个行内样式所致，删掉后，可以获得焦点了</p>

<p>但是在IE9中仍然不可换行</p>

<p><strong>解决了firefox不能聚焦的问题</strong></p>

<p><br/></p>

<h2><strong>Day 2</strong></h2>

<p>现在Chrome和Firefox都没问题了，只好硬着头皮用IE9调试了，鉴于昨天的结论，先从样式角度考虑</p>

<p>发现一级弹框去掉所有样式，就可以换行了</p>

<p>但是聚焦不到特定的某一条样式上，怀疑是脏乱的样式加成结果导致CSS解析器出错了</p>

<p>发现在错误的样式下，只要隐藏对话框也是可换行的，可能是浏览器计算位置时出错了</p>

<p>因为bootstrap样式层叠的太多了，既然不知道哪个样式是错的，那就用正确的样式手写生成原来的样子，也是个办法</p>

<p>生成过程中发现其他样式都去掉，display:block;position:fixed;z-index:1030;就能复现问题，可能是浏览器计算z-index错了</p>

<p>用IE9调试工具修改页面源码，就没问题了。因为页面重绘，重新计算了位置，也可能是事件都删掉了</p>

<p>页面太乱了，清理一下，把页面杂乱的标签都删掉，尤其是script片段，没作用</p>

<p>把link标签都删掉，没问题了。应该是某个样式表的问题，定位到是bootstrap.css或ui.jqgrid.css的问题，这两个删一个问题就复现</p>

<p>把一级弹框的所有父元素保留，删除页面中所有其他的html，问题还存在。但是IE9调试工具中点Refresh就没问题了，IE9调试工具不可靠</p>

<p>不能过度依赖调试工具了，得想办法把本地服务器端运行起来，不然剩下的办法只能是实验室环境中把网页重新静态构建起来了</p>

<p><strong>找到一个可行的解决方案，弹出第二级对话框时，把第一级隐藏掉</strong></p>

<p><br/></p>

<h2><strong>Day 3</strong></h2>

<p>搭建本机环境，把服务器端运行起来</p>

<p>删掉一级弹框中的所有代码，控制台命令弹出二级纯html弹框，没作用</p>

<p>先用控制台命令弹出二级纯html弹框，再在页面点击弹出一级弹框，没作用</p>

<p>控制台命令弹出二级纯html弹框，再控制台命令弹出一级纯html弹框，好了，应该是一级弹框弹出的过程中做了什么</p>

<p>发现是bootstrap的modal(&lsquo;show&rsquo;)这条语句弹出的框有问题</p>

<p>因为IE9不容易跟源码，所以先不看源码，在实验室环境中，造一个一模一样modal，然后二级弹框果然出问题了，并且firefox和chrome都无法获得焦点</p>

<p>实验室环境中复现了问题，问题快解决了</p>

<p>找到bootstrap的modal插件的官方例子，弹出二级弹框，没问题</p>

<p>对比有问题的代码，发现只要modal-body中包含&lt;button&gt;就能复现问题，定位为bootstrap的问题</p>

<p>考虑解决方案，把服务器中的所有button都换成div，还是有问题，而实验室没问题，说明IE9不太稳定</p>

<p>控制台删掉所有的button，结果好了</p>

<p>看看是哪个button影响的，发现总是最后一个button影响的</p>

<p>用补丁方式，先造一个隐藏的button，然后载入时模拟控制台删掉它，没作用。但是控制台删掉它，就有作用，不稳定</p>

<p>不看modal的源码不行了</p>

<p>为了能调试进源码中，换Chrome跟进bootstrap源码，再到IE9看效果</p>

<p>先把modal函数中代码全删了，果然问题没了，然后逐个功能还原，寻找复现问题的临界点</p>

<p>发现enforceFocus这样的方法，是为了强制让对话框获得焦点，感觉就是这个了</p>

<p>把这个方法注掉，没作用，看看实现，就是先解绑一个自定义聚焦事件再绑定这个自定义聚焦事件</p>

<p>在事件中写log，果然点击textarea，就触发这个自定义事件</p>

<p>把事件中把强制获得焦点的代码删掉，好了，这应该就是问题所在了</p>

<p>考虑解决方案，enforceFocus只是进行解绑和绑定事件，而事件是点击textarea时触发的，那就让它只解绑不绑定</p>

<p>分析源码，enforceFocus引用是Modal.prototype中的方法，而Modal是$.fn.modal.constructor，因此是在源码外改的</p>

<p>尽量不动源码，在源码之外加补丁</p>

<p>chrome和firefox在实验室环境中，textarea是不能获得焦点的，但是网站中可以，原因未知</p>

<p><strong>通过覆盖自动聚焦事件，解决了问题</strong></p>

<p><br/></p>

<h2><strong>困难</strong></h2>

<p>IE9的调试工具太差，Chrome调试工具虽好，但是Chrome没有问题</p>

<p>bootstrap大量的样式名污染的全局空间，每一个元素有大量冗余的层叠样式</p>

<p>很多事件可能是跟样式名相关联的，删了样式名会影响事件</p>

<p>前两天本机环境没有搭建好，只能通过浏览器调试</p>

<p>第三方库用了什么黑魔法，不知道</p>

<p>页面太杂乱，script片段遍布各处，到处是动态加载但不清理的内容</p>

<p>setTimeout乱用，至少二十处setTimeout，js执行过程紊乱</p>

<p>两层弹框，第一级弹框中还能进行内容tab切换，影响因素比较多</p>

<p>项目代码的问题写的太差，互相依赖，很难对功能进行隔离，不能以功能模块为单位进行测试</p>

<p>二级弹框并不是一级弹框的子元素，而是body的子元素，与一级弹框的位置相距很远，从直觉上很难发现有关联</p>

<p><br/></p>

<h2><strong>优势</strong></h2>

<p>电脑配置不错，两个显示器，16G内存装了虚拟机可以模拟IE8-11,Edge</p>

<p>没有时间压力，没人催我，没有别的项目或会议打断我</p>

<p>服务器端同事配合，没有怀疑我的能力</p>

<p>bootstrap和jqgrid源码不是太烂</p>

<p>这不是一个偶现的bug，没次都能出现，难度降低了不少</p>

<p><br/></p>

<h2><strong>误区</strong></h2>

<p>其实IE的问题并不是那么多，更多的是可见代码的问题</p>

<p>黑盒试错，不如静下心来跟进源码看看原理</p>

<p>不能过度依赖调试工具的结论</p>

<p>可以通过改动来试错的代码越多，排除假设的机会就越大</p>
]]></content>
  </entry>
  
</feed>
