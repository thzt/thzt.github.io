<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[何幻]]></title>
  <link href="https://thzt.github.io/atom.xml" rel="self"/>
  <link href="https://thzt.github.io/"/>
  <updated>2016-09-13T09:16:55+08:00</updated>
  <id>https://thzt.github.io/</id>
  <author>
    <name><![CDATA[thzt]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[决策的秘密]]></title>
    <link href="https://thzt.github.io/blog/2016/09/12/the-secrets-of-decision-making/"/>
    <updated>2016-09-12T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/09/12/the-secrets-of-decision-making</id>
    <content type="html"><![CDATA[<p>当我们无法选择的时候，原因并不在我们自身，</p>

<p>在于客观上还不具备能够进行选择的条件。</p>

<p><br/></p>

<p>可悲的是，人们习惯性的把这种状况理解为内心的纠结，</p>

<p>反而忽视了决策形成条件的推动和促成。</p>

<p><br/></p>

<h2><strong>未来是朦胧的</strong></h2>

<p>我们所做的事情，虽然业界有很多方案可选，</p>

<p>但是我们实际上并不知道最终方案长什么样。</p>

<p><br/></p>

<p>我们自己也不知道最终能否实现，只能通过感觉，</p>

<p>我们更无法确定什么才是『最终方案』，连问题都在变化。</p>

<p><br/></p>

<p>因此，到底应该如何选型呢？</p>

<p>经验就一定是正确的吗？</p>

<p>选择的利弊应该通过什么来衡量呢？</p>

<p><br/></p>

<h2><strong>现状是没有用的</strong></h2>

<p>软件领域中，</p>

<p>仅仅根据现状找到解决方案是不可行的，</p>

<p>因为世界不会等我们的方案实现之后再去变化。</p>

<p><br/></p>

<p>等代码写完，一切都变了，</p>

<p>到时候我们又要怪罪需求变更了。</p>

<p><br/></p>

<p>那么，软件应该怎样设计呢？</p>

<p>那些看起来优雅的设计，真的能发挥作用吗？</p>

<p>不好的设计，在长远看来真的就不合理吗？</p>

<p><br/></p>

<h2><strong>带着假设向前</strong></h2>

<p>其实，最难的事情就是直面自己的无能为力，</p>

<p>如果无法做出决策，那就先承认它。</p>

<p>只有承认了，在此基础上才能找到新的思路。</p>

<p><br/></p>

<p>而那些好的决策，并不是当场做出来的，</p>

<p>而是向前走得足够远，再绕回来修正的。</p>

<p>一个总是能有正确判断的人，并不是因为头脑灵活，</p>

<p>而是因为努力掌握更多的信息，拥有全局观点。</p>

<p><br/></p>

<p>因此，如果现在无法决定，就说明无论如何决定都是不可衡量的，</p>

<p>这个时候，就需要大胆尝试，延迟决定，</p>

<p>不要苦苦思索，而是努力到让选择可以被衡量的时候出现。</p>

<p><br/></p>

<p>努力就是为了验证我们的选择。</p>

<p><br/></p>

<h2><strong>从现状看趋势</strong></h2>

<p>世界无时无刻不在变化，现状只是这种变化的某个快照，</p>

<p>因此，拥有动态发展的观点，能通过历史和现状看到趋势，才是重要的，</p>

<p>只有沿着趋势生长，软件才能活下来。</p>

<p><br/></p>

<p>不好的设计，违背发展趋势，与问题渐行渐远，</p>

<p>优雅的设计，和问题共生共荣。</p>

<p><br/></p>

<p>要看清趋势，并不是一件容易的事情，</p>

<p>这需要要理清所有相关责任人的想法，</p>

<p>因为，软件是人来做的，也是要用来解决人的问题的。</p>

<p><br/></p>

<p>沟通能力，并不是指把一件事情说清楚的能力，</p>

<p>而是主动了解信息，挖掘可能性，让事情向前发展，</p>

<p>打破僵局，促成一件事情的能力。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>当出现选择困难的时候，勉强进行选择，才是危险的，</p>

<p>此时此刻，我们应该去尝试，并证明某个选择不可行。</p>

<p><br/></p>

<p>如果永远无法证明呢？</p>

<p>那就相信命运。</p>

<p><br/></p>

<p>有些事情不是人力所能及，</p>

<p>每个人都有完成工作的方式，</p>

<p>很难说哪种方式更好。</p>

<p><br/></p>

<p>最难的事情就是直面自己的无能为力。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[为什么作者无法不持有偏见]]></title>
    <link href="https://thzt.github.io/blog/2016/09/07/the-bias-of-the-author/"/>
    <updated>2016-09-07T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/09/07/the-bias-of-the-author</id>
    <content type="html"><![CDATA[<p>正如本文一样，</p>

<p>当作者要表述某个论点的时候，</p>

<p>我们总是能感觉到强烈的偏见既视感。</p>

<p><br/></p>

<p>那些作者列举的论据，似乎全都是刻意所为，</p>

<p>而那些不合情理的疑点，全都没有被提及，</p>

<p>一定是作者想让我们相信他的偏见，故意这么做的。</p>

<p><br/></p>

<p>大多数阅读者，很容易有这种感觉，</p>

<p>并自作聪明的产生了一个误区，让他们不敢随意相信别人。</p>

<p>他们可能曾经有过多次被人带偏，所以认识到了有主见的重要性。</p>

<p><br/></p>

<h2><strong>偏见的根源</strong></h2>

<p>然而，这同样也限制了他们接受新事物的速度，</p>

<p>让他们不再轻易相信别人，对别人的论点论据，容易怀有抗拒之心。</p>

<p><br/></p>

<p>也有一些“过来人”，会指出作者不恰当的说辞，</p>

<p>出于好心的，忠告那些“年轻人”，</p>

<p>指出作者的某些说法是不妥当的，是不公正的，包含大量的主观判断在里面。</p>

<p><br/></p>

<p>我承认以上的情况，确实全都发生过，且经常发生。</p>

<p>可是，站在作者的角度来看，如果意在指出大部分读者的盲区，</p>

<p>那么在行文时，就必须有所侧重，语气上难免有带偏之嫌。</p>

<p><br/></p>

<p>就像一个本来歪斜的树木，要想矫正，就必须先矫枉过正，</p>

<p>一个只能通过以毒攻毒解救的病人，就必须先使用毒药去“祸害”他，</p>

<p>对付一个已经持有偏见的人，只能带他去另外一个极端体会一下。</p>

<p><br/></p>

<h2><strong>真理的形态</strong></h2>

<p>分析原因，我们之所以保持怀疑，</p>

<p>是因为我们不想被某个人一时的判断所左右，我们想获得真理。</p>

<p>不过，真理并不是以这个形态出现的。</p>

<p><br/></p>

<p>能区分事实和判断，这种思路固然重要，</p>

<p>然而，发现真理总是以条件形式出现的，这个更加重要。</p>

<p><br/></p>

<p>相信条件为真时的断言，并且对条件始终保持怀疑，这才是应有的态度。</p>

<p>如果我们有能力承认任何假设，就可以走的更远，思路更广。</p>

<p><br/></p>

<p>睿智者总是能做到先相信，走出一段路之后，再反过来怀疑，</p>

<p>他们在各种条件上下文中，来回穿梭，进退。</p>

<p><br/></p>

<h2><strong>没有答案的问题</strong></h2>

<p>假如，公司突然派你出差，你会带什么？</p>

<p>不少人是想法是，电脑，面包，水&hellip;</p>

<p><br/></p>

<p>好的回答者，会这样做出答复：</p>

<p>我并不知道去哪里出差，为期多久，</p>

<p>如果比较近的话，时间又比较短，我会带&hellip;</p>

<p>如果比较远，时间长，我会带&hellip;</p>

<p><br/></p>

<p>具备这种思维模式的人，任何时候都不会陷入恐慌。</p>

<p>现实生活中很多类似的问题找不到答案，同样是因为场景不明，</p>

<p>有办法踏出一步的人，才能推进事物的发展。</p>

<p><br/></p>

<h2><strong>什么是理解</strong></h2>

<p>任何一本书的作者，要想表达某个观点，就不得不有所偏见，</p>

<p>然后相信读者的理解能力和自我保护意识，</p>

<p>而好的读者也能迅速抓住作者的写作意图。</p>

<p><br/></p>

<p>有人说，我怎么知道我理解的就是作者要表达的呢？</p>

<p>我的观点是，无所谓了，只要有所得就行。</p>

<p>虽然作者有其写作目的，但是读者也有其阅读目的，</p>

<p>这两个目的，不一定是匹配的。</p>

<p><br/></p>

<p>好的文学作品，不同的人阅读起来，可以有不同的收获。</p>

<p>同一道饭菜，不同的人品味起来，可以有不同的口感。</p>

<p>我们也善于发现言外之意。</p>

<p><br/></p>

<p>理解不如收获。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>作者是没办法不持有偏见的，为了行文方便。</p>

<p>但是读者也未必一定会受到偏见所累，只要能坚持自己的收获。</p>

<p>真理不在作者的描述上面，也不在描述是事实上面，而在于持有检验的精神。</p>

<p><br/></p>

<p>因此，让偏见来的更猛烈一些吧，</p>

<p>我只是想看看你要说什么。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[性格的弱点]]></title>
    <link href="https://thzt.github.io/blog/2016/09/03/weakness/"/>
    <updated>2016-09-03T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/09/03/weakness</id>
    <content type="html"><![CDATA[<p>人们常说，性格决定命运。</p>

<p>一直以来，我总觉得这是一句空话，一个『大』道理，</p>

<p>并没有什么真正的用处。</p>

<p><br/></p>

<p>但是随着生活阅历的不断丰富，</p>

<p>却越发察觉到限制自身发展的，正是性格本身。</p>

<p>大义凛然的形象，容易让人拍手称赞，</p>

<p>但是引人注目的传奇经历，也隐藏了性格的弱点。</p>

<p><br/></p>

<h2><strong>道德观</strong></h2>

<p>古龙小说小李飞刀的主角李寻欢，</p>

<p>为了向龙啸天报恩，居然将表妹让给他，断送了美好姻缘。</p>

<p>李寻欢有性格缺陷，他做不到有恩不报的事情，</p>

<p>这是他一直可以被人利用的原因。</p>

<p><br/></p>

<p>金庸小说射雕英雄传中，</p>

<p>郭靖曾三番四次搭救欧阳锋，原因只是坚持自己不能见死不救。</p>

<p>这种性格缺陷，导致了后面一系列的灾难，</p>

<p>洪七公和黄蓉差点死在欧阳锋手上，而江南七怪，几乎全军覆没。</p>

<p><br/></p>

<p>除此之外，</p>

<p>各种反派角色总是过的更轻松，因为他们没有道德观的束缚，</p>

<p>他们游刃有余，总能有机会兴风作浪。</p>

<p>而以正派标榜自身的侠客，总是束手束脚，悲剧连连。</p>

<p><br/></p>

<p>同样是没有证据，反派人物就可以声称自己是忍辱负重，</p>

<p>而指认主角是卖国求荣。</p>

<p>而主角的性格缺陷，让他们相信清者自清，错过了解释的机会。</p>

<p><br/></p>

<h2><strong>我不能</strong></h2>

<p>诚然，虐心的情节才能有更多的读者，</p>

<p>可是生活中的我们未必不会明知故犯。</p>

<p><br/></p>

<p>所以说，以上的例子虽然不是直接源于生活，但是有生活中的影子，</p>

<p>当我们对自己说『我可做不出这种事』的时候，是因为我们有性格缺陷，</p>

<p>对自己说『不能』的时候，实际上已经错过了大部分的『可能』。</p>

<p><br/></p>

<p>看到这里，肯定有人会说，即使这样，我也做不出有违良心的事情。</p>

<p>是的，性格反映了一个人的特征，</p>

<p>有什么样的性格，就决定了他是一个什么样的人。</p>

<p><br/></p>

<p>因此，改变性格是很难的，也是危险的，会导致一系列的连锁反应，</p>

<p>物以类聚人以群分，性格还会决定我们的身边会聚集什么样的人。</p>

<p>改变性格会扭转局势，改变命运。</p>

<p><br/></p>

<h2><strong>看到自己的私心</strong></h2>

<p>我写出这些，并不是希望做出改变，</p>

<p>而是想，当我们遭遇难题时，或者有过不去的门槛之时，</p>

<p>能提醒自己，这是性格缺陷在作怪，不要总是找客观原因。</p>

<p><br/></p>

<p>另一方面，在绝境中，不同的人也会做出不同的选择，</p>

<p>在金庸小说倚天屠龙记中，同样是迫于长辈的压力，</p>

<p>周芷若会立下毒誓，抢夺屠龙刀，陷害别人，</p>

<p>而赵敏却以死相逼，救得张无忌，替父顶罪。</p>

<p><br/></p>

<p>这也说明，那些总是找客观原因说自己境遇悲惨的人们，</p>

<p>并没有认识到选择才是鉴别一个人的标准，</p>

<p>当前的处境并不是做出糟糕决定的直接原因，私心才是。</p>

<p><br/></p>

<h2><strong>多样性</strong></h2>

<p>这个世界本来就是由形形色色的生命构成的，物种具有多样性，</p>

<p>人类社会也是如此，社会中有不同性格的人，</p>

<p>于是社会的发展才有了不同的可能。</p>

<p><br/></p>

<p>有过必改，和坚持己见，都是优秀的品质，</p>

<p>但是，我们却不可能同时具有这两种性格，只能做到其中一个。</p>

<p>优秀和低劣并没有明显的区别。</p>

<p><br/></p>

<p>哈佛大学的麦克.桑德尔在讲授《公正》这门课时，提出了这样一个问题：</p>

<p>假设你是一名电车司机正在驾驶着高速行驶的电车，</p>

<p>此时前方轨道上有五个工人，而一旁的另一条轨道上只有一个工人，</p>

<p>想要停下电车已经不可能，但只要拉动操纵杆就可以转入另一条轨道，</p>

<p>是转道，还是不转道？</p>

<p><br/></p>

<p>无论从结果还是行为本身来评判，都无法知晓哪个选择是更好的，</p>

<p>因此，纠结于是否道德，这个问题本身可能都是有问题的。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>中国有句古话，谋事在人成事在天，说的非常好，</p>

<p>人力所能及的事情毕竟是少数，我们只能做出尝试，然后等待，</p>

<p>却无法操纵一件事情的最终结果。</p>

<p><br/></p>

<p>因此，各安天命，同时意识到自身的性格缺陷，我想这才是好的，</p>

<p>保持一定的灵活性，不至于总是难堪到把自己逼疯，</p>

<p>也不至于自信到能改变命运。</p>

<p><br/></p>

<p>道法自然。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[相信不证自明]]></title>
    <link href="https://thzt.github.io/blog/2016/08/24/believed-in-the-absence-of-evidence/"/>
    <updated>2016-08-24T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/08/24/believed-in-the-absence-of-evidence</id>
    <content type="html"><![CDATA[<p>当我们得出某个结论的时候，最容易忽视的一点是，</p>

<p>结论实际上是在某个前提之下才成立的，</p>

<p>如果前提有漏洞，那么结论就不可靠了。</p>

<p><br/></p>

<p>这件事经常会对我们起到警示作用。</p>

<p>让我们有意识的去鉴别前提的真实性，</p>

<p>这可以称之为科学方法，小心的去求证某些假设。</p>

<p><br/></p>

<p>然而，在另一方面，</p>

<p>有能力暂时接受某个尚未判断为真的假设，也是一种能力。</p>

<p>先相信别人，相信不证自明，存疑于来日方长，而不纠结某个断言，</p>

<p>会让我们更容易站在别人的立场看待问题，视野更广。</p>

<p><br/></p>

<p>因此，聪明人的思路总是有很多分支，各个分支都有条件。</p>

<p>那些已经相信的事实，可能只是一个假设，</p>

<p>那些极力怀疑的论点，也有可能为真。</p>

<p><br/></p>

<p><a href="https://book.douban.com/subject/3138847/">大前研一</a>这样说，</p>

<p>解决问题的能力，就是为印证假设不辞劳苦的行动力。</p>

<p><br/></p>

<h3><strong>先让人把事情说完</strong></h3>

<p>当别人表述某个论点的时候，很难同时携带着该论点的证明，</p>

<p>所以，转而让他去证明这个论点，就会打断他的思路，证明完之后还要再跳回来。</p>

<p>不幸的是，现场的不充分的思考，根本不具备清晰证明某个论点的条件，</p>

<p>这也是为什么会议容易被无限延长的原因，</p>

<p>现场很难让别人相信你，可是不相信你的论点，他们就做不到继续往下听。</p>

<p><br/></p>

<p>一个好的权衡之计就是，先让分享者把事情讲完，</p>

<p>哪怕其中包含了很多值得怀疑的论点，</p>

<p>我们先记录下来，最后大家一起，逐个用行动去检验它。</p>

<p><br/></p>

<p>将表述和证明隔开，是有好处的，</p>

<p>夹杂着提到的所有定理之证明过程的教科书是多么的晦涩难懂，</p>

<p>它影响了整本书的知识脉络，也影响了读者的思路，</p>

<p>尽管这些证明是有用的。</p>

<p><br/></p>

<h3><strong>先相信才有必要防止尽信</strong></h3>

<p>上学时，我们学过一篇文章提到，</p>

<p>尽信书，则不如无书，</p>

<p>我觉得这句话坑害了很多人。</p>

<p><br/></p>

<p>它让人们更加容易怀疑某些已被证明的结论，</p>

<p>而不是建立起“承认在某种假设下该结论为真”的科学观，</p>

<p>这大大减缓了我们接受新知识的速度。</p>

<p><br/></p>

<p>人们容易去寻找“到底什么是真的”，这种荒谬问题的结论，</p>

<p>而不是认识到“真理是条件性为真”，这种科学方法的本质。</p>

<p><br/></p>

<p>实际上，首先我们先要做到“信书”，</p>

<p>然后才有必要提醒自己不要“尽信书”。</p>

<p><br/></p>

<h3><strong>证明不是为了让自己更信</strong></h3>

<p>不以发现隐含前提的为动机的证明，只是让自己更相信结论而已。</p>

<p><br/></p>

<p>对每个论点都尝试检验，可以磨炼我们论证的技巧，</p>

<p>但是却并不会加强我们“找到什么才是假设”的能力。</p>

<p><br/></p>

<p>有多少人怀疑狭义相对论，可是，它已经是在光速不变性的这个前提下被证明为真的结论了，</p>

<p>大多数人怀疑论证的过程，而不是怀疑论证的前提，也没有想过去挖掘隐含的前提，</p>

<p>发现和检验前提才是最困难的一步，通过论证结论肯定是可重现的，</p>

<p>多证明一次，只是让自己更相信罢了。</p>

<p><br/></p>

<p>哪怕是在科学研究中，很多结论也是建立在假设之上的，</p>

<p>这些假设在现代条件下可能无法检验，但只要是最终能被检验的就行，</p>

<p>那么我们就能说这个结论不可靠吗？我们宁可相信它是条件性可靠的。</p>

<p><br/></p>

<h3><strong>结语</strong></h3>

<p>相信不证自明，一开始很难办到，因为我们习惯了用证明去说服自己，</p>

<p>实际上，我们脑海中有很多假设是却是未经证明的。</p>

<p><br/></p>

<p>比如，你怎么证明你看到的就是那个事物，你看到的只是它反射的光罢了。</p>

<p>我们确定某人出现了两次，而不是两个同样的人，</p>

<p>是建立在不同的人一定会反射不同的光这种假设上的。</p>

<p>万一，以后科技发达后，可以改变这个假设呢？</p>

<p><br/></p>

<p>因此，到底什么才是真的，这个问题是找不到答案的，</p>

<p>我们只能知道在某个前提下的结论。</p>

<p><br/></p>

<p>此外，我们之所以倚仗证明，</p>

<p>还不是因为我们相信证明可以让经验更可靠吗？</p>

<p>然而这件事本身也是一个前提，但又是不可被证明的，</p>

<p>我们只能说大部分情况确实如此，仅此而已。</p>

<p><br/></p>

<p>那么，这篇文章的结论，你相信吗？</p>

<p>请相信不证自明。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[思路和想象力]]></title>
    <link href="https://thzt.github.io/blog/2016/08/18/imagination/"/>
    <updated>2016-08-18T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/08/18/imagination</id>
    <content type="html"><![CDATA[<p>命题逻辑和一阶谓词逻辑属于古典逻辑范围，</p>

<p>而直觉主义逻辑是一种非经典逻辑，</p>

<p>它不承认排中律，强调命题的证实性而不是真理性。</p>

<p><br/></p>

<p>古典逻辑认为，一个实体的存在可以通过否定它的不存在来证明。</p>

<p>对直觉主义逻辑来说，这是不正确的，</p>

<p>不存在性的否定不表示可能找到存在性的构造证明。</p>

<p><br/></p>

<h3><strong>整合思维</strong></h3>

<p>商业思想家罗杰·马丁，曾采访过50多位成功的领导者，</p>

<p>最终发现，他们大都具有一个非同寻常的特征。</p>

<p><br/></p>

<p>他们愿意而且能够同时接纳两种互相冲突的观点，</p>

<p>在碰到意见冲突时，他们既不慌张，也不是简单的进行非此即彼的取舍，</p>

<p>而是另辟蹊径，提出一个新思路，</p>

<p>既包含了原先两种观点的内容，又比原先两种观点胜出一筹。</p>

<p>罗杰·马丁把这种思考和综合的过程，称为整合性思维。</p>

<p><br/></p>

<h3><strong>智者</strong></h3>

<p>70多年前，美国小说家斯科特·菲茨杰拉德也指出过，</p>

<p>真正智者的特点之一，就是，</p>

<p>能同时容下两个相对立的想法，但仍然保持行动能力。</p>

<p><br/></p>

<h3><strong>应变</strong></h3>

<p>我国古代，三国时期魏国大臣，政治家，军事家司马懿，</p>

<p>在教育孩子时，也曾说过，</p>

<p>夫处世之道，亦即应变之术，岂可偏执一端；</p>

<p>用兵之道亦然如此，皆贵在随机应变。</p>

<p><br/></p>

<h3><strong>趋向的危害</strong></h3>

<p>以上例子我们可以发现，同时遇到两种矛盾的想法是正常的，</p>

<p>非此即彼的断言，反而是片面的。</p>

<p>因此，当我们在生活中发现自己的某种趋向时，就得开始惶恐了，</p>

<p>它的相反面所具有的种种好处，我们得到的将越来越少。</p>

<p><br/></p>

<p>思路和想象力，就是这样对立的两种思维。</p>

<p><br/></p>

<h3><strong>逻辑思维</strong></h3>

<p>思路，可以理解为思维的路径。</p>

<p>大前研一在《思考的技术》一书中提到，</p>

<p>由于绝大多数人都没有养成逻辑思考的习惯，所以就缺少了能够解决问题的思路。</p>

<p>所以人们应该重视导出结论的思维路径，而不是有没有知识。</p>

<p><br/></p>

<p>可见，思路对于解决一个问题，</p>

<p>甚至判断这个问题是否真的构成问题来说，</p>

<p>都是非常重要的。</p>

<p><br/></p>

<p>没有这些思路，我们将很容易迷失。</p>

<p>方案做出来之后，才发现根本没有达到目的，因为我们没有考虑方向，</p>

<p>计划落地后，才发现得不偿失，因为我们没有考虑成本和收益，</p>

<p>项目经常性的延期，小伙伴们苦于加班，因为我们在过程中没有考虑过风险。</p>

<p><br/></p>

<p>这些都是经验教训，可以总结为思维的套路，</p>

<p>按着套路思考的话，我们会避免进入很多误区。</p>

<p><br/></p>

<h3><strong>想象力</strong></h3>

<p>我们感受到了我们的趋向，</p>

<p>我们钟爱思路，那么就会出现问题。</p>

<p><br/></p>

<p>要判断一件事情是否有价值，判断它的影响范围，</p>

<p>常用的思路当然可以帮助我们。</p>

<p>可是，思路会逐渐变成人们的舒适区，</p>

<p>人们更容易相信符合逻辑判断的结论。</p>

<p><br/></p>

<p>从短时间来看，逻辑推理是有用的，</p>

<p>会帮助我们排除那些显然可以被证明为错误的方案，</p>

<p>但是从长时间来看，就不尽然了。</p>

<p><br/></p>

<p>一个长远目标，或者一个战略举措，</p>

<p>根本就无法通过逻辑来推理出来，因为我们所知所感都是朦胧的，</p>

<p>在有创新性的工作中，这一点非常明显。</p>

<p><br/></p>

<p>爱因斯坦这样说，想象力比知识更重要。</p>

<p>是的，科学研究更需要想象力来决定方向，</p>

<p>而逻辑证明只是用来排除那些不正确想法罢了。</p>

<p><br/></p>

<p>想象力，让我们更有远见，</p>

<p>而严谨的思维和卓越的执行能力，让我们可以实现它。</p>

<p><br/></p>

<h3><strong>结语</strong></h3>

<p>那么如何锻炼现象力呢？</p>

<p><br/></p>

<p>我们可以想象一下未来，大胆预测，</p>

<p>我们应该总是尝试做一些意料之外的事情。</p>

<p><br/></p>

<p>我们也可以把不太相关的事物放在一起类比，找出关联，</p>

<p>这两件事情根本毫无关系，那我们让他们相关，</p>

<p>会发生什么好玩的事情？</p>

<p><br/></p>

<p>我们还可以符合逻辑的事情取反，并假设它成立，</p>

<p>想象中我们的世界是颠倒的，因为我们想看到以前看不到的东西。</p>

<p><br/></p>

<p>总之，我们要保持中立，警惕偏执，这样才会同时拥有它们的种种好处。</p>

<p><br/></p>

<p>我们不但要把思维路径记录下来，让人人都能得出相同的决策，降低风险。</p>

<p>我们还要发挥前瞻性和想象力，让我们的工作不可被替代，有远见。</p>

<p><br/></p>

<h3><strong>参考</strong></h3>

<p><a href="https://zh.wikipedia.org/wiki/%E7%9B%B4%E8%A7%89%E4%B8%BB%E4%B9%89%E9%80%BB%E8%BE%91">直觉主义逻辑</a></p>

<p><a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E7%9B%B4%E8%A7%89%E4%B8%BB%E4%B9%89">数学直觉主义</a></p>

<p><a href="http://wenku.baidu.com/view/1d94574dfe4733687e21aa8b.html">整合性思维：成功领导人的思考方式</a></p>

<p><a href="https://book.douban.com/subject/3138847/">思考的技术</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[拓扑学拾趣]]></title>
    <link href="https://thzt.github.io/blog/2016/08/13/about-topology/"/>
    <updated>2016-08-13T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/08/13/about-topology</id>
    <content type="html"><![CDATA[<script src="https://thzt.github.io/thirdpart/jQuery/jquery-1.11.1.js"></script>


<p><link href="https://thzt.github.io/thirdpart/KaTeX/katex.min.css" rel="stylesheet"/></p>

<script src="https://thzt.github.io/thirdpart/KaTeX/katex.min.js"></script>


<script src="https://thzt.github.io/javascripts/katex.js"></script>


<h2><strong>集合论的基础知识</strong></h2>

<p><strong>幂集</strong></p>

<p>设<span data-katex="X"></span>是非空集合，</p>

<p>记<span data-katex="2^X"></span>是<span data-katex="X"></span>的全体子集（包括<span data-katex="X"></span>及<span data-katex="\varnothing"></span>）的集合，</p>

<p>称为<span data-katex="X"></span>的幂集。</p>

<p><br/></p>

<p><strong>包含关系</strong></p>

<p><span data-katex="x\in A"></span>表示<span data-katex="x"></span>是集合<span data-katex="A"></span>中的一个元素。</p>

<p><span data-katex="x\notin A"></span>表示<span data-katex="x"></span>不是集合<span data-katex="A"></span>的元素。</p>

<p><span data-katex="A\subseteq B"></span>表示<span data-katex="A"></span>包含于<span data-katex="B"></span>（包含<span data-katex="A=B"></span>的情形）。</p>

<p><span data-katex="A\nsubseteq"></span>表示<span data-katex="A"></span>不包含与<span data-katex="B"></span>，即<span data-katex="A"></span>中有不属于<span data-katex="B"></span>的元素。</p>

<p><br/></p>

<p><strong>交与并</strong></p>

<p>现在列出<span data-katex="2^X"></span>中的几种运算及它们的性质。</p>

<p><span data-katex="\;{\tiny\begin{matrix} \\ \normalsize \cap \\ ^{\scriptsize \lambda \in \Lambda }\end{matrix}}\;A_\lambda"></span>表示集合族<span data-katex="\{ A_\lambda | \lambda \in \Lambda \}"></span>中所有集合之交。</p>

<p><span data-katex="\;{\tiny\begin{matrix} \\ \normalsize \cup \\ ^{\scriptsize \lambda \in \Lambda }\end{matrix}}\;A_\lambda"></span>表示集合族<span data-katex="\{ A_\lambda | \lambda \in \Lambda \}"></span>中所有集合之并。</p>

<p><br/></p>

<p><strong>交换律，结合律和分配律</strong></p>

<p>交并运算各自都满足交换律和结合律。</p>

<p>交与并有分配律：</p>

<p>（1）<span data-katex="B\cup ( \;{\tiny\begin{matrix} \\ \normalsize \cap \\ ^{\scriptsize \lambda \in \Lambda }\end{matrix}}\;A_\lambda )=\;{\tiny\begin{matrix} \\ \normalsize \cap \\ ^{\scriptsize \lambda \in \Lambda }\end{matrix}}\;(B\cup A_\lambda )"></span></p>

<p>（2）<span data-katex="B\cap ( \;{\tiny\begin{matrix} \\ \normalsize \cup \\ ^{\scriptsize \lambda \in \Lambda }\end{matrix}}\;A_\lambda )=\;{\tiny\begin{matrix} \\ \normalsize \cup \\ ^{\scriptsize \lambda \in \Lambda }\end{matrix}}\;(B\cap A_\lambda )"></span></p>

<p><br/></p>

<p><strong>差和余</strong></p>

<p>差，<span data-katex="A\backslash B"></span>表示属于<span data-katex="A"></span>而不属于<span data-katex="B"></span>的元素的集合。</p>

<p>余集，<span data-katex="A^c:=X\backslash A"></span>。</p>

<p>因此，<span data-katex="A\backslash B=A\cap B^c"></span></p>

<p><br/></p>

<p><strong>De Morgan公式</strong></p>

<p>（1）<span data-katex="B\backslash ( \;{\tiny\begin{matrix} \\ \normalsize \cup \\ ^{\scriptsize \lambda \in \Lambda }\end{matrix}}\;A_\lambda )=\;{\tiny\begin{matrix} \\ \normalsize \cap \\ ^{\scriptsize \lambda \in \Lambda }\end{matrix}}\;(B\backslash A_\lambda )"></span></p>

<p>（2）<span data-katex="B\backslash ( \;{\tiny\begin{matrix} \\ \normalsize \cap \\ ^{\scriptsize \lambda \in \Lambda }\end{matrix}}\;A_\lambda )=\;{\tiny\begin{matrix} \\ \normalsize \cup \\ ^{\scriptsize \lambda \in \Lambda }\end{matrix}}\;(B\backslash A_\lambda )"></span></p>

<p><br/></p>

<p>特别的当<span data-katex="B=X"></span>为全集时，</p>

<p>（3）<span data-katex="( \;{\tiny\begin{matrix} \\ \normalsize \cup \\ ^{\scriptsize \lambda \in \Lambda }\end{matrix}}\;A_\lambda )^c=\;{\tiny\begin{matrix} \\ \normalsize \cap \\ ^{\scriptsize \lambda \in \Lambda }\end{matrix}}\;A_\lambda^c"></span></p>

<p>（4）<span data-katex="( \;{\tiny\begin{matrix} \\ \normalsize \cap \\ ^{\scriptsize \lambda \in \Lambda }\end{matrix}}\;A_\lambda )^c=\;{\tiny\begin{matrix} \\ \normalsize \cup \\ ^{\scriptsize \lambda \in \Lambda }\end{matrix}}\;A_\lambda^c"></span></p>

<p><br/></p>

<p><strong>映射</strong></p>

<p>设<span data-katex="X"></span>和<span data-katex="Y"></span>都是集合，映射<span data-katex="f:X\rightarrow Y"></span>是一个对应关系，使得</p>

<p><span data-katex="\forall x\in X"></span>，对应着<span data-katex="Y"></span>中的一点<span data-katex="f(x)"></span>（称为<span data-katex="x"></span>的像点）</p>

<p><br/></p>

<p>若<span data-katex="A\subseteq X"></span>，记<span data-katex="f(A:=\{f(x)|x\in A\}"></span>，是<span data-katex="Y"></span>的一个子集，</p>

<p>称为<span data-katex="A"></span>在<span data-katex="f"></span>下的像。</p>

<p>若<span data-katex="B\subseteq Y"></span>，记<span data-katex="f^{-1}(b):=\{x\in X|f(x)\in B\}"></span>，</p>

<p>称为<span data-katex="B"></span>在<span data-katex="f"></span>下的原像。</p>

<p><br/></p>

<p>当<span data-katex="f(X)=Y"></span>时，称<span data-katex="f"></span>是满的，</p>

<p>若<span data-katex="X"></span>中的不同点的像点也不同，称<span data-katex="f"></span>是单的。</p>

<p>既单又满的映射称为一一对应。</p>

<p>当<span data-katex="f"></span>是一一对应时，它就有一个逆映射，记作<span data-katex="f^{-1}"></span>。</p>

<p><br/></p>

<p><strong>映射的复合</strong></p>

<p>设<span data-katex="f:X\rightarrow Y"></span>和<span data-katex="g:Y\rightarrow Z"></span>都是映射，</p>

<p><span data-katex="f"></span>和<span data-katex="g"></span>的复合（或称乘积）是<span data-katex="X"></span>到<span data-katex="Z"></span>的映射，记作<span data-katex="g\circ f:X\rightarrow Z"></span>，</p>

<p>规定为，<span data-katex="(g\circ f)(x)=g(f(x))"></span>。</p>

<p><br/></p>

<p><span data-katex="\forall x\in X"></span>，则有，</p>

<p>（1）<span data-katex="(g\circ f)(A)=g(f(A))"></span></p>

<p>（2）<span data-katex="(g\circ f)^{-1}(B)=f^{-1}(g^{-1}(B))"></span></p>

<p><br/></p>

<p><strong>恒同映射，限制与包含映射</strong></p>

<p>集合<span data-katex="X"></span>到自身的恒同映射（保持每一点不变）记作<span data-katex="id_X:\rightarrow X"></span>（常简记为<span data-katex="id"></span>）。</p>

<p>若<span data-katex="f:X\rightarrow Y"></span>是映射，<span data-katex="A\subseteq X"></span>，规定<span data-katex="f"></span>在<span data-katex="A"></span>上的限制为<span data-katex="f|A:X\rightarrow Y"></span>，</p>

<p><span data-katex="\forall x\in A"></span>，<span data-katex="(f|A)(x)=f(x)"></span>。</p>

<p>记<span data-katex="i:A\rightarrow X"></span>为包含映射，即<span data-katex="\forall x\in A"></span>，<span data-katex="i(x)=x"></span>，</p>

<p>于是，<span data-katex="i=id|A"></span>，<span data-katex="f|A=f\circ i"></span>。</p>

<p><br/></p>

<p><strong>笛卡尔积</strong></p>

<p>设<span data-katex="X_1"></span>和<span data-katex="X_2"></span>都是集合，称集合</p>

<p><span data-katex="X_1\times X_2:=\{(x,y)|x\in X,y\in Y\}"></span>为<span data-katex="X_1"></span>与<span data-katex="X_2"></span>的笛卡尔积。</p>

<p>称<span data-katex="x"></span>和<span data-katex="y"></span>为有序偶<span data-katex="(x,y)"></span>的坐标。</p>

<p><br/></p>

<p><strong>等价关系</strong></p>

<p>集合<span data-katex="X"></span>上的一个关系<span data-katex="R"></span>是<span data-katex="X\times X"></span>的一个子集，</p>

<p>当<span data-katex="(x_1,x_2)\in R"></span>时，说<span data-katex="x_1"></span>与<span data-katex="x_2"></span>是<span data-katex="R"></span>相关的，记作<span data-katex="x_1Rx_2"></span>。</p>

<p><br/></p>

<p>集合<span data-katex="X"></span>的一个关系<span data-katex="R"></span>称为等价关系，如果满足：</p>

<p>（1）自反性：<span data-katex="\forall x\in X"></span>，<span data-katex="xRx"></span></p>

<p>（2）对称性：若<span data-katex="x_1Rx_2"></span>，则<span data-katex="x_2Rx_1"></span></p>

<p>（3）传递性：若<span data-katex="x_1Rx_2"></span>，<span data-katex="x_2Rx_3"></span>，则<span data-katex="x_1Rx_3"></span></p>

<p><br/></p>

<p>等价关系常用<span data-katex="\sim"></span>表示，例如<span data-katex="x_1Rx_2"></span>，可记作<span data-katex="x_1\sim x_2"></span>，</p>

<p>称为<span data-katex="x_1"></span>等价于<span data-katex="x_2"></span>。</p>

<p>当<span data-katex="X"></span>上有等价关系<span data-katex="\sim"></span>时，可以把<span data-katex="X"></span>分成许多子集，</p>

<p>凡是互相等价的点属于同一子集。</p>

<p>称每个子集为一个<span data-katex="\sim"></span>等价类，记<span data-katex="X/\sim"></span>是全部等价类的集合，</p>

<p>称为<span data-katex="X"></span>关于<span data-katex="\sim"></span>的商集。</p>

<p><span data-katex="\forall x\in X"></span>所在的等价类记作<span data-katex="\left \langle x \right \rangle"></span>，</p>

<p>于是，<span data-katex="X/\sim =\{\left \langle x \right \rangle |x\in X\}"></span></p>

<p><br/></p>

<h2><strong>拓扑空间</strong></h2>

<p><strong>子集族</strong></p>

<p>设<span data-katex="X"></span>是一个非空集合，<span data-katex="2^X"></span>是<span data-katex="X"></span>的幂集，</p>

<p>把<span data-katex="2^X"></span>的子集（即以<span data-katex="X"></span>的一部分子集为成员的集合）称为<span data-katex="X"></span>的子集族。</p>

<p><br/></p>

<p><strong>拓扑</strong></p>

<p>设<span data-katex="X"></span>是一个非空集合，<span data-katex="X"></span>的一个子集族<span data-katex="\tau"></span>称为<span data-katex="X"></span>的一个拓扑，</p>

<p>如果它满足</p>

<p>（1）<span data-katex="X"></span>和<span data-katex="\varnothing"></span>都包含在<span data-katex="\tau"></span>中</p>

<p>（2）<span data-katex="\tau"></span>中任意多个成员的并集仍在<span data-katex="\tau"></span>中</p>

<p>（3）<span data-katex="\tau"></span>中有限多个成员的交集仍在<span data-katex="\tau"></span>中</p>

<p><br/></p>

<p>集合<span data-katex="X"></span>和它的一个拓扑<span data-katex="\tau"></span>一起称为一个拓扑空间，记作<span data-katex="(X,\tau)"></span>。</p>

<p>称<span data-katex="\tau"></span>中的成员为这个拓扑空间的开集。</p>

<p><br/></p>

<p>从定义看出，给出集合的一个拓扑就是规定它的哪些子集是开集。</p>

<p><br/></p>

<p><strong>离散拓扑</strong></p>

<p>设<span data-katex="X"></span>是一个非空集合，<span data-katex="2^X"></span>构成<span data-katex="X"></span>上的一个拓扑，称为<span data-katex="X"></span>上的离散拓扑。</p>

<p><span data-katex="\{X,\varnothing \}"></span>也是<span data-katex="X"></span>上的拓扑，称为<span data-katex="X"></span>上的平凡拓扑。</p>

<p><br/></p>

<p><strong>有限补拓扑，可数补拓扑</strong></p>

<p>设<span data-katex="X"></span>是无穷集合，<span data-katex="\tau =\{A| A^c \subseteq X\wedge A^c\ is\ finite\}\cup\{\varnothing \}"></span>，称为<span data-katex="X"></span>上的有限补拓扑。</p>

<p>设<span data-katex="X"></span>是不可数无穷集合，<span data-katex="\tau =\{A| A^c \subseteq X\wedge A^c\ is\ countable\}\cup\{\varnothing \}"></span>，称为<span data-katex="X"></span>上的可数补拓扑。</p>

<p><br/></p>

<p><strong>度量</strong></p>

<p>集合<span data-katex="X"></span>上的一个度量<span data-katex="d"></span>是一个映射<span data-katex="d:X\times X\rightarrow R"></span>，</p>

<p>它满足</p>

<p>（1）正定性：<span data-katex="d(x,x)=0"></span>，<span data-katex="\forall x\in X"></span>；<span data-katex="d(x,y)>0"></span>，当<span data-katex="X\neq Y"></span></p>

<p>（2）对称性：<span data-katex="d(x,y)=d(y,x)"></span>，<span data-katex="\forall x,y\in X"></span></p>

<p>（3）三角不等式：<span data-katex="d(x,x)\leqslant d(x,y)+d(y,z)"></span>，<span data-katex="\forall x,y,z\in X"></span></p>

<p><br/></p>

<p>当集合<span data-katex="X"></span>上规定一个度量<span data-katex="d"></span>后，称为度量空间，记作<span data-katex="(X,d)"></span>。</p>

<p><br/></p>

<p><span data-katex="R^n=\{(x_1,x_2,\cdots ,x_n)|x_i\in R,\ i=1,2,\cdots , n\}"></span>，</p>

<p>规定<span data-katex="R^n"></span>上的度量<span data-katex="d"></span>为，</p>

<p><span data-katex="d((x_1,\cdots ,x_n),(y_1,\cdots ,y_n))=\sqrt{\sum_{x=1}^{n}(x_i-y_i)^2}"></span></p>

<p>记<span data-katex="E^n=(R^n,d)"></span>，称为<span data-katex="n"></span>维欧氏空间。</p>

<p><br/></p>

<p><strong>球形邻域</strong></p>

<p>设<span data-katex="x_0\in X"></span>，<span data-katex="\varepsilon"></span>是一个正数，称<span data-katex="X"></span>的子集</p>

<p><span data-katex="B(x_0,\varepsilon):=\{x\in X|d(x_0,x)<\varepsilon \}"></span></p>

<p>为以<span data-katex="x_0"></span>为心，<span data-katex="\varepsilon"></span>为半径的球形邻域。</p>

<p><br/></p>

<p>如果规定<span data-katex="X"></span>的子集族<span data-katex="\tau"></span>是<span data-katex="X"></span>中若干球形邻域的并集，</p>

<p>那么<span data-katex="\tau"></span>构成了<span data-katex="X"></span>上的一个拓扑，</p>

<p>并称<span data-katex="\tau"></span>为<span data-katex="X"></span>上由度量<span data-katex="d"></span>决定的度量拓扑。</p>

<p><br/></p>

<p>因此，每个度量空间都可以自然的看成具有度量拓扑的拓扑空间。</p>

<p><br/></p>

<h2><strong>拓扑空间的几个基本概念</strong></h2>

<p><strong>闭集</strong></p>

<p>拓扑空间<span data-katex="X"></span>的一个子集<span data-katex="A"></span>称为闭集，如果<span data-katex="A^c"></span>是开集。</p>

<p>也就是说，闭集就是开集的余集，开集也一定是一个闭集的余集。</p>

<p><br/></p>

<p>例如，在离散拓扑空间中，任何子集都是开集，从而任何子集也都是闭集。</p>

<p>在平凡拓扑空间中，只有两个闭集，<span data-katex="X=\varnothing ^c"></span>和<span data-katex="\varnothing =X^c"></span>。</p>

<p><br/></p>

<p>拓扑空间中的闭集满足：</p>

<p>（1）<span data-katex="X"></span>和<span data-katex="\varnothing"></span>都是闭集</p>

<p>（2）任意多个闭集的交集是闭集合</p>

<p>（3）有限个闭集的并集是闭集</p>

<p><br/></p>

<p><strong>内点，邻域和内部</strong></p>

<p>设<span data-katex="A"></span>是拓扑空间<span data-katex="X"></span>的一个子集，点<span data-katex="x\in A"></span>，</p>

<p>如果存在开集<span data-katex="U"></span>，使得<span data-katex="x\in U\subseteq A"></span>，</p>

<p>则称<span data-katex="x"></span>是<span data-katex="A"></span>的一个内点，<span data-katex="A"></span>是<span data-katex="x"></span>的一个邻域。</p>

<p><br/></p>

<p><span data-katex="A"></span>的所有内点的集合称为<span data-katex="A"></span>的内部，记作<span data-katex="A^\circ"></span>。</p>

<p>（1）若<span data-katex="A\subseteq B"></span>，则<span data-katex="A^\circ \subseteq B^\circ"></span></p>

<p>（2）<span data-katex="A^\circ"></span>是包含在<span data-katex="A"></span>中所有开集的并集，因此是包含在<span data-katex="A"></span>中的最大开集</p>

<p>（3）<span data-katex="A^\circ =A"></span>当且仅当<span data-katex="A"></span>是开集</p>

<p>（4）<span data-katex="(A\cap B)^\circ =A^\circ \cap B^\circ"></span></p>

<p>（5）<span data-katex="(A\cup B)^\circ \supseteq A^\circ \cup B^\circ"></span></p>

<p><br/></p>

<p><strong>聚点，导集和闭包</strong></p>

<p>设<span data-katex="A"></span>是拓扑空间<span data-katex="X"></span>的子集，<span data-katex="x\in X"></span>，</p>

<p>如果<span data-katex="x"></span>的每个邻域都含有<span data-katex="A\backslash\{x\}"></span>中的点，则称<span data-katex="x"></span>为<span data-katex="A"></span>的聚点。</p>

<p><span data-katex="A"></span>的所有聚点集合称为<span data-katex="A"></span>的导集，记作<span data-katex="A'"></span>。</p>

<p>称集合<span data-katex="\overline{A}:=A\cup A'"></span>为<span data-katex="A"></span>的闭包。</p>

<p><br/></p>

<p>由定义不难看出，<span data-katex="x\in \overline{A}"></span>当且仅当<span data-katex="x"></span>的任一邻域与<span data-katex="A"></span>都有交点。</p>

<p>（1）若<span data-katex="A\subseteq B"></span>，则<span data-katex="\overline{A}\subseteq \overline{B}"></span></p>

<p>（2）<span data-katex="\overline{A}"></span>是所有包含<span data-katex="A"></span>的闭集的交集，所以是包含<span data-katex="A"></span>的最小闭集。</p>

<p>（3）<span data-katex="\overline{A}=A"></span>当且仅当<span data-katex="A"></span>是闭集</p>

<p>（4）<span data-katex="\overline{A\cup B}=\overline{A}\cup \overline{B}"></span></p>

<p>（5）<span data-katex="\overline{A\cap B} \subseteq \overline{A}\cap \overline{B}"></span></p>

<p><br/></p>

<p><strong>可分拓扑空间</strong></p>

<p>拓扑空间<span data-katex="X"></span>的子集<span data-katex="A"></span>称为稠密的，如果<span data-katex="\overline{A}=X"></span>。</p>

<p>如果<span data-katex="X"></span>有可数的稠密子集，则称<span data-katex="X"></span>是可分拓扑空间。</p>

<p><br/></p>

<p><strong>子空间</strong></p>

<p>设<span data-katex="A"></span>是拓扑空间<span data-katex="(X,\tau)"></span>的一个非空子集，</p>

<p>规定<span data-katex="A"></span>的子集族为<span data-katex="\tau _A:=\{U\cap A|U\in \tau \}"></span>，</p>

<p>可证<span data-katex="\tau _A"></span>是<span data-katex="A"></span>上的一个拓扑，称为<span data-katex="\tau"></span>导出的<span data-katex="A"></span>上的子空间拓扑，</p>

<p>称<span data-katex="(A,\tau _A)"></span>为<span data-katex="(X,\tau)"></span>的子空间。</p>

<p><br/></p>

<p>以后对拓扑空间的子集都将看做拓扑空间，即子空间。</p>

<p>对于子空间<span data-katex="A"></span>的子集<span data-katex="U"></span>，笼统的说<span data-katex="U"></span>是不是开集意义就不明确了，</p>

<p>必须说明在<span data-katex="A"></span>中看还是在全空间中看，这两者是不同的。</p>

<p><br/></p>

<p>例如，<span data-katex="E^1"></span>是<span data-katex="E^2"></span>的子空间，开区间<span data-katex="(0,1)"></span>在<span data-katex="E^1"></span>中是开集，</p>

<p>而在<span data-katex="E^2"></span>中不是开集，因此开集的概念是相对的。</p>

<p>同样，闭集，邻域，内点，内部，聚点和闭包等等概念也都是相对概念。</p>

<p><br/></p>

<h2><strong>连续映射与同胚映射</strong></h2>

<p><strong>连续映射</strong></p>

<p>设<span data-katex="X"></span>和<span data-katex="Y"></span>都是拓扑空间，<span data-katex="f:X\rightarrow Y"></span>是一个映射，</p>

<p><span data-katex="x\in X"></span>，如果对于<span data-katex="Y"></span>中<span data-katex="f(x)"></span>的任一邻域<span data-katex="V"></span>，</p>

<p><span data-katex="f^{-1}(V)"></span>总是<span data-katex="x"></span>的邻域，则说<span data-katex="f"></span>在<span data-katex="x"></span>处连续。</p>

<p><br/></p>

<p>如果把定义中的『任一邻域<span data-katex="V"></span>』改成『任一开邻域<span data-katex="V"></span>』，那么定义的意义不变，</p>

<p>因此，<span data-katex="f"></span>在点<span data-katex="x"></span>处连续，也就是，</p>

<p>对包含<span data-katex="f(x)"></span>的每个开集，比存在包含<span data-katex="x"></span>的开集<span data-katex="U"></span>，</p>

<p>使得，<span data-katex="f(U)\subseteq V"></span>。</p>

<p><br/></p>

<p>如果映射<span data-katex="f:X\rightarrow Y"></span>在任一点<span data-katex="x\in X"></span>都连续，</p>

<p>则说<span data-katex="f"></span>是连续映射。</p>

<p>（1）<span data-katex="Y"></span>的任一开集在<span data-katex="f"></span>下的原像是<span data-katex="X"></span>的开集</p>

<p>（2）<span data-katex="Y"></span>的任一闭集在<span data-katex="f"></span>下的原像是<span data-katex="X"></span>的闭集</p>

<p><br/></p>

<p><strong>同胚映射</strong></p>

<p>如果<span data-katex="f:X\rightarrow Y"></span>是一一对应，</p>

<p>并且<span data-katex="f"></span>及其逆<span data-katex="f"></span>{-1}:Y\rightarrow X"></span>都是连续的，</p>

<p>则称<span data-katex="f"></span>是一个同胚映射，简称同胚。</p>

<p><br/></p>

<p>当存在<span data-katex="X"></span>到<span data-katex="Y"></span>的同胚映射时，就称<span data-katex="X"></span>与<span data-katex="Y"></span>同胚，</p>

<p>记作<span data-katex="X \cong Y"></span>。</p>

<p><br/></p>

<p>值得注意的是，同胚映射中条件<span data-katex="f^{-1}"></span>连续不可忽视，</p>

<p>它不能从一一对应和<span data-katex="f"></span>的连续性推出。</p>

<p><br/></p>

<p><strong>拓扑不变性</strong></p>

<p>拓扑空间在同胚映射下保持不变的概念，称为拓扑概念，</p>

<p>在同胚映射下保持不变的性质，称为拓扑性质。</p>

<p><br/></p>

<p>当<span data-katex="f:X\rightarrow Y"></span>是同胚映射时，</p>

<p><span data-katex="X"></span>的每个开集<span data-katex="U"></span>的像<span data-katex="f(U)"></span>，是<span data-katex="Y"></span>的开集，</p>

<p>而<span data-katex="Y"></span>的开集<span data-katex="V"></span>的<span data-katex="f"></span>原像是<span data-katex="X"></span>的开集，</p>

<p>因此开集概念在同胚映射下保持不变，它是拓扑概念。</p>

<p>由它规定的闭集，闭包，邻域，内点等等概念都是拓扑概念。</p>

<p><br/></p>

<p>用开集或其派生的拓扑概念来刻画的性质，都是拓扑性质。</p>

<p><br/></p>

<h2><strong>拓扑基</strong></h2>

<p><strong>生成的子集族</strong></p>

<p>设<span data-katex="\mathscr{B}"></span>是<span data-katex="X"></span>的一个子集族，</p>

<p>规定新的子集族<span data-katex="\mathscr{B}'"></span>，它的元素为<span data-katex="\mathscr{B}"></span>中任意多个成员的并集。</p>

<p>称<span data-katex="\mathscr{B}'"></span>为<span data-katex="\mathscr{B}"></span>所生成的子集族，</p>

<p>显然有<span data-katex="\mathscr{B}\subseteq \mathscr{B}'"></span>，<span data-katex="\varnothing \in \mathscr{B}'"></span>。</p>

<p><br/></p>

<p><strong>投射</strong></p>

<p>设<span data-katex="X_1"></span>和<span data-katex="X_2"></span>是两个集合，记<span data-katex="X_1\times X_2"></span>为它们的笛卡尔积，</p>

<p>规定<span data-katex="j_1:X_1\times X_2\rightarrow X_i"></span>为<span data-katex="j_i(x_1,x_2)=x_i"></span>，<span data-katex="i=1,2"></span>，</p>

<p>称<span data-katex="j_i"></span>为<span data-katex="X_1\times X_2"></span>到<span data-katex="X_i"></span>的投射。</p>

<p><br/></p>

<p><strong>乘积空间</strong></p>

<p>设<span data-katex="(X_1,\tau_1)"></span>和<span data-katex="(X_2,\tau_2)"></span>是两个拓扑空间，</p>

<p>现在要在笛卡尔积<span data-katex="X_1\times X_2"></span>上规定一个与<span data-katex="\tau_1,\tau_2"></span>密切相关的拓扑<span data-katex="\tau"></span>，</p>

<p>使得<span data-katex="j_1"></span>和<span data-katex="j_2"></span>都连续，并且是满足此要求的最小拓扑。</p>

<p><br/></p>

<p>设<span data-katex="\mathscr{B}=\{U_1\times U_2|U_i\in \tau_i\}"></span>，</p>

<p>则由<span data-katex="\mathscr{B}"></span>生成的子集族<span data-katex="\mathscr{B}'"></span>，构成了<span data-katex="X_1\times X_2"></span>上的一个拓扑，</p>

<p>称为<span data-katex="X_1\times X_2"></span>上的乘积拓扑。</p>

<p><br/></p>

<p>称<span data-katex="(X_1\times X_2,\mathscr{B}')"></span>为<span data-katex="(X_1,\tau_1)"></span>和<span data-katex="(X_2,\tau_2)"></span>的乘积空间，</p>

<p>简记为<span data-katex="X_1\times X_2"></span>。</p>

<p><br/></p>

<p>可证，<span data-katex="\mathscr{B}'"></span>是使得<span data-katex="j_1"></span>和<span data-katex="j_2"></span>都连续的最小拓扑。</p>

<p><br/></p>

<p><strong>拓扑基</strong></p>

<p>称集合<span data-katex="X"></span>的子集族<span data-katex="\mathscr{B}"></span>为集合<span data-katex="X"></span>的拓扑基，</p>

<p>如果由<span data-katex="\mathscr{B}"></span>生成的子集族<span data-katex="\mathscr{B}'"></span>是<span data-katex="X"></span>的一个拓扑。</p>

<p><br/></p>

<p>称拓扑空间<span data-katex="(X,\tau)"></span>的子集族<span data-katex="\mathscr{B}"></span>为这个拓扑空间的拓扑基，</p>

<p>如果由<span data-katex="\mathscr{B}"></span>生成的子集族<span data-katex="\mathscr{B}'=\tau"></span>。</p>

<p><br/></p>

<p>这里提出了两个有联系的不同概念，集合的拓扑基和拓扑空间的拓扑基。</p>

<p>前者只要求<span data-katex="\mathscr{B}'"></span>是集合<span data-katex="X"></span>的一个拓扑，</p>

<p>而后者要求<span data-katex="\mathscr{B}'"></span>是<span data-katex="X"></span>原有的拓扑<span data-katex="\tau"></span>。</p>

<p>这两个概念的判断方法也是不一样的。</p>

<p><br/></p>

<p><span data-katex="\mathscr{B}"></span>是集合<span data-katex="X"></span>的拓扑基的充分必要条件是：</p>

<p>（1）<span data-katex="\;{\tiny\begin{matrix} \\ \normalsize \cup \\ ^{\scriptsize B\in \mathscr{B} }\end{matrix}}\;=X"></span></p>

<p>（2）若<span data-katex="B_1,B_2\in \mathscr{B}"></span>，则<span data-katex="B_1\cap B_2\in \mathscr{B}'"></span></p>

<p><br/></p>

<p><span data-katex="\mathscr{B}"></span>是拓扑空间<span data-katex="(X,\tau)"></span>的拓扑基的充分必要条件是：</p>

<p>（1）<span data-katex="\mathscr{B}\subseteq \tau"></span>（即<span data-katex="\mathscr{B}"></span>的成员都是开集）</p>

<p>（2）<span data-katex="\tau \subseteq \mathscr{B}'"></span>（即每个开集都是<span data-katex="\mathscr{B}"></span>中一些成员的并集）</p>

<p><br/></p>

<h2><strong>分离公理</strong></h2>

<p><strong><span data-katex="T_1"></span>公理</strong>
任何两个不同的店<span data-katex="x"></span>与<span data-katex="y"></span>，<span data-katex="x"></span>有邻域不含<span data-katex="y"></span>，<span data-katex="y"></span>有邻域不含<span data-katex="x"></span>。</p>

<p><br/></p>

<p><strong><span data-katex="T_2"></span>公理</strong></p>

<p>任何两个不同点有不相交邻域。</p>

<p><br/></p>

<p>这里的『邻域』可改成『开邻域』，而公理的含义不变。</p>

<p>满足<span data-katex="T_2"></span>也一定满足<span data-katex="T_1"></span>公理，但从<span data-katex="T_1"></span>公理推不出<span data-katex="T_2"></span>公理。</p>

<p>可证，<span data-katex="X"></span>满足<span data-katex="T_1"></span>公理，当且仅当<span data-katex="X"></span>的有限子集是闭集。</p>

<p><br/></p>

<p><span data-katex="T_2"></span>公理是最重要的分离公理，满足<span data-katex="T_2"></span>公理的拓扑空间称为Hausdorff空间。</p>

<p><br/></p>

<p><strong><span data-katex="T_3"></span>公理</strong></p>

<p>任意一点与不含它的任一闭集有不相交的（开）邻域。</p>

<p><br/></p>

<p><strong><span data-katex="T_4"></span>公理</strong></p>

<p>任意两个不想交的闭集有不想交的（开）邻域。</p>

<p>（当<span data-katex="A\subseteq U^\circ"></span>时，说<span data-katex="U"></span>是集合<span data-katex="A"></span>的邻域）</p>

<p><br/></p>

<p>如果<span data-katex="X"></span>满足<span data-katex="T_1"></span>公理，则它的单点集是闭集，</p>

<p>因此<span data-katex="T_3"></span>公理推出<span data-katex="T_2"></span>公理，<span data-katex="T_4"></span>公理推出<span data-katex="T_3"></span>公理，</p>

<p>然而，没有<span data-katex="T_1"></span>公理的前提下，上述关系不成立。</p>

<p><br/></p>

<p>可证，度量空间<span data-katex="(X,d)"></span>满足<span data-katex="T_i"></span>公理（<span data-katex="i=1,2,3,4"></span>）。</p>

<p><br/></p>

<p><span data-katex="X"></span>满足<span data-katex="T_3"></span>公理，当且仅当任意点<span data-katex="x"></span>和它的开邻域<span data-katex="W"></span>，存在<span data-katex="x"></span>的开邻域<span data-katex="U"></span>，</p>

<p>使得<span data-katex="\overline{U}\subseteq W"></span>。</p>

<p><span data-katex="X"></span>满足<span data-katex="T_4"></span>公理，当且仅当任意闭集<span data-katex="A"></span>和它的开邻域<span data-katex="W"></span>，有<span data-katex="A"></span>的开邻域<span data-katex="U"></span>，</p>

<p>使得<span data-katex="\overline{U}\subseteq W"></span>。</p>

<p><br/></p>

<h2><strong>可数公理</strong></h2>

<p><strong>邻域基</strong></p>

<p>设<span data-katex="x\in X"></span>，把<span data-katex="x"></span>的所有邻域的集合称为<span data-katex="x"></span>的邻域系，记作<span data-katex="\mathscr{N}(x)"></span>。</p>

<p><span data-katex="\mathscr{N}(x)"></span>的一个子集（即<span data-katex="x"></span>的一族邻域）<span data-katex="\mathscr{U}"></span>称为<span data-katex="x"></span>的一个邻域基，</p>

<p>如果<span data-katex="x"></span>的每个邻域至少包含<span data-katex="\mathscr{U}"></span>中的一个成员。</p>

<p><br/></p>

<p>若<span data-katex="\mathscr{B}"></span>是拓扑空间<span data-katex="X"></span>的拓扑基，则<span data-katex="\mathscr{U}=\{B\in \mathscr{B}|x\in B\}"></span>也是<span data-katex="x"></span>的邻域基。</p>

<p><br/></p>

<p><strong><span data-katex="C_1"></span>公理</strong></p>

<p>拓扑空间<span data-katex="X"></span>中的任一点都有可数的邻域基。</p>

<p><br/></p>

<p><strong><span data-katex="C_2"></span>公理</strong></p>

<p>拓扑空间<span data-katex="X"></span>有可数拓扑基。</p>

<p><br/></p>

<p><span data-katex="C_2"></span>空间称为完全可分空间，<span data-katex="C_2"></span>空间一定也是<span data-katex="C_1"></span>空间。</p>

<p>可证，可分度量空间是<span data-katex="C_2"></span>空间。</p>

<p><br/></p>

<h2><strong>紧致性</strong></h2>

<p><strong>收敛</strong></p>

<p>设<span data-katex="x_0,x_2,\cdots ,x_n,\cdots"></span>（可简记为<span data-katex="\{x_n\}"></span>）是拓扑空间<span data-katex="X"></span>中的点的序列，</p>

<p>如果点<span data-katex="x_0\in X"></span>的任一邻域<span data-katex="U"></span>都包含<span data-katex="\{x_n\}"></span>中几乎所有项，</p>

<p>即，只有有限个<span data-katex="x_n"></span>不在<span data-katex="U"></span>中，</p>

<p>则说<span data-katex="\{x_n\}"></span>收敛到<span data-katex="x_0"></span>，记作<span data-katex="x_n\rightarrow x_0"></span>。</p>

<p><br/></p>

<p><strong>列紧性</strong></p>

<p>拓扑空间称为列紧的，如果它的每个序列有收敛的子序列。</p>

<p><br/></p>

<p><strong>覆盖</strong></p>

<p>设<span data-katex="\mathscr{C}\subseteq{2^X}"></span>是拓扑空间<span data-katex="X"></span>的子集族，</p>

<p>称<span data-katex="\mathscr{C}"></span>是<span data-katex="X"></span>的一个覆盖，如果<span data-katex="\;{\tiny\begin{matrix} \\ \normalsize \cup \\ ^{\scriptsize C\in \mathscr{C} }\end{matrix}}\;C=X"></span>。</p>

<p>如果覆盖<span data-katex="\mathscr{C}"></span>的每个成员都是开（闭）集，则称<span data-katex="\mathscr{C}"></span>为开（闭）覆盖。</p>

<p>如果覆盖<span data-katex="\mathscr{C}"></span>只包含有限个成员，则称<span data-katex="\mathscr{C}"></span>是一个有限覆盖。</p>

<p>如果<span data-katex="\mathscr{C}"></span>的一个子族<span data-katex="\mathscr{A}\subseteq \mathscr{C}"></span>本身也构成<span data-katex="X"></span>的覆盖，就称<span data-katex="\mathscr{A}"></span>是<span data-katex="\mathscr{C}"></span>的子覆盖。</p>

<p><br/></p>

<p><strong>粘接引理</strong></p>

<p>设<span data-katex="\{A_1,A_2,\cdots ,A_n\}"></span>是<span data-katex="X"></span>的一个有限闭覆盖，</p>

<p>如果映射<span data-katex="f:X\rightarrow Y"></span>在每个<span data-katex="A_i"></span>上的限制都是连续的，</p>

<p>则<span data-katex="f"></span>是连续的。</p>

<p><br/></p>

<p><strong>紧致性</strong></p>

<p>拓扑空间称为紧致的，如果它的每个开覆盖都有有限的子覆盖。</p>

<p><br/></p>

<p>可证，紧致<span data-katex="C_1"></span>空间是列紧的，列紧度量空间是紧致的。</p>

<p>对于度量空间来说，它是列紧的当且仅当它是紧致的。</p>

<p><br/></p>

<p><strong>紧致子集</strong></p>

<p>一个拓扑空间<span data-katex="X"></span>的子集<span data-katex="A"></span>如果作为子空间是紧致的，就称为<span data-katex="X"></span>的紧致子集。</p>

<p>可证，紧致空间的闭子集紧致，紧致空间在连续映射下的像也紧致。</p>

<p>定义在紧致空间上的连续函数有界。</p>

<p><br/></p>

<h2><strong>连通性和道路连通性</strong></h2>

<p><strong>连通性</strong></p>

<p>拓扑空间<span data-katex="X"></span>称为连通的，如果它不能分解为两个非空不想交开集的并。</p>

<p><br/></p>

<p>连通空间在连续映射下的像也是连通的。</p>

<p>连通空间上的连续函数可以取到一切中间值。</p>

<p><br/></p>

<p>若<span data-katex="X"></span>有一个连通的稠密子集，则<span data-katex="X"></span>连通。</p>

<p><br/></p>

<p>如果<span data-katex="X"></span>有一个连通覆盖<span data-katex="\mathscr{C}"></span>（<span data-katex="\mathscr{C}"></span>中每个成员都连通），</p>

<p>并且<span data-katex="X"></span>有一个连通子集<span data-katex="A"></span>它与<span data-katex="\mathscr{C}"></span>中每个成员都相交，</p>

<p>则<span data-katex="X"></span>连通。</p>

<p><br/></p>

<p><strong>道路连通性</strong></p>

<p>设<span data-katex="X"></span>是拓扑空间，从单位闭区间<span data-katex="I=[0,1]"></span>到<span data-katex="X"></span>的一个连续映射<span data-katex="a:I\rightarrow X"></span>，</p>

<p>称为<span data-katex="X"></span>上的一条道路。</p>

<p>把点<span data-katex="a(0)"></span>和<span data-katex="a(1)"></span>分别称为<span data-katex="a"></span>的起点和终点，统称为端点。</p>

<p><br/></p>

<p>道路是指映射本身，而不是它的像集。</p>

<p>事实上，可能有许多不同道路，它们的像集完全相同。</p>

<p><br/></p>

<p>如果道路<span data-katex="a:I\rightarrow X"></span>是常值映射，即<span data-katex="a(I)"></span>是一个点，就称为点道路。</p>

<p>点道路完全被像点<span data-katex="x"></span>决定，记为<span data-katex="e_x"></span>。</p>

<p>起点与终点重合的道路，称为闭路，点道路是一个闭路。</p>

<p><br/></p>

<p>道路有两种运算：逆和乘积。</p>

<p>一条道路<span data-katex="a:I\rightarrow X"></span>的逆也是<span data-katex="X"></span>上的道路，记作<span data-katex="\overline{a}"></span>，</p>

<p>规定<span data-katex="\overline{a}(t)=a(1-t)"></span>，<span data-katex="\forall t\in I"></span>。</p>

<p><span data-katex="X"></span>上的两条道路<span data-katex="a"></span>与<span data-katex="b"></span>，如果满足<span data-katex="a(1)=b(0)"></span>，则可规定它们的乘积<span data-katex="ab"></span>，</p>

<p>它也是<span data-katex="X"></span>上的道路，规定为</p>

<p><span data-katex="ab(t)=a(2t)"></span>，<span data-katex="0\leqslant t\leqslant 1/2"></span></p>

<p><span data-katex="ab(t)=b(2t-1)"></span>，<span data-katex="1/2\leqslant t\leqslant 1"></span></p>

<p>由粘接引理可证，<span data-katex="ab"></span>是连续的。</p>

<p><br/></p>

<p>拓扑空间<span data-katex="X"></span>称为道路连通的，</p>

<p>如果<span data-katex="\forall x,y\in X"></span>存在<span data-katex="X"></span>中分别以<span data-katex="x"></span>和<span data-katex="y"></span>为起点和终点的道路。</p>

<p><br/></p>

<p>道路连通空间一定连通。</p>

<p>道路连通空间在连续映射下的像也是道路连通的。</p>

<p><br/></p>

<h2><strong>商空间</strong></h2>

<p><strong>商拓扑</strong></p>

<p>一般的，一个集合<span data-katex="X"></span>上如果有等价关系<span data-katex="\sim"></span>，相应的等价类的集合记作<span data-katex="X/\sim"></span>，</p>

<p>称为<span data-katex="X"></span>关于<span data-katex="\sim"></span>的商集。</p>

<p>把<span data-katex="X"></span>上的点，对应到它所在的等价类，得到映射<span data-katex="p:X\rightarrow X/\sim"></span>，称为粘合映射。</p>

<p><br/></p>

<p>设<span data-katex="(X,\tau)"></span>是一个拓扑空间，<span data-katex="\sim"></span>是集合<span data-katex="X"></span>上的一个等价关系，</p>

<p>规定商集<span data-katex="X/\sim"></span>上的子集族</p>

<p><span data-katex="\tilde{\tau}:=\{V\subseteq X/\sim |\ p^{-1}(V)\in \tau \}"></span></p>

<p>则可证<span data-katex="\tilde{\tau}"></span>是<span data-katex="X/\sim"></span>上的一个拓扑，</p>

<p>称为<span data-katex="\tau"></span>在<span data-katex="\sim"></span>下的商拓扑，</p>

<p>称<span data-katex="(X/\sim ,\tilde{\tau})"></span>是<span data-katex="(X,\tau )"></span>关于<span data-katex="\tau"></span>的商空间。</p>

<p><br/></p>

<p><strong>商映射</strong></p>

<p>设<span data-katex="X"></span>和<span data-katex="Y"></span>是拓扑空间，映射<span data-katex="f:X\rightarrow Y"></span>称为商映射，如果</p>

<p>（1）<span data-katex="f"></span>连续</p>

<p>（2）<span data-katex="f"></span>是满的</p>

<p>（3）设<span data-katex="B\subseteq Y"></span>，如果<span data-katex="f^{-1}(B)"></span>是<span data-katex="X"></span>的开集，则<span data-katex="B"></span>是<span data-katex="Y"></span>的开集</p>

<p>当<span data-katex="X/\sim"></span>是<span data-katex="X"></span>的一个商空间时，粘合映射<span data-katex="p:X\rightarrow X/\sim"></span>是一个商映射。</p>

<p><br/></p>

<p>任给映射<span data-katex="f:X\rightarrow Y"></span>，规定<span data-katex="X"></span>中的等价关系<span data-katex="\;{\tiny\begin{matrix} f \\ \normalsize \sim \\ ^{\scriptsize }\end{matrix}}\;"></span>如下：</p>

<p><span data-katex="\forall x,x'\in X"></span>，若<span data-katex="f(x)=f(x')"></span>，就说<span data-katex="x"></span>与<span data-katex="x'"></span>在<span data-katex="\;{\tiny\begin{matrix} f \\ \normalsize \sim \\ ^{\scriptsize }\end{matrix}}\;"></span>意义下等价，</p>

<p>记作<span data-katex="x\;{\tiny\begin{matrix} f \\ \normalsize \sim \\ ^{\scriptsize }\end{matrix}}\;x'"></span>。</p>

<p><br/></p>

<p>可见，如果<span data-katex="f:X\rightarrow Y"></span>是商映射，则<span data-katex="X/\;{\tiny\begin{matrix} f \\ \normalsize \sim \\ ^{\scriptsize }\end{matrix}}\;\cong Y"></span>。</p>

<p><br/></p>

<p>连续的满映射<span data-katex="f:X\rightarrow Y"></span>，如果它还是开映射或闭映射，则它是商映射。</p>

<p>商映射的复合也是商映射。</p>

<p><br/></p>

<h2><strong>拓扑流形与闭曲面</strong></h2>

<p><strong>拓扑流形</strong></p>

<p>一个Hausdorff空间<span data-katex="X"></span>称为<span data-katex="n"></span>维（拓扑）流形，</p>

<p>如果<span data-katex="X"></span>任一点都有一个同胚与<span data-katex="E^n"></span>或<span data-katex="E^n_+"></span>的开邻域。</p>

<p>这里<span data-katex="E^n_+"></span>是半个<span data-katex="n"></span>维欧氏空间，规定为</p>

<p><span data-katex="E^n_+:=\{(x_1,x_2,\cdots ,x_n)\in E^n\ ,x_n\geqslant 0\}"></span></p>

<p><br/></p>

<p><strong>边界点</strong></p>

<p>设<span data-katex="M"></span>是<span data-katex="n"></span>维流形，点<span data-katex="x\in M"></span>如果有同胚于<span data-katex="E^n"></span>的开邻域，</p>

<p>就称<span data-katex="x"></span>是<span data-katex="M"></span>的内点（注意，这里的内点与子集的内点不同），</p>

<p>否则就称为边界点。</p>

<p>全体内点的集合，称为<span data-katex="M"></span>的内部，它是<span data-katex="M"></span>的一个开集。</p>

<p><br/></p>

<p><strong>闭曲面</strong></p>

<p>二维流形称为曲面。</p>

<p>没有边界点的紧致连通曲面，称为闭曲面。</p>

<p><br/></p>

<h2><strong>参考</strong></h2>

<p><a href="https://book.douban.com/subject/1230382/">基础拓扑学讲义</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[专业程序猿的修炼指南]]></title>
    <link href="https://thzt.github.io/blog/2016/08/05/professional-programmer/"/>
    <updated>2016-08-05T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/08/05/professional-programmer</id>
    <content type="html"><![CDATA[<p>《理解专业程序员》一书中提到：</p>

<p>对于有些事情，似乎每个人都是专家。</p>

<p>任何人，只要智商超过80，又懂得一点什么东西，似乎都可以当教师。</p>

<p>任何人，按照广告应征，在小臂上搭一条毛巾，在美国那就是一个侍者了。</p>

<p><br/></p>

<p>编程这种行当也是如此。</p>

<p>如果某程序员说他有15年的编程经验，人们倒会觉得他简直是个智障。</p>

<p>如果他真有那么一点点智商的话，那总应该在14年前就学会全部的编程知识了呀，</p>

<p>在此之后，他就早该做腻了这一行，去换个管理呀，销售呀之类的职位了。</p>

<p><br/></p>

<p>事实上，除非你自己是一个胜任的程序员，否则也就很难衡量一个程序员的工作质量。</p>

<p>世上有很多可怜的企业，从来没能长期留住一个真正胜任的程序员，</p>

<p>因此他们也就没有一套标准来衡量程序员的专业性。</p>

<p><br/></p>

<p>况且，即使是有15年的经验，对于学习编程知识来说也不一定就够用，</p>

<p>除非这位学习者特别一心一意。</p>

<p>是的，专业和业余之间有天壤之别，我们该怎样锻炼自己呢？</p>

<p><br/></p>

<h2><strong>1. 多学习几门语言总是好的</strong></h2>

<p>语言可以影响思维，语言是表达思维的工具，</p>

<p>编程语言也是如此。</p>

<p>如果你没有这种感觉，很有可能是因为你只会一种编程语言。</p>

<p><br/></p>

<p>虽然，那些主流的编程语言，它们在计算能力上都是图灵等价的，</p>

<p>但是，在不同问题上，需要思考的“距离”是不同的。</p>

<p>用某些语言，我们会更容易想到某种方案，</p>

<p>而用另一种语言，我们几乎就难以想到它。</p>

<p><br/></p>

<p>因此，对于见多识广的人，会根据问题迅速想到适用的方案，</p>

<p>而不管是这原本是便于用哪个语言来解决的，</p>

<p>然后再落实到团队和个人，用生产环境中的语言来实现这种方案。</p>

<p><br/></p>

<p>The limits of your language are the limits of your world.</p>

<p>多学几门语言，会让我们看到更宽广的世界。</p>

<p><br/></p>

<h2><strong>2. 坚持写作</strong></h2>

<p>代码是写出来的，文章也是写出来的，</p>

<p>这种联系不是巧合。</p>

<p>“写”的能力，会在文章和代码之间相互影响。</p>

<p>说白了，我们都是在练习表达。</p>

<p><br/></p>

<p>代码的可读性，可维护性，直接关系到了软件的成本和发展趋势，</p>

<p>谁都不想维护一堆烂摊子，不是吗？</p>

<p><br/></p>

<p>写作可以锻炼这种能力，</p>

<p>让我们的思路更顺畅，去更好的组织文字，</p>

<p>用更合适的通俗易懂的方式来表达。</p>

<p>坚持写作会让我们的代码更饱满，</p>

<p>有“抒情”，有“旁白”，有“叙事”，还有“议论”。</p>

<p>而不是通篇的流水。</p>

<p><br/></p>

<p>坚持写作，会让我们成为一名有品位的程序员。</p>

<p><br/></p>

<h2><strong>3. 钻研数学</strong></h2>

<p>学数学自有其价值，并不仅仅是为了学编程。</p>

<p>但钻研数学，会让我们根深蒂固，不易受风浪影响。</p>

<p>业界的每一次浪潮，受波及的都是那些根基缥缈的人们。</p>

<p><br/></p>

<p>学好数学，至少让我们可以认识到不完全<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6%E5%BD%92%E7%BA%B3%E6%B3%95">归纳法</a>的局限性，</p>

<p>学好数学，至少让我们可以认识到<a href="https://zh.wikipedia.org/wiki/%E5%93%A5%E5%BE%B7%E5%B0%94%E4%B8%8D%E5%AE%8C%E5%A4%87%E5%AE%9A%E7%90%86">形式化方法的局限性</a>，</p>

<p>学好数学，至少让我们可以认识到<a href="https://zh.wikipedia.org/wiki/%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98">计算机的局限性</a>。</p>

<p>是的，我们想知道我们不能做什么。</p>

<p><br/></p>

<p>我们还想知道哪些是等价的，</p>

<p>这个问题是一个<a href="https://zh.wikipedia.org/wiki/%E7%9F%A9%E9%98%B5">矩阵</a>乘积问题，</p>

<p>这个问题是一个DAG的<a href="https://zh.wikipedia.org/wiki/%E6%8B%93%E6%92%B2%E6%8E%92%E5%BA%8F">拓扑排序</a>问题，</p>

<p>这个问题是一个<a href="https://zh.wikipedia.org/wiki/%E4%B8%8D%E5%8F%AF%E5%88%A4%E5%AE%9A%E9%97%AE%E9%A2%98%E5%88%97%E8%A1%A8">不可判定问题</a>。</p>

<p><br/></p>

<p>钻研数学，会让我们活的更笃定。</p>

<p><br/></p>

<h2><strong>4. 磨炼思路</strong></h2>

<p>真正优秀的程序员是那些专注于认识，理解，沟通和解决问题的人，</p>

<p>软件只是用来提高效率的工具而已。</p>

<p>你是否优秀，不是通过代码的行数来决定的，而是通过你的逻辑，你的思想。</p>

<p>而你的逻辑和思想，将在你所写的代码中体现。</p>

<p>——Clojure的创始人，Rich Hickey</p>

<p><br/></p>

<p>因此，我们和其他人唯一的不同就体现在思路上面，</p>

<p>我们对<a href="http://coolshell.cn/articles/10804.html">XY问题</a>是否敏感，</p>

<p>会不会避免重复劳动，有没有优先级意识，</p>

<p>怎样改善我们的环境，如何<a href="https://book.douban.com/subject/6990284/">布道</a>，</p>

<p>是不是关注工程的质量和风险。</p>

<p><br/></p>

<p>这些都是有效的思维和逻辑，是需要积累和锻炼的，</p>

<p>在遇到问题时，我们不再是无助的，而是可以“推导”出解决方案。</p>

<p>很多时候，这是制胜的唯一方法。</p>

<p><br/></p>

<p>磨炼思路，会让事情变得更清晰可解。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>我们已经听说过一万小时定律了，然而我觉得它并不靠谱，</p>

<p>并不是每个人都适合做程序员，尤其是成为专业人士，</p>

<p>就像写了这么多年作文，也无法成为作家一样。</p>

<p>我们得接受现实，做自己能力范围之内爱好的事情。</p>

<p><br/></p>

<p>如果硬要总结出编程行业门槛的话，我想应该是这样的，</p>

<p>要想学会编程，就需要我们敢于先把未知放下，等羽翼丰满后，回过头来再战。</p>

<p>Don&rsquo;t sweat the stuff you don&rsquo;t understand immediately. Keep moving!</p>

<p>Only people who die very young learn all they really need to know in kindergarten.</p>

<p><br/></p>

<h2><strong>参考</strong></h2>

<p><a href="https://book.douban.com/subject/1866824/">理解专业程序员</a></p>

<p><a href="https://book.douban.com/subject/6990284/">布道之道</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[懵逼的上同调群]]></title>
    <link href="https://thzt.github.io/blog/2016/08/02/cohomology-group/"/>
    <updated>2016-08-02T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/08/02/cohomology-group</id>
    <content type="html"><![CDATA[<script src="https://thzt.github.io/thirdpart/jQuery/jquery-1.11.1.js"></script>


<p><link href="https://thzt.github.io/thirdpart/KaTeX/katex.min.css" rel="stylesheet"/></p>

<script src="https://thzt.github.io/thirdpart/KaTeX/katex.min.js"></script>


<script src="https://thzt.github.io/javascripts/katex.js"></script>


<h2><strong>代数结构</strong></h2>

<p><strong>代数运算</strong></p>

<p>设<span data-katex="A"></span>为集合，函数<span data-katex="f:A\times A\rightarrow A"></span>称为<span data-katex="A"></span>上的一个二元代数运算，</p>

<p>简称二元运算。</p>

<p><br/></p>

<p>设<span data-katex="A"></span>为集合，<span data-katex="n"></span>为正整数，<span data-katex="A^n=A\times A\times \cdots \times A"></span>表示<span data-katex="A"></span>的<span data-katex="n"></span>阶笛卡尔积，</p>

<p>函数<span data-katex="f:A^n\rightarrow A"></span>称为<span data-katex="A"></span>上的一个<span data-katex="n"></span>元代数运算，简称<span data-katex="n"></span>元运算。</p>

<p>如果<span data-katex="f"></span>是<span data-katex="A"></span>上的运算，也可以称<span data-katex="A"></span>在运算<span data-katex="f"></span>下是封闭的。</p>

<p><br/></p>

<p><strong>单位元和零元</strong></p>

<p>设<span data-katex="\circ"></span>为集合<span data-katex="A"></span>上的二元运算，</p>

<p>若存在<span data-katex="e_l\in A"></span>（或<span data-katex="e_r\in A"></span>）使得<span data-katex="\forall x\in A"></span>都有<span data-katex="e_l\circ x=x"></span>（或<span data-katex="x\circ e_r=x"></span>），</p>

<p>则称<span data-katex="e_l"></span>（或<span data-katex="e_r"></span>）是<span data-katex="A"></span>中关于<span data-katex="\circ"></span>运算的左（或右）单位元。</p>

<p>若<span data-katex="e\in A"></span>关于<span data-katex="\circ"></span>运算既为左单位元又为右单位元，则称<span data-katex="e"></span>为<span data-katex="A"></span>中关于<span data-katex="\circ"></span>运算的单位元。</p>

<p><br/></p>

<p>若存在<span data-katex="\theta_l\in A"></span>（或<span data-katex="\theta_r\in A"></span>）使得<span data-katex="\forall x\in A"></span>都有<span data-katex="\theta_l\circ x=\theta_l"></span>（或<span data-katex="x\circ \theta_r=\theta_r"></span>），</p>

<p>则称<span data-katex="\theta_l"></span>（或<span data-katex="\theta_r"></span>）是<span data-katex="A"></span>中关于<span data-katex="\circ"></span>运算的左（或右）零元。</p>

<p>若<span data-katex="\theta\in A"></span>关于<span data-katex="\circ"></span>运算既为左零元又为右零元，则称<span data-katex="e"></span>为<span data-katex="A"></span>中关于<span data-katex="\circ"></span>运算的零元。</p>

<p><br/></p>

<p>可证，</p>

<p>如果集合<span data-katex="A"></span>中的任意元素，关于<span data-katex="\circ"></span>运算既有左单位元，又有右单位元，则左单位元等于右单位元，且是<span data-katex="A"></span>中唯一的单位元。</p>

<p>如果集合<span data-katex="A"></span>中的任意元素，关于<span data-katex="\circ"></span>运算既有左零元，又有右零元，则左零元等于右零元，且是<span data-katex="A"></span>中唯一的零元。</p>

<p><br/></p>

<p><strong>逆元</strong></p>

<p>设<span data-katex="\circ"></span>为集合<span data-katex="A"></span>上的二元运算，<span data-katex="e\in A"></span>是关于<span data-katex="\circ"></span>运算的单位元。</p>

<p>对于<span data-katex="x\in A"></span>，若存在<span data-katex="y_l\in A"></span>（或<span data-katex="y_r\in A"></span>）使得<span data-katex="y_l\circ x=e"></span>（或<span data-katex="x\circ y_r=e"></span>），</p>

<p>则称<span data-katex="y_l"></span>（或<span data-katex="y_r"></span>）是<span data-katex="x"></span>关于<span data-katex="\circ"></span>运算的左（或右）逆元。</p>

<p>若<span data-katex="y\in A"></span>既是<span data-katex="x"></span>关于<span data-katex="\circ"></span>运算的左逆元，又是<span data-katex="x"></span>关于<span data-katex="\circ"></span>运算的右逆元，</p>

<p>则称<span data-katex="y"></span>是<span data-katex="x"></span>关于<span data-katex="\circ"></span>运算的逆元。</p>

<p><br/></p>

<p>可证，如果集合<span data-katex="A"></span>中的任意元素，关于<span data-katex="\circ"></span>运算既有左逆元，又有右逆元，则左逆元等于右逆元，且是该元素唯一的逆元。</p>

<p><br/></p>

<p><strong>代数系统</strong></p>

<p>一个代数系统是一个三元组<span data-katex="V=\left \langle A,\Omega ,K \right \rangle"></span>，</p>

<p>其中<span data-katex="A"></span>是一个非空的对象集合，称为<span data-katex="V"></span>的载体，</p>

<p><span data-katex="\Omega"></span>是一个非空的运算集合，即<span data-katex="\Omega=\;{\tiny\begin{matrix}\infty\\ \normalsize \cup \\ ^{\scriptsize j=1}\end{matrix}}\;\Omega_j"></span>，<span data-katex="\Omega_j"></span>是<span data-katex="A"></span>上所有<span data-katex="j"></span>元运算的集合，</p>

<p><span data-katex="K\subseteq A"></span>是代数常数的集合。</p>

<p><br/></p>

<p>对于任何代数常数<span data-katex="k\in K"></span>，可以把<span data-katex="k"></span>看成<span data-katex="A"></span>上的零元运算，</p>

<p>这时可将代数系统<span data-katex="V"></span>写作<span data-katex="\left \langle A,\Omega \right \rangle"></span>，</p>

<p>这时<span data-katex="\Omega=\;{\tiny\begin{matrix}\infty\\ \normalsize \cup \\ ^{\scriptsize j=0}\end{matrix}}\;\Omega_j"></span>，<span data-katex="\Omega_0=K"></span>。</p>

<p><br/></p>

<p><strong>同类型的代数系统</strong></p>

<p>设<span data-katex="V_1=\left \langle A,o_1,o_2,\cdots,o_r \right \rangle"></span>，<span data-katex="V_2=\left \langle B,\overline{o_1},\overline{o_2},\cdots,\overline{o_r} \right \rangle"></span>是具有<span data-katex="r"></span>个运算的代数系统，<span data-katex="r\geqslant 1"></span>。</p>

<p>若对于<span data-katex="i=1,2,\cdots ,r"></span>，<span data-katex="o_i"></span>和<span data-katex="\overline{o_i}"></span>具有同样的元数，</p>

<p>则称<span data-katex="V_1"></span>和<span data-katex="V_2"></span>是同类型的代数系统。</p>

<p><br/></p>

<p><strong>子代数</strong></p>

<p>设<span data-katex="V=\left \langle A,o_1,o_2,\cdots,o_r \right \rangle"></span>是代数系统，<span data-katex="B"></span>是<span data-katex="A"></span>的非空子集，</p>

<p>若<span data-katex="B"></span>对<span data-katex="V"></span>中所有的运算封闭，则称<span data-katex="V'=\left \langle B,o_1,o_2,\cdots,o_r \right \rangle"></span>是<span data-katex="V"></span>的子代数系统，</p>

<p>简称子代数。</p>

<p><br/></p>

<p>当<span data-katex="B"></span>是<span data-katex="A"></span>的真子集时，称<span data-katex="V'"></span>是<span data-katex="V"></span>的真子代数。</p>

<p><br/></p>

<p><strong>同态与同构</strong></p>

<p>设<span data-katex="V_1=\left \langle A,o_1,o_2,\cdots,o_r \right \rangle"></span>，<span data-katex="V_2=\left \langle B,\overline{o_1},\overline{o_2},\cdots,\overline{o_r} \right \rangle"></span>是同类型的代数系统，</p>

<p>对于<span data-katex="i=1,2,\cdots ,r"></span>，<span data-katex="o_i"></span>和<span data-katex="\overline{o_i}"></span>是<span data-katex="k_i"></span>元运算，</p>

<p>函数<span data-katex="\varphi :A\rightarrow B"></span>对于所有的运算<span data-katex="o_i"></span>，<span data-katex="\overline{o_i}"></span>都有，</p>

<p><span data-katex="\varphi(o_i(x_1,x_2,\cdots ,x_{k_i}))=\overline{o_i}(\varphi(x_1),\varphi(x_2),\cdots ,\varphi(x_{k_i}))"></span></p>

<p>则称<span data-katex="\varphi"></span>是代数系统<span data-katex="V_1"></span>到<span data-katex="V_2"></span>的同态映射，简称同态。</p>

<p><br/></p>

<p>若<span data-katex="\varphi"></span>是满射，则称<span data-katex="\varphi"></span>是满同态，</p>

<p>若<span data-katex="\varphi"></span>是单射，则称<span data-katex="\varphi"></span>是单同态，</p>

<p>若<span data-katex="\varphi"></span>是双射，则称<span data-katex="\varphi"></span>是同构，</p>

<p>若<span data-katex="V_1=V_2"></span>，则称<span data-katex="\varphi"></span>是自同态，若<span data-katex="\varphi"></span>又是双射，则称<span data-katex="\varphi"></span>是自同构。</p>

<p><br/></p>

<p><strong>同态像</strong></p>

<p>设<span data-katex="V_1=\left \langle A,o_1,o_2,\cdots,o_r \right \rangle"></span>，<span data-katex="V_2=\left \langle B,\overline{o_1},\overline{o_2},\cdots,\overline{o_r} \right \rangle"></span>是同类型的代数系统，</p>

<p>对于<span data-katex="i=1,2,\cdots ,r"></span>，<span data-katex="o_i"></span>和<span data-katex="\overline{o_i}"></span>是<span data-katex="k_i"></span>元运算，</p>

<p><span data-katex="\varphi :A\rightarrow B"></span>是<span data-katex="V_1"></span>到<span data-katex="V_2"></span>的同态，</p>

<p>则<span data-katex="\varphi(A)"></span>关于<span data-katex="V_2"></span>中的运算构成了一个代数系统，且是<span data-katex="V_2"></span>的子代数，</p>

<p>称为<span data-katex="V_1"></span>在<span data-katex="\varphi"></span>下的同态像。</p>

<p><br/></p>

<p><strong>同余关系</strong></p>

<p>设代数系统<span data-katex="V=\left \langle A,o_1,o_2,\cdots,o_r \right \rangle"></span>，其中<span data-katex="o_i"></span>是<span data-katex="k_i"></span>元运算，</p>

<p>关系<span data-katex="\sim"></span>是<span data-katex="A"></span>上的等价关系，</p>

<p>任取<span data-katex="A"></span>上<span data-katex="2k_i"></span>个元素，<span data-katex="a_1,a_2,\cdots ,a_{k_i}"></span>和<span data-katex="b_1,b_2,\cdots ,b_{k_i}"></span>，</p>

<p>如果对<span data-katex="j=1,2,\cdots ,k_i"></span>，<span data-katex="a_j\sim b_j"></span>成立，就有</p>

<p><span data-katex="o_i(a_1,a_2,\cdots ,a_{k_i})\sim o_i(b_1,b_2,\cdots ,b_{k_i})"></span></p>

<p>则称等价关系\sim"></span>对运算<span data-katex="o_i"></span>具有置换性质。</p>

<p><br/></p>

<p>如果等价关系<span data-katex="\sim"></span>对<span data-katex="V"></span>中的所有运算都具有置换性质，</p>

<p>则称关系<span data-katex="\sim"></span>是<span data-katex="V"></span>上的同余关系，</p>

<p>称<span data-katex="A"></span>中关于<span data-katex="\sim"></span>的等价类为<span data-katex="V"></span>上的同余类。</p>

<p><br/></p>

<p><strong>商代数</strong></p>

<p>设代数系统<span data-katex="V=\left \langle A,o_1,o_2,\cdots,o_r \right \rangle"></span>，其中<span data-katex="o_i"></span>是<span data-katex="k_i"></span>元运算，</p>

<p>关系<span data-katex="\sim"></span>是<span data-katex="V"></span>上的同余关系，</p>

<p><span data-katex="V"></span>关于同余关系<span data-katex="\sim"></span>的商代数记作<span data-katex="V/\sim =\left \langle A/\sim ,\overline{o_1},\overline{o_2},\cdots,\overline{o_r} \right \rangle"></span>，</p>

<p>其中<span data-katex="A/\sim"></span>是<span data-katex="A"></span>关于同余关系<span data-katex="\sim"></span>的商集。</p>

<p><br/></p>

<p>对于<span data-katex="i=1,2,\cdots ,r"></span>，运算<span data-katex="\overline{o_i}"></span>规定为：</p>

<p><span data-katex="\forall [a_1],[a_2],\cdots ,[a_{k_i}]\in A/\sim"></span>，有</p>

<p><span data-katex="\overline{o_i}([a_1],[a_2],\cdots ,[a_{k_i}])=[o_i(a_1,a_2,\cdots ,a_{k_i})]"></span>。</p>

<p><br/></p>

<p><strong>同态导出的等价关系</strong></p>

<p>若<span data-katex="\varphi :A\rightarrow B"></span>是<span data-katex="V_1"></span>到<span data-katex="V_2"></span>的同态，</p>

<p>定义等价关系<span data-katex="x\sim y"></span>当且仅当<span data-katex="\varphi(x)=\varphi(y)"></span>，<span data-katex="\forall x,y\in A"></span>。</p>

<p>则称，该等价关系是同态<span data-katex="\varphi"></span>导出的等价关系。</p>

<p><br/></p>

<p>可证，同态<span data-katex="\varphi"></span>导出的等价关系是<span data-katex="V_1"></span>上的同余关系。</p>

<p><br/></p>

<p><strong>自然映射</strong></p>

<p>设<span data-katex="V=\left \langle A,o_1,o_2,\cdots,o_r \right \rangle"></span>是代数系统，</p>

<p>其中<span data-katex="o_i"></span>是<span data-katex="k_i"></span>元运算，<span data-katex="i=1,2,\cdots ,r"></span>，<span data-katex="\sim"></span>是<span data-katex="V"></span>上的同余关系，</p>

<p>则自然映射<span data-katex="g:A\rightarrow A/\sim"></span>，<span data-katex="\forall a\in A,\ g(a)=[a]"></span>，</p>

<p>是从<span data-katex="V"></span>到<span data-katex="V/\sim"></span>上的同态映射。</p>

<p><br/></p>

<p><strong>同态基本定理</strong></p>

<p>设<span data-katex="V_1=\left \langle A,o_1,o_2,\cdots,o_r \right \rangle"></span>，<span data-katex="V_2=\left \langle B,\overline{o_1},\overline{o_2},\cdots,\overline{o_r} \right \rangle"></span>是同类型的代数系统，</p>

<p>对于<span data-katex="i=1,2,\cdots ,r"></span>，<span data-katex="o_i"></span>和<span data-katex="\overline{o_i}"></span>是<span data-katex="k_i"></span>元运算，</p>

<p><span data-katex="\varphi :A\rightarrow B"></span>是<span data-katex="V_1"></span>到<span data-katex="V_2"></span>的同态，</p>

<p>关系<span data-katex="\sim"></span>是<span data-katex="\varphi"></span>导出的<span data-katex="V_1"></span>上的同余关系，</p>

<p>则<span data-katex="V_1"></span>关于同余关系<span data-katex="\sim"></span>的商代数，同构于<span data-katex="V_1"></span>在<span data-katex="\varphi"></span>下的同态像，即</p>

<p><span data-katex="V_1/\sim \ \cong \ \left \langle \varphi(A),\overline{o_1},\overline{o_2},\cdots ,\overline{o_r} \right \rangle"></span></p>

<p><br/></p>

<p>同态基本定理告诉我们，任何代数系统<span data-katex="V"></span>的商代数是它的一个同态像。</p>

<p>反之，如果<span data-katex="V'"></span>是<span data-katex="V"></span>的同态像，则<span data-katex="V'"></span>与<span data-katex="V"></span>的一个商代数同构。</p>

<p><br/></p>

<h2><strong>群结构</strong></h2>

<p><strong>半群</strong></p>

<p>设<span data-katex="\circ"></span>是集合<span data-katex="S"></span>上的二元运算，若<span data-katex="\circ"></span>运算在<span data-katex="S"></span>上是可结合的，</p>

<p>则称代数系统<span data-katex="V=\left \langle S,\circ \right \rangle"></span>是半群。</p>

<p><br/></p>

<p><strong>幺半群</strong></p>

<p>设<span data-katex="V=\left \langle S,\circ \right \rangle"></span>是半群，</p>

<p>若存在<span data-katex="e\in S"></span>为<span data-katex="V"></span>中关于运<span data-katex="\circ"></span>运算的单位元，</p>

<p>则称<span data-katex="V=\left \langle S,\circ ,e \right \rangle"></span>的幺半群。</p>

<p><br/></p>

<p><strong>群</strong></p>

<p><span data-katex="\left \langle G,\circ \right \rangle"></span>是含有一个二元运算的代数系统，</p>

<p>如果满足以下条件：</p>

<p>（1）<span data-katex="\circ"></span>运算是可结合的，</p>

<p>（2）存在<span data-katex="e\in G"></span>是关于<span data-katex="\circ"></span>运算的单位元，</p>

<p>（3）任何<span data-katex="x\in G"></span>，<span data-katex="x"></span>关于<span data-katex="\circ"></span>运算的逆元<span data-katex="x^{-1}\in G"></span>。</p>

<p>则称<span data-katex="G"></span>是一个群。</p>

<p><br/></p>

<p><strong>交换群</strong></p>

<p>若群<span data-katex="G"></span>中运算满足交换律，则称<span data-katex="G"></span>为交换群，或Abel群。</p>

<p><br/></p>

<p><strong>子群</strong></p>

<p><span data-katex="G"></span>是群，<span data-katex="H"></span>是<span data-katex="G"></span>的非空子集，若<span data-katex="H"></span>关于<span data-katex="G"></span>中的运算构成一个群，</p>

<p>则称<span data-katex="H"></span>是<span data-katex="G"></span>的子群，记为<span data-katex="H\leqslant G"></span>。</p>

<p>如果子群<span data-katex="H"></span>是<span data-katex="G"></span>的真子集，则称<span data-katex="H"></span>是<span data-katex="G"></span>的真子群，记为<span data-katex="H<G"></span>。</p>

<p><br/></p>

<p>若把群看做是具有一个可结合的二元运算，一个求逆元的一元运算，</p>

<p>和一个零元运算（二元运算的单位元）的代数系统，</p>

<p>可以证明，<span data-katex="G"></span>的子群就是代数系统<span data-katex="\left \langle G_1,\bullet,\ ^{-1},e_1 \right \rangle"></span>的子代数。</p>

<p><br/></p>

<p><strong>陪集分解</strong></p>

<p><span data-katex="G"></span>是群，<span data-katex="H"></span>是<span data-katex="G"></span>的子群，<span data-katex="a\in G"></span>，定义</p>

<p><span data-katex="Ha=\{ha|h\in H\}"></span></p>

<p>则称<span data-katex="Ha"></span>是子群<span data-katex="H"></span>在<span data-katex="G"></span>中的一个右陪集。</p>

<p><br/></p>

<p>可以证明，</p>

<p>（1）<span data-katex="He=H"></span>，</p>

<p>（2）<span data-katex="\forall A\in G,\ a\in Ha"></span>，</p>

<p>（3）<span data-katex="a\in Hb \Leftrightarrow Ha=Hb \Leftrightarrow ab^{-1}\in H"></span></p>

<p><br/></p>

<p><span data-katex="G"></span>是群，<span data-katex="H"></span>是<span data-katex="G"></span>的子群，</p>

<p>在<span data-katex="G"></span>上定义二元关系<span data-katex="R"></span>，<span data-katex="\forall a,b\in G"></span>有</p>

<p><span data-katex="aRb\Leftrightarrow ab^{-1}\in H"></span></p>

<p>则<span data-katex="R"></span>为<span data-katex="G"></span>上的等价关系，且<span data-katex="[a]_R=Ha"></span>。</p>

<p><br/></p>

<p><span data-katex="G"></span>是群，<span data-katex="H"></span>是<span data-katex="G"></span>的子群，则<span data-katex="\forall a,b\in G"></span>，</p>

<p>或者<span data-katex="Ha\cap Hb=\varnothing"></span>，或者<span data-katex="Ha=Hb"></span>，</p>

<p>且<span data-katex="\;{\tiny\begin{matrix}\\ \normalsize \cup \\ ^{\scriptsize a\in R}\end{matrix}}\;Ha=G"></span></p>

<p>因此，子群<span data-katex="H"></span>的右陪集构成了群<span data-katex="G"></span>的一个划分。</p>

<p><br/></p>

<p><strong>正规子群</strong></p>

<p><span data-katex="G"></span>是群，<span data-katex="H"></span>是<span data-katex="G"></span>的子群，若<span data-katex="\forall a\in G"></span>都有<span data-katex="Ha=aH"></span>，</p>

<p>则称<span data-katex="H"></span>是<span data-katex="G"></span>的正规子群，记为<span data-katex="H\trianglelefteq G"></span>。</p>

<p><br/></p>

<p><strong>商群</strong></p>

<p><span data-katex="G"></span>是群，<span data-katex="H"></span>是<span data-katex="G"></span>的正规子群，</p>

<p>定义<span data-katex="G/H=\{Hg|g\in G\}"></span>为<span data-katex="H"></span>在<span data-katex="G"></span>中的所有右陪集构成的集合，</p>

<p>在<span data-katex="G/H"></span>上定义运算<span data-katex="\circ"></span>，对任意的<span data-katex="Ha,Hb\in G/H"></span>，</p>

<p>有<span data-katex="Ha\circ Hb=Hab"></span>。</p>

<p>则<span data-katex="G/H"></span>关于<span data-katex="\circ"></span>运算构成了一个群，称为<span data-katex="G"></span>的商群。</p>

<p><br/></p>

<p>注：如果<span data-katex="H"></span>不是正规子群，商仍可以得到，但结果将不是群，</p>

<p>而是<a href="https://zh.wikipedia.org/wiki/%E9%BD%90%E6%80%A7%E7%A9%BA%E9%97%B4">齐次空间</a>。</p>

<p><br/></p>

<p><strong>群同态</strong></p>

<p>设<span data-katex="G_1"></span>和<span data-katex="G_2"></span>是群，<span data-katex="\varphi"></span>是<span data-katex="G_1"></span>到<span data-katex="G_2"></span>的映射，</p>

<p>若对于任意<span data-katex="x,y\in G"></span>有<span data-katex="\varphi(xy)=\varphi(x)\varphi(y)"></span>，</p>

<p>则称<span data-katex="\varphi"></span>是群<span data-katex="G_1"></span>到<span data-katex="G_2"></span>的同态映射，简称同态。</p>

<p><br/></p>

<p>若把群看做是具有一个可结合的二元运算，一个求逆元的一元运算，</p>

<p>和一个零元运算（二元运算的单位元）的代数系统，</p>

<p>则上述定义的群同态，就是代数系统<span data-katex="\left \langle G_1,\bullet,\ ^{-1},e_1 \right \rangle"></span></p>

<p>到<span data-katex="\left \langle G_2,\bullet,\ ^{-1},e_2 \right \rangle"></span>的同态。</p>

<p><br/></p>

<p><strong>同态核与同态像</strong></p>

<p>设<span data-katex="\varphi :G_1\rightarrow G_2"></span>是群<span data-katex="G_1"></span>到<span data-katex="G_2"></span>的同态，则</p>

<p><span data-katex="ker\ \varphi=\{x|x\in G\wedge \varphi(x)=e_2\}"></span></p>

<p><span data-katex="im\ \varphi=\{\varphi(x)|x\in G_1\}"></span></p>

<p><br/></p>

<p>可证，同态核<span data-katex="ker\ \varphi"></span>是<span data-katex="G_1"></span>的正规子群，</p>

<p>而同态像<span data-katex="im\ \varphi"></span>是<span data-katex="G_2"></span>的子群。</p>

<p><br/></p>

<p><strong>群同态基本定理</strong></p>

<p>设<span data-katex="G"></span>是群，<span data-katex="H"></span>是<span data-katex="G"></span>的正规子群，则<span data-katex="G"></span>的商群<span data-katex="G/H"></span>是<span data-katex="G"></span>的同态像。</p>

<p>不难看出，群同态基本定理就是一般代数系统同态基本定理的特例。</p>

<p><br/></p>

<p>特别的，如果<span data-katex="\varphi :G_1\rightarrow G_2"></span>是群<span data-katex="G_1"></span>到<span data-katex="G_2"></span>的同态，</p>

<p>则<span data-katex="G_1/(ker\ \varphi)\ \cong\ im\ \varphi"></span>。</p>

<p><br/></p>

<h2><strong>链复形与同调群</strong></h2>

<p><strong>链复形</strong></p>

<p>在数学上，同调代数领域中的一个链复形<span data-katex="(A_\bullet  ,d_\bullet )"></span>，</p>

<p>是一个交换群或者模的序列，<span data-katex="A_0,A_1,A_2,\cdots"></span>，</p>

<p>通过一系列同态<span data-katex="d_n:A_n\rightarrow A_{n-1}"></span>相连，</p>

<p>使得每两个接连的映射复合为零，即<span data-katex="\forall n,\ d_n\circ d_{n+1}=0"></span>。</p>

<p><br/></p>

<p>它们常写作如下形式：</p>

<p><span data-katex="\cdots \longrightarrow A_{n+1}\;{\tiny\begin{matrix}d_{n+1}\\ \normalsize \longrightarrow \\ ^{\scriptsize }\end{matrix}}\;A_n\;{\tiny\begin{matrix}d_n\\ \normalsize \longrightarrow \\ ^{\scriptsize }\end{matrix}}\;\cdots\;{\tiny\begin{matrix}d_2\\ \normalsize \longrightarrow \\ ^{\scriptsize }\end{matrix}}\;A_1\;{\tiny\begin{matrix}d_1\\ \normalsize \longrightarrow \\ ^{\scriptsize }\end{matrix}}\;A_0\;{\tiny\begin{matrix}d_0\\ \normalsize \longrightarrow \\ ^{\scriptsize }\end{matrix}}\;0"></span></p>

<p><br/></p>

<p><strong>同调群</strong></p>

<p>定义链复形的同调群为<span data-katex="H_n(A_\bullet):=Ker(d_n)/Im(d_{n+1})"></span>，</p>

<p>当所有同调群为零时，此链复形为正合的。</p>

<p><br/></p>

<p><strong>上链复形</strong></p>

<p>链复形概念的一个变种是上链复形。</p>

<p>一个上链复形<span data-katex="(A^\bullet  ,d^\bullet )"></span>，是一个交换群或者模的序列<span data-katex="A^0,A^1,A^2,\cdots"></span>，</p>

<p>由一系列同态<span data-katex="d^n:A^n\rightarrow A^{n+1}"></span>相连，</p>

<p>使得任何两个接连的映射复合为零，即<span data-katex="\forall n,\ d^{n+1}\circ d^n=0"></span>。</p>

<p><span data-katex="0\longrightarrow A^0\;{\tiny\begin{matrix}d^0\\ \normalsize \longrightarrow \\ ^{\scriptsize }\end{matrix}}\;A^1\;{\tiny\begin{matrix}d^1\\ \normalsize \longrightarrow \\ ^{\scriptsize }\end{matrix}}\;\cdots\;{\tiny\begin{matrix}d^{n-1}\\ \normalsize \longrightarrow \\ ^{\scriptsize }\end{matrix}}\;A^n\;{\tiny\begin{matrix}d^n\\ \normalsize \longrightarrow \\ ^{\scriptsize }\end{matrix}}\;A^{n+1}\longrightarrow \cdots"></span></p>

<p><br/></p>

<p><strong>上同调群</strong></p>

<p>定义上链复形的上同调群为<span data-katex="H^n(A^\bullet):=Ker(d^n)/Im(d^{n-1})"></span>，</p>

<p>当所有上同调群为零时，此上链复形正合。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>我们看到上同调群<span data-katex="H^n(A^\bullet)"></span>，</p>

<p>是<span data-katex="Ker(d^n)"></span>关于<span data-katex="Im(d^{n-1})"></span>的商群。</p>

<p><br/></p>

<p>下面我们证明<span data-katex="Im(d^{n-1})"></span>是<span data-katex="Ker(d^n)"></span>的正规子群。</p>

<p>（1）我们先证<span data-katex="Im(d^{n-1})"></span>是<span data-katex="Ker(d^n)"></span>的子群。</p>

<p>对于上链复形，任何两个接连的映射复合为零，说明<span data-katex="Im(d^{n-1})\subseteq Ker(d^n)"></span>。</p>

<p>且<span data-katex="Im(d^{n-1})"></span>是同态像，所以<span data-katex="Im(d^{n-1})\leqslant A^n"></span>，</p>

<p>因此<span data-katex="Im(d^{n-1})"></span>关于群运算封闭，</p>

<p>所以，根据子群的定义，<span data-katex="Im(d^{n-1})\leqslant Ker(d^n)"></span>。</p>

<p><br/></p>

<p>（2）我们再证交换群的子群是正规子群。</p>

<p>因为<span data-katex="A^n"></span>是交换群，所以它的子群也是交换群。</p>

<p>而交换群的任一子群<span data-katex="H"></span>都有，<span data-katex="Ha=\{ha|h\in H\}=\{ah|h\in H\}=aH"></span>，</p>

<p>因此交换群的任一子群都是正规子群。</p>

<p><br/></p>

<p>综上，<span data-katex="Im(d^{n-1})\trianglelefteq Ker(d^n)"></span>。</p>

<p><br/></p>

<p>所以，<span data-katex="H^n(A^\bullet):=Ker(d^n)/Im(d^{n-1})"></span>构成了一个群，</p>

<p>它的元素是<span data-katex="Im(d^{n-1})"></span>的陪集，这些陪集划分了<span data-katex="Ker(d^n)"></span>。</p>

<p><br/></p>

<h2><strong>参考</strong></h2>

<p><a href="https://zh.wikipedia.org/wiki/%E5%95%86%E7%BE%A4">商群</a></p>

<p><a href="https://zh.wikipedia.org/wiki/%E7%BE%A4%E5%90%8C%E6%85%8B">群同态</a></p>

<p><a href="https://zh.wikipedia.org/wiki/%E9%93%BE%E5%A4%8D%E5%BD%A2">链复形</a></p>

<p><a href="https://book.douban.com/subject/1230394/">离散数学教程</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[可计算性理论名词释义]]></title>
    <link href="https://thzt.github.io/blog/2016/07/23/computability/"/>
    <updated>2016-07-23T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/07/23/computability</id>
    <content type="html"><![CDATA[<script src="https://thzt.github.io/thirdpart/jQuery/jquery-1.11.1.js"></script>


<p><link href="https://thzt.github.io/thirdpart/KaTeX/katex.min.css" rel="stylesheet"/></p>

<script src="https://thzt.github.io/thirdpart/KaTeX/katex.min.js"></script>


<script src="https://thzt.github.io/javascripts/katex.js"></script>


<h2><strong>部分数论函数</strong></h2>

<p><strong>二元关系</strong></p>

<p>集合<span data-katex="S"></span>和<span data-katex="T"></span>，</p>

<p><span data-katex="S\times T"></span>的元素<span data-katex="(a,b)"></span>称为有序对，</p>

<p><span data-katex="S\times T"></span>的子集称为从<span data-katex="S"></span>到<span data-katex="T"></span>的二元关系，</p>

<p>从<span data-katex="S"></span>到<span data-katex="S"></span>的二元关系，称为<span data-katex="S"></span>上的二元关系。</p>

<p><br/></p>

<p><strong>定义域和值域</strong></p>

<p>设<span data-katex="R"></span>是从<span data-katex="S"></span>到<span data-katex="T"></span>的二元关系，</p>

<p>则称<span data-katex="R"></span>的定义域为<span data-katex="dom\ R=\{a|\exists b\ (a,b)\in R\}"></span>，</p>

<p><span data-katex="R"></span>的值域为<span data-katex="ran\ R=\{b|\exists a\ (a,b)\in R\}"></span>。</p>

<p><br/></p>

<p><strong>象</strong></p>

<p><span data-katex="A\subseteq S"></span>，则称<span data-katex="A"></span>在<span data-katex="R"></span>下的象为，</p>

<p><span data-katex="R(A)=\{b|\exists a\ (a\in A \wedge (a,b)\in R)\}"></span>，</p>

<p>特别的，如果<span data-katex="a\in A"></span>，那么把<span data-katex="\{a\}"></span>在<span data-katex="R"></span>下的象简记为<span data-katex="a"></span>在<span data-katex="R"></span>下的象，记为<span data-katex="R(a)"></span>。</p>

<p>即，<span data-katex="R(a)=\{b|(a,b)\in R\}"></span></p>

<p><br/></p>

<p><strong>部分函数</strong></p>

<p>如果<span data-katex="f"></span>是从<span data-katex="S"></span>到<span data-katex="T"></span>的二元关系，且<span data-katex="\forall a\in S"></span>，<span data-katex="f(a)=\varnothing"></span>或<span data-katex="\{b\}"></span>，</p>

<p>则称<span data-katex="f"></span>是从<span data-katex="S"></span>到<span data-katex="T"></span>的部分函数，或<span data-katex="S"></span>上的部分函数。</p>

<p>若<span data-katex="f(a)=\{b\}"></span>，则称<span data-katex="f(a)"></span>有定义，记为<span data-katex="f(a)\downarrow"></span>，</p>

<p><span data-katex="b"></span>称为<span data-katex="f"></span>在<span data-katex="a"></span>点的函数值，记为<span data-katex="f(a)=b"></span>，</p>

<p>若<span data-katex="f(a)=\varnothing"></span>，则称<span data-katex="f(a)"></span>无定义，记为<span data-katex="f(a)\uparrow"></span>。</p>

<p><br/></p>

<p><strong>全函数</strong></p>

<p>如果<span data-katex="\forall a\in S"></span>都有<span data-katex="f(a)\downarrow"></span>，即<span data-katex="dom\ f=S"></span>，则称<span data-katex="f"></span>是<span data-katex="S"></span>上的全函数，</p>

<p>此时，可以记为<span data-katex="f:S\rightarrow T"></span>。</p>

<p><br/></p>

<p><strong><span data-katex="n"></span>元部分函数</strong></p>

<p>设<span data-katex="f"></span>是笛卡尔积<span data-katex="S_1\times S_2\times \cdots \times S_n"></span>上的部分函数，</p>

<p>则通常把<span data-katex="f((a_1,a_2,\cdots ,a_n))"></span>，简记为<span data-katex="f(a_1,a_2,\cdots ,a_n)"></span>。</p>

<p><br/></p>

<p>集合<span data-katex="S^n=S\times S\times \cdots \times S"></span>上的部分函数，称为<span data-katex="S"></span>上的<span data-katex="n"></span>元部分函数。</p>

<p>自然数集<span data-katex="N=\{0,1,2,\cdots \}"></span>，从<span data-katex="N^n"></span>到<span data-katex="N"></span>的部分函数，称为<span data-katex="n"></span>元部分数论函数。</p>

<p>下文中提到的函数，默认为数论函数。</p>

<p><br/></p>

<p><strong>字函数</strong></p>

<p>字母表是一个非空有穷集合，</p>

<p>设<span data-katex="A"></span>是一个字母表，<span data-katex="A"></span>中元素的有穷序列<span data-katex="w=(a_1,a_2,\cdots ,a_m)"></span>称为<span data-katex="A"></span>上的字符串或字，</p>

<p>简记为<span data-katex="w=a_1a_2\cdots a_m"></span>。</p>

<p><span data-katex="w"></span>中符号的个数，称为字符串的长度，记为<span data-katex="|w|"></span>。</p>

<p>我们用<span data-katex="\epsilon"></span>表示空串，它不包含任何符号，是唯一的长度为<span data-katex="0"></span>的字符串。</p>

<p><br/></p>

<p><span data-katex="A"></span>上字符串的全体，记为<span data-katex="A^*"></span>。</p>

<p>设<span data-katex="u,v\in A^*"></span>，把<span data-katex="v"></span>连接在<span data-katex="u"></span>后面得到的字符串记为<span data-katex="uv"></span>。</p>

<p><br/></p>

<p>设<span data-katex="u\in A^*"></span>，规定，<span data-katex="u^0=\epsilon"></span>，<span data-katex="u^{n+1}=u^n u\ ,n\in N"></span>，</p>

<p>当<span data-katex="n>0"></span>时，<span data-katex="u^n"></span>等于<span data-katex="n"></span>个<span data-katex="u"></span>连接在一起。</p>

<p><br/></p>

<p><span data-katex="(A^*)^n"></span>到<span data-katex="A^*"></span>的部分函数，称为<span data-katex="A"></span>上的<span data-katex="n"></span>元部分字函数。</p>

<p><br/></p>

<h2><strong>程序设计语言<span data-katex="\mathscr{S}"></span></strong></h2>

<p><strong>变量</strong></p>

<p>语言<span data-katex="\mathscr{S}"></span>使用三种变量，</p>

<p>输入变量<span data-katex="X_1,X_2,\cdots"></span>，输出变量<span data-katex="Y"></span>，中间变量<span data-katex="Z_1,Z_2,\cdots"></span>，</p>

<p>变量可以取任何自然数值<span data-katex="n\in N"></span>。</p>

<p>语言还可以使用标号<span data-katex="A_1,A_2,\cdots"></span>。</p>

<p>当下标为<span data-katex="1"></span>时，可以略去。例如，<span data-katex="X_1"></span>和<span data-katex="X"></span>表示同一个变量。</p>

<p><br/></p>

<p><strong>语句</strong></p>

<p>语言<span data-katex="\mathscr{S}"></span>有三种类型的语句，</p>

<p>（1）增量语句<span data-katex="V\leftarrow V+1"></span>，表示变量V的值加<span data-katex="1"></span></p>

<p>（2）减量语句<span data-katex="V\leftarrow V-1"></span>，若变量<span data-katex="V"></span>的当前值为<span data-katex="0"></span>，则<span data-katex="V"></span>的值保持不变，否则<span data-katex="V"></span>的值减<span data-katex="1"></span>。</p>

<p>（3）条件转移语句<span data-katex="IF\ V\neq 0\ GOTO\ L"></span>，如果变量<span data-katex="V"></span>的值不等于<span data-katex="0"></span>，则下一步执行带标号<span data-katex="L"></span>的指令，否则顺序执行下一条指令。</p>

<p><br/></p>

<p><strong>执行</strong></p>

<p>开始执行程序时，中间变量和输出变量的值都为<span data-katex="0"></span>，</p>

<p>从第一条指令开始，一条一条的顺序执行，除非遇到条件转移语句，</p>

<p>当程序没有指令可执行时，计算结束，</p>

<p>此时<span data-katex="Y"></span>的值为程序的输出值。</p>

<p><br/></p>

<p>例如，</p>

<p><span data-katex="[A]\ X\leftarrow X-1"></span></p>

<p><span data-katex="\ \ \ \ Y\leftarrow Y+1"></span></p>

<p><span data-katex="\ \ \ \ IF\ X\neq 0\ GOTO\ A"></span></p>

<p>这里<span data-katex="A"></span>是第一条指令的标号，我们可以看到，这个程序计算的函数是，</p>

<p><span data-katex="f(x)=x,\ if\ x>0"></span></p>

<p><span data-katex="f(x)=1,\ else"></span></p>

<p><br/></p>

<p><strong>状态</strong></p>

<p>设<span data-katex="\sigma"></span>是形如等式<span data-katex="V=m"></span>的有穷集合，其中<span data-katex="V"></span>是一个变量，<span data-katex="m"></span>是一个数。</p>

<p>如果，</p>

<p>（1）对于每一个变量<span data-katex="V"></span>，<span data-katex="\sigma"></span>中至多含有一个等式<span data-katex="V=m"></span></p>

<p>（2）如果在程序<span data-katex="\mathscr{P}"></span>中出现变量<span data-katex="V"></span>，则<span data-katex="\sigma"></span>中必含有等式<span data-katex="V=m"></span></p>

<p>那么，称<span data-katex="\sigma"></span>是程序<span data-katex="\mathscr{P}"></span>的一个状态。</p>

<p><br/></p>

<p>状态描述程序在执行的某一步各个变量的值，</p>

<p>我们约定，如果<span data-katex="\sigma"></span>中不含关于<span data-katex="V"></span>的等式，则变量<span data-katex="V"></span>的值自动取<span data-katex="0"></span>。</p>

<p><br/></p>

<p><strong>快相</strong></p>

<p>程序的一个快相，是一个有序对<span data-katex="(i,\sigma )"></span>，</p>

<p>表示程序的当前状态为<span data-katex="\sigma"></span>，即将执行第<span data-katex="i"></span>条指令。</p>

<p><span data-katex="1\leqslant i \leqslant q"></span>，其中，<span data-katex="q"></span>是程序的长度，</p>

<p>如果<span data-katex="i=q+1"></span>，就表示程序结束，<span data-katex="(q+1,\sigma )"></span>称为程序的终点快相。</p>

<p><br/></p>

<p>除了输入变量外，所有变量值为0的状态称为初始状态，</p>

<p>如果<span data-katex="\sigma"></span>是初始状态，则称<span data-katex="(1,\sigma )"></span>是初始快相。</p>

<p><br/></p>

<p><strong>程序的计算</strong></p>

<p>设<span data-katex="s_1,s_2,\cdots"></span>是程序<span data-katex="\mathscr{P}"></span>的一个快相序列，长度为<span data-katex="k"></span>，</p>

<p>如果，</p>

<p>（1）<span data-katex="s_1"></span>是初始快相</p>

<p>（2）对于每一个<span data-katex="i(1\leqslant i<k)"></span>，<span data-katex="s_{i+1}"></span>是<span data-katex="s_i"></span>的后继</p>

<p>（3）当<span data-katex="k<\infty"></span>时，<span data-katex="s_k"></span>是终点快相</p>

<p>则称该序列是<span data-katex="\mathscr{P}"></span>的一个计算。</p>

<p><br/></p>

<h2><strong>函数的可计算性</strong></h2>

<p><strong>程序计算的函数</strong></p>

<p>设<span data-katex="\mathscr{P}"></span>是语言<span data-katex="\mathscr{S}"></span>的一个程序，<span data-katex="n"></span>是一个正整数，</p>

<p>称函数<span data-katex="\psi (x_1,x_2,\cdots ,x_n)"></span>为程序<span data-katex="\mathscr{P}"></span>计算的<span data-katex="n"></span>元部分函数，</p>

<p>如果，s_1"></span>是初始快相，其中输入变量为<span data-katex="X_1=x_1,X_2=x_2,\cdots ,X_n=x_n"></span>，输出变量为<span data-katex="Y"></span>，</p>

<p>（1）从<span data-katex="s_1"></span>开始的计算是有穷序列<span data-katex="s_1,s_2,\cdots ,s_k"></span>，则<span data-katex="\psi (x_1,x_2,\cdots ,x_n)"></span>等于<span data-katex="Y"></span>在<span data-katex="s_k"></span>中的值</p>

<p>（2）从<span data-katex="s_1"></span>开始的计算是无穷序列<span data-katex="s_1,s_2,\cdots"></span>，则<span data-katex="\psi (x_1,x_2,\cdots ,x_n)\uparrow"></span></p>

<p><br/></p>

<p><strong>部分可计算性与可计算性</strong></p>

<p>设<span data-katex="f(x_1,x_2,\cdots ,x_n)"></span>是一个部分函数，如果存在程序<span data-katex="\mathscr{P}"></span>计算<span data-katex="f"></span>，</p>

<p>则称<span data-katex="f"></span>是部分可计算的。</p>

<p><br/></p>

<p>如果一个函数，既是部分可计算的，又是全函数，则称这个函数是可计算的。</p>

<p><br/></p>

<p><strong>谓词的可计算性</strong></p>

<p>我们可以把谓词看作取值为<span data-katex="0"></span>或<span data-katex="1"></span>的全函数，</p>

<p>并把真值等同于<span data-katex="1"></span>，假值等同于<span data-katex="0"></span>。</p>

<p><br/></p>

<p>如果谓词<span data-katex="P(x_1,x_2,\cdots ,x_n)"></span>作为一个全函数是可计算的，</p>

<p>则称该谓词是可计算的。</p>

<p><br/></p>

<h2><strong>函数的递归性</strong></h2>

<p><strong>合成运算</strong></p>

<p>设<span data-katex="f"></span>是<span data-katex="k"></span>元部分函数，<span data-katex="g_1,g_2,\cdots ,g_k"></span>是<span data-katex="k"></span>个<span data-katex="n"></span>元部分递归函数，</p>

<p><span data-katex="h(x_1,\cdots ,x_n)=f(g_1(x_1,\cdots ,x_n),\cdots ,g_k(x_1,\cdots ,x_n))"></span></p>

<p>则称<span data-katex="h"></span>是由<span data-katex="f"></span>和<span data-katex="g_1,g_2,\cdots ,g_k"></span>，经过合成运算得到的。</p>

<p><br/></p>

<p>可证，如果<span data-katex="h"></span>是由（部分）可计算函数<span data-katex="f"></span>和<span data-katex="g_1,g_2,\cdots ,g_k"></span>合成得到的，</p>

<p>则<span data-katex="h"></span>也是（部分）可计算函数。</p>

<p><br/></p>

<p><strong>原始递归运算</strong></p>

<p>设<span data-katex="g"></span>是一个<span data-katex="2"></span>元全函数，<span data-katex="k"></span>是一个常数，</p>

<p><span data-katex="h(0)=k"></span></p>

<p><span data-katex="h(t+1)=g(t,h(t))"></span></p>

<p>则称<span data-katex="h"></span>是由<span data-katex="g"></span>经过原始递归运算得到的。</p>

<p><br/></p>

<p>可证，如果<span data-katex="g"></span>是可计算的，则<span data-katex="h"></span>是可计算的。</p>

<p><br/></p>

<p>设<span data-katex="f"></span>是一个<span data-katex="n"></span>元全函数，<span data-katex="g"></span>是<span data-katex="n+2"></span>元全函数，</p>

<p><span data-katex="h(x_1,\cdots ,x_n,0)=f(x_1,\cdots ,x_n)"></span></p>

<p><span data-katex="h(x_1,\cdots ,x_n,t+1)=g(t,h(x_1,\cdots ,x_n,t),x_1,\cdots ,x_n)"></span></p>

<p>则称<span data-katex="h"></span>是由<span data-katex="f"></span>和<span data-katex="g"></span>经过原始递归运算得到的。</p>

<p><br/></p>

<p>可证，如果<span data-katex="f"></span>和<span data-katex="g"></span>都是可计算的，则<span data-katex="h"></span>是可计算的。</p>

<p><br/></p>

<p><strong>原始递归函数类</strong></p>

<p>设初始函数包括，</p>

<p>（1）零函数<span data-katex="n(x)=0"></span></p>

<p>（2）后继函数<span data-katex="s(x)=x+1"></span></p>

<p>（3）投影函数<span data-katex="u^n_i(x_1,\cdots ,x_n)=x_i"></span>，<span data-katex="i\leqslant i\leqslant n"></span></p>

<p>则，由初始函数经过有限次合成运算和原始递归运算得到的函数，称为原始递归函数。</p>

<p><br/></p>

<p>可证，由原始递归函数经过合成运算或原始递归运算，得到的函数仍为原始递归函数。</p>

<p>每一个原始递归函数都是可计算的。</p>

<p><br/></p>

<p>常用原始递归函数举例，</p>

<p>常数<span data-katex="k"></span>，<span data-katex="x"></span>，<span data-katex="x+y"></span>，<span data-katex="x\cdot y"></span>，<span data-katex="x!"></span>，<span data-katex="x^y"></span>，前驱函数<span data-katex="p(x)"></span>，<span data-katex="|x-y|"></span></p>

<p><br/></p>

<p><strong>原始递归谓词</strong></p>

<p>如果一个谓词看作取值为<span data-katex="0"></span>或<span data-katex="1"></span>的全函数是原始递归的，则称该谓词是原始递归的。</p>

<p>可证，如果<span data-katex="P"></span>和<span data-katex="Q"></span>是原始递归谓词，则<span data-katex="\neg P"></span>，<span data-katex="P\wedge Q"></span>和<span data-katex="P\vee Q"></span>也是原始递归谓词。</p>

<p><br/></p>

<p><strong>极小化运算</strong></p>

<p>设<span data-katex="P(x_1,\cdots ,x_n,t)"></span>是一个谓词，</p>

<p><span data-katex="f(x_1,\cdots ,x_n)=min\ P(x_1,\cdots ,x_n,t)"></span>，</p>

<p><span data-katex="f(x_1,\cdots ,x_n)"></span>的值，或者是使<span data-katex="P(x_1,\cdots ,x_n,t)"></span>为真的<span data-katex="t"></span>的最小值，</p>

<p>或者无定义，如果不存在<span data-katex="t"></span>使得<span data-katex="P(x_1,\cdots ,x_n,t)"></span>为真。</p>

<p>其中，<span data-katex="min"></span>为极小化运算，</p>

<p>也称部分函数<span data-katex="f"></span>，是由谓词<span data-katex="P"></span>经过极小化运算得到的。</p>

<p><br/></p>

<p>设<span data-katex="g(x_1,\cdots ,x_n,t)"></span>是一个<span data-katex="n+1"></span>元全函数，</p>

<p><span data-katex="f(x_1,\cdots ,x_n)=min\ {g(x_1,\cdots ,x_n,t)=0}"></span>，</p>

<p>则称<span data-katex="f"></span>是由函数<span data-katex="g"></span>经过极小化运算得到的。</p>

<p><br/></p>

<p><strong>递归函数类</strong></p>

<p>由初始函数经过有限次合成运算，原始递归运算和极小化运算，得到的函数称为部分递归函数，</p>

<p>部分递归的全函数称为递归函数。</p>

<p><br/></p>

<p>如果一个谓词看作取值为<span data-katex="0"></span>或<span data-katex="1"></span>的全函数是递归的，则称该谓词是递归的。</p>

<p><br/></p>

<p><strong>递归性与可计算性</strong></p>

<p>可证，部分递归函数是部分可计算函数。</p>

<p>递归函数是可计算函数，递归谓词是可计算谓词。</p>

<p><br/></p>

<p>可证，原始递归函数类是可计算函数类的真子集。</p>

<p><br/></p>

<p>因为，至少存在一个Ackermann函数<span data-katex="A(k,x)"></span>是可计算的，但不是原始递归的。</p>

<p><span data-katex="A(0,x)=x+1"></span></p>

<p><span data-katex="A(k+1,0)=A(k,1)"></span></p>

<p><span data-katex="A(k+1,x+1)=A(k,A(k+1,x))"></span></p>

<p><br/></p>

<h2><strong>集合和语言的递归性</strong></h2>

<p><strong>集合识别问题</strong></p>

<p>所谓集合识别问题，是指对于给定的集合，任给一个元素，问这个元素是否属于该集合，</p>

<p>也称为集合的成员资格问题。</p>

<p><br/></p>

<p><strong>集合特征函数</strong></p>

<p>设<span data-katex="B\subseteq N"></span>，<span data-katex="B"></span>的特征函数<span data-katex="\chi _B"></span>是一个谓词，定义为，</p>

<p><span data-katex="\chi _B\equiv x\in B,\ \forall x\in N"></span>，</p>

<p>集合<span data-katex="B"></span>可以用它的特征函数表示为，<span data-katex="B=\{x\in N|\chi _B(x)\}"></span>。</p>

<p><br/></p>

<p>如果特征函数<span data-katex="\chi _B"></span>是可计算的，则成集合<span data-katex="B"></span>是递归的。</p>

<p>如果存在部分可计算函数<span data-katex="g"></span>使得<span data-katex="B=\{x\in N|g(x)\downarrow \}"></span>，</p>

<p>则称集合<span data-katex="B"></span>是递归可枚举的。</p>

<p><br/></p>

<p>可证，如果集合<span data-katex="B"></span>和<span data-katex="C"></span>都是递归的，则集合<span data-katex="\bar{B}"></span>，<span data-katex="B\cap C"></span>和<span data-katex="B\cup C"></span>都是递归的。</p>

<p>递归集一定是递归可枚举的。</p>

<p>集合<span data-katex="B"></span>是递归的，当且仅当<span data-katex="B"></span>和<span data-katex="\bar{B}"></span>都是递归可枚举的。</p>

<p>如果集合<span data-katex="B"></span>和<span data-katex="C"></span>是递归可枚举的，则集合<span data-katex="B\cap C"></span>和<span data-katex="B\cup C"></span>也是递归可枚举的。</p>

<p><br/></p>

<p><strong>语言识别问题</strong></p>

<p>设字母表<span data-katex="A=\{s_1,s_2,\cdots ,s_n\}"></span>，<span data-katex="A^*"></span>的任何子集<span data-katex="L"></span>称为<span data-katex="A"></span>上的语言。</p>

<p><span data-katex="A^*"></span>上集合的识别问题，有称为<span data-katex="A"></span>上的语言识别问题。</p>

<p><br/></p>

<p>语言的特征函数定义为，<span data-katex="\chi _L\equiv w\in L,\ \forall w\in A^*"></span>，</p>

<p>如果语言<span data-katex="L"></span>的特征函数<span data-katex="\chi _L"></span>是可计算的，则称语言<span data-katex="L"></span>是递归的。</p>

<p>如果存在<span data-katex="A"></span>上的部分可计算函数<span data-katex="g"></span>使得，<span data-katex="L=\{w\in A^*|g(w)\downarrow \}"></span>，</p>

<p>则称语言<span data-katex="L"></span>是递归可枚举的。</p>

<p><br/></p>

<p><strong>递归可枚举集</strong></p>

<p>设<span data-katex="B\subseteq N"></span>，且<span data-katex="B"></span>是递归可枚举的，</p>

<p>则存在原始递归谓词<span data-katex="R(x,t)"></span>使得，<span data-katex="B=\{x|\exists t\ R(x,t)\}"></span></p>

<p><br/></p>

<p>设<span data-katex="B"></span>是一个非空递归可枚举集，则存在原始递归函数<span data-katex="f(x)"></span>使得，</p>

<p><span data-katex="B=\{f(x)|x\in N\}"></span></p>

<p><br/></p>

<p>集合<span data-katex="B"></span>是递归可枚举的，当且仅当存在部分可计算函数<span data-katex="f(x)"></span>，使得，</p>

<p><span data-katex="B=\{f(x)|f(x)\downarrow \}"></span></p>

<p><br/></p>

<p>总之，如果<span data-katex="B"></span>非空，则以下命题是等价的，</p>

<p>（1）<span data-katex="B"></span>是递归可枚举的，即<span data-katex="B"></span>是一个部分可计算函数的定义域，</p>

<p>（2）<span data-katex="B"></span>是第一个原始递归函数的值域，</p>

<p>（3）<span data-katex="B"></span>是一个可计算函数的值域，</p>

<p>（4）<span data-katex="B"></span>是一个部分可计算函数的值域。</p>

<p><br/></p>

<h2><strong>可判定性与半可判定性</strong></h2>

<p><span data-katex="\mathscr{S}"></span>程序设计语言，递归函数，Turing机，文法等计算模型，</p>

<p>可以证明它们是等价的，即计算相同的函数类——部分可计算函数。</p>

<p>它们可以识别相同的语言类，递归可枚举语言。</p>

<p><br/></p>

<p>如果语言<span data-katex="L"></span>是递归的，那么存在一台总停机的DTM（确定型图灵机）<span data-katex="\mathscr{M}"></span>识别<span data-katex="L"></span>，</p>

<p>任给一个字符串<span data-katex="x"></span>，<span data-katex="\mathscr{M}"></span>总能在有限步内回答<span data-katex="x\in L"></span>还是<span data-katex="x\notin L"></span>，</p>

<p>因而，我们说<span data-katex="L"></span>为可判定的。</p>

<p><br/></p>

<p>如果<span data-katex="L"></span>的递归可枚举的，情况就不同了，识别<span data-katex="L"></span>的DTM可能永不停机，</p>

<p>只有当<span data-katex="x\in L"></span>时，<span data-katex="\mathscr{M}"></span>才能保证一定能在有限步内停机并接受<span data-katex="x"></span>，</p>

<p>而当<span data-katex="x\notin L"></span>时，<span data-katex="\mathscr{M}"></span>可能永不停机，</p>

<p>在这种情况下，我们不知道是暂时没有停机，还是永不停机，</p>

<p>这时，我们说<span data-katex="L"></span>是半可判定的。</p>

<p><br/></p>

<p>因此，递归语言是可判定的，而递归可枚举语言是半可判定的，</p>

<p>同样的，直观可计算函数是可计算函数，而部分可计算函数是半可计算的，</p>

<p>可计算谓词是可判定的，它定义的集合是递归的，</p>

<p>如果谓词定义的集合是递归可枚举的，则该谓词是半可判定的。</p>

<h2><strong>参考</strong></h2>

<p><a href="https://book.douban.com/subject/1310925/">可计算性与计算复杂性导引</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[挑战极限]]></title>
    <link href="https://thzt.github.io/blog/2016/07/18/overcome-the-limitation/"/>
    <updated>2016-07-18T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/07/18/overcome-the-limitation</id>
    <content type="html"><![CDATA[<p>当初，我们选择了一个喜好的领域，</p>

<p>希望有朝一日能成为专家。</p>

<p><br/></p>

<p>可是，后来才发现，</p>

<p>这个领域中已经有了一大批先行者。</p>

<p>他们的经验十分丰富，而我们没有任何优势。</p>

<p><br/></p>

<p>我们因此变得灰心丧气，迷茫怀疑，</p>

<p>觉得自己不是这块料，</p>

<p>肯定还有更好的机会等着我们。</p>

<p><br/></p>

<p>是啊，再这样下去就完了。</p>

<p><br/></p>

<h3>上限</h3>

<p>我们在入行之时就听前辈说过，</p>

<p>要想成为专家，就必须有效的训练自己一万小时，</p>

<p>于是，那段岁月真是刻骨铭心，</p>

<p>每天都在拼命学习。</p>

<p><br/></p>

<p>这样一晃就是好几年，</p>

<p>我们终于有所小成，</p>

<p>可是越努力，越能清晰发现自己能力的上限。</p>

<p><br/></p>

<p>我们可能无法变得更强了。</p>

<p>天赋使然，哪怕我们再努力。</p>

<p><br/></p>

<h3>动摇</h3>

<p>智者在这时候告诫我们，要发挥优势，</p>

<p>结合自己的优势才能找到方向。</p>

<p><br/></p>

<p>于是，我们动摇了，</p>

<p>真的该去学别的了，</p>

<p>目前这个领域果然不是我们的优势所在。</p>

<p><br/></p>

<p>某人，某某人，我们真的永远没办法超越他们，</p>

<p>所以，我们要学他们不擅长的东西，</p>

<p>用优势挑战劣势。</p>

<p><br/></p>

<h3>短暂</h3>

<p>人生是那么的短暂，</p>

<p>一万小时是如此的漫长，</p>

<p>可是青春不在，我们能有几个一万小时挥霍自如？</p>

<p><br/></p>

<p>在任何其他领域，</p>

<p>上限的问题同样会遇到，</p>

<p>优势同样还会变得不是那么明显。</p>

<p><br/></p>

<p>其他领域的专家也不容易，</p>

<p>实际上，以这样的心态，根本上也做不到。</p>

<p><br/></p>

<p>到那时候，我们又该何去何从呢？</p>

<p><br/></p>

<h3>忍耐</h3>

<p>继续保持训练吧，</p>

<p>不要因为没有明显进步而灰心丧气，</p>

<p>更不要沾沾自喜。</p>

<p><br/></p>

<p>最大化每天的收获，拼的是耐心，</p>

<p>拼的是比别人更迟的放弃。</p>

<p><br/></p>

<p>做科研工作的，未必当时看起来那么有天分，</p>

<p>是数十年的积累和努力，改变了自身。</p>

<p><br/></p>

<p>做教育工作的，成为教师未必有那么强烈的愿望，</p>

<p>是数十年的耳濡目染和刻意进取，改变了心态。</p>

<p><br/></p>

<p>拼不过天赋，只是失败者的借口而已。</p>

<p><br/></p>

<h3>埋头苦干</h3>

<p>努力和成绩并不是一个线性关系，</p>

<p>从90分到100分的努力，</p>

<p>可能十倍或百倍于0到60分的努力。</p>

<p><br/></p>

<p>坚持锻炼，触摸到天花板，</p>

<p>如果感觉到自己不再进步时，</p>

<p>很有可能是因为成绩的变化太小了。</p>

<p><br/></p>

<p>这时候，调整训练方式是对的，但是不要轻言放弃。</p>

<p>这个时候放弃，就放弃了成为专家的机会，</p>

<p>放弃了突破自己，放弃了梦想。</p>

<p><br/></p>

<p>真的，我们天生没有任何优势，</p>

<p>除了埋头苦干。</p>

<p><br/></p>

<h3>怀疑</h3>

<p>我们应该意识到危机，</p>

<p>但同样还要意识到，怀疑自己是再正常不过的心理。</p>

<p><br/></p>

<p>怀疑自己训练方式错了，</p>

<p>怀疑自己的是否不适合，</p>

<p>这都是正常的，每个人都会遇到。</p>

<p><br/></p>

<p>可是，狠下心来，不急于求成，</p>

<p>专注于自己的成长，不看外部表现，</p>

<p>就极少有人能办到。</p>

<p><br/></p>

<p>追求及格的人多了，而追求完美的人少之又少。</p>

<p><br/></p>

<h3>坚持</h3>

<p>永远不要放弃，专家是坚持到最后的人们。</p>

<p><br/></p>

<p>他们有丰富的经验，专注的训练，</p>

<p>有锲而不舍的努力，有不屈不挠的毅力。</p>

<p><br/></p>

<p>永远无法超越他们，因为弱者会动摇。</p>

<p>永远无法打败他们，因为试图打败他们的人们，先输给了自己。</p>

<p><br/></p>

<p>总之，超越自己的次数越多，对手就越少。</p>

<p><br/></p>

<h3>结语</h3>

<p>莫道君行早，更有早行人。</p>

<p>——《增广贤文》</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[重在表达]]></title>
    <link href="https://thzt.github.io/blog/2016/07/01/the-way-to-express/"/>
    <updated>2016-07-01T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/07/01/the-way-to-express</id>
    <content type="html"><![CDATA[<p>如果我们以发展的眼光来看待自身拥有的技能，</p>

<p>就会发现，</p>

<p>练习和使用是两个不同的概念。</p>

<p><br/></p>

<p>我们可以不断练习，越来越熟练，</p>

<p>还可以花时间练习新的技能。</p>

<p>我们也可以越来越会使用已经学会的技能，</p>

<p>对自己的控制能力越来越强。</p>

<p><br/></p>

<p>这其中隐含了一个客观事实在里面，</p>

<p>那就是技能是永远学不完的，</p>

<p>也永远练习不到足够熟练的程度。</p>

<p><br/></p>

<p>因此，我们就需要在练习和使用之间找到平衡，</p>

<p>什么时候增加熟练度，</p>

<p>什么时候学习新技能，</p>

<p>什么时候练习如何使用它们，</p>

<p>怎样才能做到灵活运用。</p>

<p><br/></p>

<h2><strong>能不能先上手</strong></h2>

<p>如果说计算机行业对比其他行业有门槛的话，</p>

<p>想必就只有一个了，</p>

<p>那就是，是否有能力把目前的疑问放下，以后再绕回来解决。</p>

<p><br/></p>

<p>每个概念在第一次遇到的时候，</p>

<p>是依赖于以后某个未知概念才可以理解的。</p>

<p>因此，我们要首先把它们全都装入大脑中，</p>

<p>然后等时机成熟，触类旁通。</p>

<p><br/></p>

<p>某个概念没有理解，就无法理解后续概念，</p>

<p>或者无法使用没有理解的概念，</p>

<p>这是软件从业者最大的障碍。</p>

<p><br/></p>

<p>我们可以设想这样一个场景，</p>

<p>假如我们曾经理解过，但是现在印象模糊了，</p>

<p>那么还不是一样使用它吗？</p>

<p><br/></p>

<p>直觉，和依靠不足的信息进行决策的能力，</p>

<p>也是需要锻炼的。</p>

<p><br/></p>

<h2><strong>什么是基础</strong></h2>

<p>很多人都强调基础的重要性，</p>

<p>那么什么是基础呢？</p>

<p>对软件行业来说，哪些是基础呢？</p>

<p><br/></p>

<p>基础，就是那些，</p>

<p>你感觉用不着，但如果成为专家是显然需要的知识。</p>

<p><br/></p>

<p>是的，那些用不着的知识，</p>

<p>潜移默化的影响着你，</p>

<p>影响每一招每一式的施展，</p>

<p>这才是基础。</p>

<p><br/></p>

<p>例如，我们在做Web开发，</p>

<p>那么网络技术，编译原理，算法，设计模式，等等都是基础。</p>

<p>它们能让我们跳出当前的场景看待问题。</p>

<p><br/></p>

<p>那如果我们做编译器的开发呢，</p>

<p>那么形式语言理论，语义学，类型理论，数理逻辑，等等都是基础。</p>

<p>再深入下去还有，</p>

<p>可见，基础之下还有基础，像冰山一样隐藏在水面之下。</p>

<p><br/></p>

<h2><strong>关键在哪</strong></h2>

<p>如果用一句话形容软件工程师的工作，</p>

<p>我想说，软件工程师，就是用DSL降低问题复杂度的人们。</p>

<p>各行各业解决问题的角度都有不同，</p>

<p>而软件工程师，独爱DSL——领域特定语言。</p>

<p><br/></p>

<p>既然和语言有关，那就需要很强的表达能力，</p>

<p>像优秀的作家一样，词汇量固然重要，</p>

<p>但是如果要让人耐看，就必须表达的好。</p>

<p><br/></p>

<p>因此重点在于设计这些DSL的描述方式上，</p>

<p>在于如何使用已有的知识，进行整合。</p>

<p>这是一种创造性的活动。</p>

<p><br/></p>

<p>拿个篮球活动的例子来引出问题吧，</p>

<p>我曾问过高手们一个问题，</p>

<p>“你怎样保证失误率那么低的？”</p>

<p>“两个办法，训练时努力降低失误率，比赛时，不用失误率高的动作”。</p>

<p><br/></p>

<p>这给了我很强的启示，</p>

<p>原来如何使用是一门艺术，</p>

<p>使用方式决定了最后的表现。</p>

<p><br/></p>

<h2><strong>那么路线是什么</strong></h2>

<p>综上所述，我们得到了一个从入门到成熟的行走路线，</p>

<p>首先，我们要不求甚解的往大脑中塞下很多东西，</p>

<p>并强迫自己使用，还要有足够好的恒心让自己一遍一遍重新回来琢磨它。</p>

<p><br/></p>

<p>然后，我们要向下挖掘那些看起来没用的，但成为专家显然需要的知识。</p>

<p>把这些知识放在水面下，用露出的那一点点“细枝末节”去应付浮躁的潮流。</p>

<p>这样就不会随波逐流了，水深才会心静，心静而气自闲。</p>

<p><br/></p>

<p>最后，我们把重点放在表达上，</p>

<p>不要使用那些不熟练的知识，它们是训练时攻克的目标。</p>

<p>要有能力在紧要关头只用熟练的知识解决问题。</p>

<p><br/></p>

<p>为什么会失误？是因为本来就没有多大可能它会成功。</p>

<p>那么为什么还要用它，而不去选择其他成功率高的方式？</p>

<p>因为没有成功率高的方式吗？那为什么不去训练？</p>

<p>没有什么好练的啊？把那些计划以后再练的练了吧。</p>

<p><br/></p>

<p>这样就变成了一个以训练为本，重在表达的正向循环了。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>做到随机应变，并不是一件容易的事情，</p>

<p>要么基本功太弱，要么没有控制自己的能力总是想使用不纯熟的技能。</p>

<p><br/></p>

<p>没有在比赛场上训练的选手，</p>

<p>也没有线上环境试错的码农。</p>

<p><br/></p>

<p>大家都在打基础，练表达，</p>

<p>基本功诚然重要，但是打基础大家都懂，不是盲区，</p>

<p>重在表达，就很少有人意识到了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[不动点算子与完全偏序]]></title>
    <link href="https://thzt.github.io/blog/2016/06/25/complete-partial-order/"/>
    <updated>2016-06-25T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/06/25/complete-partial-order</id>
    <content type="html"><![CDATA[<script src="https://thzt.github.io/thirdpart/jQuery/jquery-1.11.1.js"></script>


<p><link href="https://thzt.github.io/thirdpart/KaTeX/katex.min.css" rel="stylesheet"/></p>

<script src="https://thzt.github.io/thirdpart/KaTeX/katex.min.js"></script>


<script src="https://thzt.github.io/javascripts/katex.js"></script>


<h2><strong>域论模型</strong></h2>

<p>类型化lambda演算，有两个常用模型。</p>

<p>其一，域论模型。其二，递归函数论模型。</p>

<p><br/></p>

<p>在众多域论模型中，</p>

<p>主要关心的是一种具有完全偏序（complete partial order）结构的域，简称CPO。</p>

<p>研究它的主要原因是，它是带有不动点算子的模型，</p>

<p>而且它还提供了一种解释递归类型表达式的方法。</p>

<p>域论方法是递归函数论模型的基础。</p>

<p><br/></p>

<h2><strong>递归</strong></h2>

<p>加入递归之后，对表达式进行归约就可能会无限的进行下去，</p>

<p>因此将出现没有范式（normal form）的表达式。</p>

<p>于是，把每个表达式指称为一个数值，这种想法就可能有问题了。</p>

<p>下面我们引入不动点算子（fixed-point operator），用来它定义递归。</p>

<p><br/></p>

<p><span data-katex="letrec~f:\sigma=M~in~N"></span></p>

<p>它表示<span data-katex="N"></span>，但是<span data-katex="N"></span>中f的值，是等式<span data-katex="f=M"></span>的解。</p>

<p>而<span data-katex="M"></span>中可能会包含<span data-katex="f"></span>。</p>

<p><span data-katex="M"></span>的类型根据等式<span data-katex="f=M"></span>也是<span data-katex="\sigma"></span>。</p>

<p><br/></p>

<p>我们将看到，<span data-katex="letrec"></span>是<span data-katex="let"></span>与不动点算子的语法糖（syntactic sugar）。</p>

<p>首先，我们先用<span data-katex="letrec"></span>定义阶乘函数，来计算<span data-katex="5!"></span>。</p>

<p><span data-katex="letrec~f:nat\rightarrow nat=\lambda y:nat.~(if~Eq?~y~0~then~1~else~y*f(y-1))~in~f~5"></span></p>

<p><br/></p>

<p>其中<span data-katex="f"></span>是下列等式的解。</p>

<p><span data-katex="f=\lambda y:nat.~if~Eq?~y~0~then~1~else~y*f(y-1)"></span></p>

<p><br/></p>

<h2><strong>不动点算子</strong></h2>

<p>从数学的角度来看，并不是所有形如<span data-katex="f:\sigma =M"></span>的等式都有解，</p>

<p>如果有多个解，也不知道选择哪个解。</p>

<p>我们先假设每个这样的等式都有解，为此我们增加一个不动点算子来得到这个解。</p>

<p><br/></p>

<p>一般的，如果<span data-katex="F:\sigma \rightarrow \sigma"></span>是某一类型到自身的函数。</p>

<p>那么<span data-katex="F"></span>的一个不动点，是使得<span data-katex="x=F(x)"></span>的值<span data-katex="x:\sigma"></span>。</p>

<p><br/></p>

<p>经过观察我们发现，阶乘函数<span data-katex="f"></span>是以下函数的<span data-katex="F"></span>的不动点，即满足<span data-katex="f=F(f)"></span>。</p>

<p><span data-katex="F=_{def}\lambda f:nat\rightarrow nat.~\lambda y:nat.~if~Eq?~y~0~then~1~else~y*f(y-1)"></span></p>

<p>其中，<span data-katex="f:nat\rightarrow nat"></span>，<span data-katex="F:(nat\rightarrow nat)\rightarrow (nat\rightarrow nat)"></span></p>

<p><br/></p>

<p>我们定义，<span data-katex="fix_\sigma :(\sigma \rightarrow \sigma )\rightarrow \sigma"></span>，是对应于每个类型<span data-katex="\sigma"></span>的不动点算子。</p>

<p>满足的如下等式公理，</p>

<p><span data-katex="fix_\sigma =\lambda f:\sigma \rightarrow \sigma .~f(fix_\sigma f)"></span></p>

<p><br/></p>

<p>可知，对任意的<span data-katex="F:\sigma \rightarrow \sigma"></span>，<span data-katex="fix_\sigma F"></span>是<span data-katex="F"></span>的不动点，即，</p>

<p><span data-katex="fix_\sigma F=F(fix_\sigma F)"></span></p>

<p><br/></p>

<p>我们就可以用<span data-katex="let"></span>和<span data-katex="fix_\sigma"></span>表示<span data-katex="letrec"></span>了。</p>

<p><span data-katex="letrec~f:\sigma =M~in~N=_{def}let~f:\sigma =(fix_\sigma \lambda f:\sigma .~M)~in~N"></span></p>

<p><br/></p>

<h2><strong>归约</strong></h2>

<p>我们以阶乘函数为例，来说明带有不动点算子的表达式是如何归约的。</p>

<p>为了行文方便，我们省略<span data-katex="fix_{nat\rightarrow nat}"></span>的下标，直接记为<span data-katex="fix"></span>。</p>

<p>定义阶乘函数<span data-katex="fact=_{def}fix~F"></span>，其中，</p>

<p><span data-katex="F=_{def}\lambda f:nat\rightarrow nat.~\lambda y:nat.~if~Eq?~y~0~then~1~else~y*f(y-1)"></span></p>

<p><br/></p>

<p>我们来计算<span data-katex="fact~n"></span>。</p>

<p><span data-katex="fact~n=(fix~F)~n"></span></p>

<p><span data-katex="=((\lambda f:nat\rightarrow nat.~f(fix~f))~F)~n"></span></p>

<p><span data-katex="=(F~(fix~F))~n"></span></p>

<p><span data-katex="=((\lambda f:nat\rightarrow nat.~\lambda y:nat.~if~Eq?~y~0~then~1~else~y*f(y-1))~(fix~F))~n"></span></p>

<p><span data-katex="=(if~Eq?~n~0~then~1~else~n*(fix~F))~(n-1)"></span></p>

<p><br/></p>

<h2><strong>无法终止的运算</strong></h2>

<p>由于递归允许我们写出没有范式的表达式，</p>

<p>所以我们相应的必须给这样的表达式赋予含义。</p>

<p><br/></p>

<p>例如，</p>

<p><span data-katex="letrec~f:nat\rightarrow nat=\lambda x:nat.~f(x+1)~in~f~3"></span></p>

<p>尽管该表达式的类型是<span data-katex="nat"></span>，但是我们无法把它简化为一个数值。</p>

<p>所以该表达式的含义就不是一个自然数了。</p>

<p><br/></p>

<p>一方面，认为该表达式的类型是<span data-katex="nat"></span>是合理的，它是类型规则的推导结论。</p>

<p>另一方面，如果我们说该表达式的值是『未定义的』，</p>

<p>那么<span data-katex="f"></span>的语义就变成了部分函数（partial function）。</p>

<p><br/></p>

<p>我们不如给自然数集附加一个值<span data-katex="\perp _{nat}"></span>，</p>

<p>用来表示类型<span data-katex="nat"></span>上无法终止的运算（nonterminating computation）。</p>

<p>这给了我们一个把部分函数看成完全函数（total function）的方法。</p>

<p><br/></p>

<h2><strong>CPO</strong></h2>

<p><strong>偏序</strong></p>

<p>一个偏序（partial order）<span data-katex="\left \langle D,\leqslant  \right \rangle"></span>是一个集合<span data-katex="D"></span>，以及集合上的一个关系（relation）<span data-katex="\leqslant"></span>，</p>

<p>这个关系具有自反性，反对称性，和传递性。</p>

<p><br/></p>

<p>若对于任意<span data-katex="d\in D"></span>有<span data-katex="d\leqslant d"></span>，则称<span data-katex="\leqslant"></span>具有自反性（reflexive）。</p>

<p>若<span data-katex="a\leqslant b"></span>且<span data-katex="b\leqslant a"></span>有<span data-katex="a=b"></span>，则称<span data-katex="\leqslant"></span>具有反对称性（anti-symmetric）。</p>

<p>若<span data-katex="a\leqslant b"></span>且<span data-katex="b\leqslant c"></span>有<span data-katex="a\leqslant c"></span>，则称<span data-katex="\leqslant"></span>具有传递性（transitive）。</p>

<p><br/></p>

<p><strong>上界与最小上界</strong></p>

<p>如果<span data-katex="\left \langle D,\leqslant  \right \rangle"></span>是一个偏序，则子集<span data-katex="S\subseteq D"></span>的上界（upper bound），</p>

<p>是<span data-katex="D"></span>中的一个元素<span data-katex="x\in D"></span>，使得对于任意的<span data-katex="y\in S"></span>有<span data-katex="y\leqslant x"></span>。</p>

<p>最小上界（least upper bound）是那个<span data-katex="\leqslant"></span>任何其它上界的元素。</p>

<p><br/></p>

<p><strong>有向集</strong></p>

<p>如果<span data-katex="\left \langle D,\leqslant  \right \rangle"></span>是一个偏序，称子集<span data-katex="S\subseteq D"></span>是有向的（directed），</p>

<p>如果<span data-katex="S"></span>的每一个有限子集<span data-katex="S_0\subseteq S"></span>在<span data-katex="S"></span>中都有上界。</p>

<p>有向集（directed set）的一个性质是，所有有向集都非空。</p>

<p><br/></p>

<p><strong>完全偏序</strong></p>

<p>完全偏序（complete partial order）简称CPO，它是一个偏序<span data-katex="\left \langle D,\leqslant  \right \rangle"></span>，</p>

<p>且每一个有向子集<span data-katex="S\subseteq D"></span>都有最小上界，我们把这个最小上界记为<span data-katex="\bigvee S"></span>。</p>

<p>可证，任何一个有限的偏序，都是完全偏序。</p>

<p><br/></p>

<p>一个不是CPO的例子是自然数集，自然数集<span data-katex="N"></span>本身是有向的，但没有最小上界。</p>

<p>如果我们加入一个比其他自然数都大的元素<span data-katex="\infty"></span>，我们就得到了一个CPO。</p>

<p><br/></p>

<h2><strong>CPO的提升</strong></h2>

<p><strong>有奇点的CPO</strong></p>

<p>如果<span data-katex="\mathscr{D}=\left \langle D,\leqslant  \right \rangle"></span>是一个有最小元（least element）的偏序，</p>

<p>则称为<span data-katex="\mathscr{D}"></span>是有奇点（pointed）的，我们用<span data-katex="\perp _D"></span>表示<span data-katex="D"></span>的最小元。</p>

<p><br/></p>

<p><strong>提升集</strong></p>

<p>对于任意的集合<span data-katex="A"></span>，我们构建一个CPO，<span data-katex="A_\perp =\left \langle A\cup \{\perp \} ,\leqslant  \right \rangle"></span>，</p>

<p>其中，<span data-katex="x\leqslant y"></span>当且仅当<span data-katex="x=\perp"></span>或<span data-katex="x=y"></span>。</p>

<p>我们称<span data-katex="A_\perp"></span>为<span data-katex="A"></span>的提升集（lifted set）。</p>

<p><br/></p>

<p>用这个方法，我们可以提升任何一个CPO，<span data-katex="\mathscr{D}=\left \langle D,\leqslant _D  \right \rangle"></span>，</p>

<p>得到<span data-katex="\mathscr{D}_\perp =\left \langle D\cup \{\perp \},\leqslant \right \rangle"></span>，</p>

<p>其中<span data-katex="\perp"></span>与<span data-katex="D"></span>中的任何元素都不等，新的序关系<span data-katex="x\leqslant y"></span>当且仅当<span data-katex="x=\perp"></span>或<span data-katex="x\leqslant _D y"></span>。</p>

<p><br/></p>

<p>可证，如果<span data-katex="\mathscr{D}"></span>是一个CPO，则<span data-katex="\mathscr{D}_\perp"></span>是一个有奇点的CPO。</p>

<p><br/></p>

<h2><strong>连续函数</strong></h2>

<p><strong>单调函数</strong></p>

<p>设<span data-katex="\mathscr{D}=\left \langle D,\leqslant _D \right \rangle"></span>和<span data-katex="\mathscr{E}=\left \langle E,\leqslant _E \right \rangle"></span>是CPO，</p>

<p><span data-katex="f:D\rightarrow E"></span>是集合<span data-katex="D"></span>到<span data-katex="E"></span>的一个函数，我们说<span data-katex="f"></span>是单调的（monotonic），</p>

<p>如果<span data-katex="a\leqslant b"></span>就有<span data-katex="f(a)\leqslant f(b)"></span>。</p>

<p><br/></p>

<p><strong>连续函数</strong></p>

<p>一个单调函数<span data-katex="f"></span>是连续的（continuous），如果对于任意有向子集<span data-katex="S\subseteq D"></span>，有<span data-katex="f(\bigvee S)=\bigvee f(S)"></span>。</p>

<p><br/></p>

<p><strong>提升函数</strong></p>

<p>我们定义<span data-katex="f:D\rightarrow E"></span>对应的提升函数（lifted function）为<span data-katex="f_\perp =(D\cup\{ \perp \})\rightarrow (E\cup\{ \perp \})"></span>。</p>

<p>其中，如果<span data-katex="a\in D"></span>，则<span data-katex="f_\perp (a)=f(a)"></span>，否则<span data-katex="f_\perp (a)=\perp"></span>。</p>

<p><br/></p>

<p><strong>函数集构成CPO</strong></p>

<p>假设<span data-katex="\mathscr{D}=\left \langle D,\leqslant _D \right \rangle"></span>和<span data-katex="\mathscr{E}=\left \langle E,\leqslant _E \right \rangle"></span>是CPO，</p>

<p>对于连续函数<span data-katex="f,g:D\rightarrow E"></span>，我们称<span data-katex="f\leqslant_{D\rightarrow E} g"></span>，如果对于任意<span data-katex="d\in D"></span>，都有<span data-katex="f(d)\leqslant _E g(d)"></span>。</p>

<p>于是，所有这些连续函数构成了一个CPO，记为<span data-katex="\mathscr{D}\rightarrow \mathscr{E}=\left \langle D\rightarrow E,\leqslant _{D\rightarrow E} \right \rangle"></span>。</p>

<p><br/></p>

<h2><strong>最小不动点</strong></h2>

<p>我们称<span data-katex="a"></span>是<span data-katex="f"></span>的最小不动点（least fixed point），</p>

<p>如果<span data-katex="a=f(a)"></span>且对于任意的<span data-katex="b=f(b)"></span>，我们有<span data-katex="a\leqslant b"></span>。</p>

<p><br/></p>

<p>如果<span data-katex="\mathscr{D}"></span>是一个有奇点的CPO，且<span data-katex="f:D\rightarrow D"></span>是连续的，则<span data-katex="f"></span>有最小不动点，</p>

<p><span data-katex="fix_D f=\bigvee \{ f^n(\perp )~|~n\geqslant 0 \}"></span>，</p>

<p>且<span data-katex="fix_D"></span>是连续的。</p>

<p><br/></p>

<p>例如，设<span data-katex="\mathscr{D}=\left \langle D,\leqslant _D \right \rangle"></span>是有奇点的CPO，则恒等函数<span data-katex="id:D\rightarrow D"></span>的最小不动点是<span data-katex="\perp _D"></span>。</p>

<p><span data-katex="fix_D~id=\bigvee \{ id^n(\perp _D)~|~n\geqslant 0 \}=\bigvee \{ \perp _D \}=\perp _D"></span></p>

<h2><strong>结语</strong></h2>

<p>初等数学中，某些函数是没有不动点的。</p>

<p>那么在什么情况下，形如<span data-katex="f:\sigma =M"></span>的表达式有解呢？</p>

<p>定义了递归之后，对类型化lambda演算的模型产生了什么影响呢？</p>

<p><br/></p>

<p>这是一直以来我心中是一个问题。</p>

<p>诚然，类型化lambda演算有不同的解释方式，但以上域论模型通俗易懂，</p>

<p>也算是告一段落吧，以后的路还长着呢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[代数数据类型的语法和语义]]></title>
    <link href="https://thzt.github.io/blog/2016/06/08/algebraic-data-type/"/>
    <updated>2016-06-08T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/06/08/algebraic-data-type</id>
    <content type="html"><![CDATA[<script src="https://thzt.github.io/thirdpart/jQuery/jquery-1.11.1.js"></script>


<p><link href="https://thzt.github.io/thirdpart/KaTeX/katex.min.css" rel="stylesheet"/></p>

<script src="https://thzt.github.io/thirdpart/KaTeX/katex.min.js"></script>


<script src="https://thzt.github.io/javascripts/katex.js"></script>


<h3><strong>代数数据类型</strong></h3>

<p>一个代数数据类型，由值的一些集合，以及这些集合之间的一些函数构成。</p>

<p>这些函数都是一阶函数，不能以其他函数作为参数。</p>

<p><br/></p>

<h3><strong>泛代数</strong></h3>

<p>泛代数（universal algebra）也称为等式逻辑（equational logic），</p>

<p>是用于研究代数数据类型的一个数学框架。</p>

<p><br/></p>

<p>在泛代数中，代数数据类型的语法由代数项（algebraic term）描述，公理语义用项之间的等式集（a set of equations）描述，</p>

<p>而指称语义对应于一个<span data-katex="\Sigma"></span>代数，操作语义通过给等式设定方向来表示。</p>

<hr />

<h2><strong>代数数据类型的语法</strong></h2>

<h3><strong>代数项和签名</strong></h3>

<p>一个代数项（algebraic term）由符号和类型来定义，</p>

<p>这些信息放在一起称为代数项的签名（signature）。</p>

<p><br/></p>

<p>构成代数项的基本类型称为sort。</p>

<p><br/></p>

<p>一个签名<span data-katex="\Sigma=\left \langle S,F \right \rangle"></span>，由以下几个部分构成，</p>

<p>（1）以sort为元素构成的集合</p>

<p>（2）sort上函数符号的集合<span data-katex="F=\left \{ f:s_1\times \cdots \times s_k\rightarrow s \right \}"></span></p>

<p>其中，<span data-katex="s_1,\cdots ,s_k,s\in S"></span>，<span data-katex="f"></span>称为类型化的函数符号，</p>

<p>每个函数符号的类型是唯一的。</p>

<p><br/></p>

<p>例如，自然数表达式的签名是<span data-katex="\Sigma_N=\left \langle S,F \right \rangle"></span>，</p>

<p>其中<span data-katex="S=\left \{ nat \right \}"></span>，只包含一个sort，</p>

<p><span data-katex="F"></span>给出以下几个函数符号，</p>

<p><span data-katex="0:nat"></span>，<span data-katex="1:nat"></span>，<span data-katex="+:nat\times nat\rightarrow nat"></span>，<span data-katex="*:nat\times nat\rightarrow nat"></span>。</p>

<p>习惯上为了节省空间，通常把签名写成一个表格形式，</p>

<p><span data-katex="sorts:nat"></span></p>

<p><span data-katex="fctns:0,1:nat"></span></p>

<p><span data-katex="+,*:nat\times nat\rightarrow nat"></span></p>

<p><br/></p>

<h3><strong>变量的指派</strong></h3>

<p>一个指派（sort assignment），是如下一个有限集合，用来指定变量的类型，</p>

<p><span data-katex="\Gamma=\left \{ x_1:s_1,\cdots ,x_k:s_k \right \}"></span></p>

<p>不能为同一个变量指派不同的sort。</p>

<p><br/></p>

<h3><strong>合法代数项的集合</strong></h3>

<p>基于签名<span data-katex="\Sigma"></span>和指派<span data-katex="\Gamma"></span>，可以定义一个sort为<span data-katex="s"></span>的代数项的集合<span data-katex="Terms^s\left ( \Sigma,\Gamma \right )"></span>，</p>

<p>它满足以下几个条件，</p>

<p>（1）如果<span data-katex="x:s\in \Gamma"></span>则<span data-katex="x\in Terms^s\left ( \Sigma,\Gamma \right )"></span></p>

<p>（2）如果<span data-katex="f:s_1\times \cdots \times s_k\rightarrow s"></span>且<span data-katex="M_i\in Terms^{s_i}\left ( \Sigma,\Gamma \right )"></span>，</p>

<p><span data-katex="i=1,\cdots ,n"></span>，则<span data-katex="fM_1\cdots M_k\in Terms^s\left ( \Sigma,\Gamma \right )"></span></p>

<hr />

<h2><strong>代数数据类型的指称语义</strong></h2>

<h3><strong><span data-katex="\Sigma"></span>代数</strong></h3>

<p><span data-katex="\Sigma"></span>代数是一种数学结构，它为代数项提供了含义或指称语义。</p>

<p><br/></p>

<p>一个<span data-katex="\Sigma"></span>代数，包含了一个或多个集合，称为载体（carrier），</p>

<p>以及一些特征元素，和载体上的一些一阶函数，</p>

<p><span data-katex="f:A_1\times \cdots \times A_k \rightarrow A"></span></p>

<p><br/></p>

<p>例如，<span data-katex="\Sigma"></span>代数<span data-katex="\mathscr{N}=\left \langle N,0,1,+,* \right \rangle"></span></p>

<p>具有载体<span data-katex="N"></span>，它是自然数集，</p>

<p>具有特征元素，<span data-katex="0,1\in N"></span>，</p>

<p>以及函数，<span data-katex="+,*:N \times N \rightarrow N"></span>。</p>

<p>其中，特征元素可以看成零元函数。</p>

<p><br/></p>

<p>带有多个载体的例子是<span data-katex="\Sigma"></span>代数<span data-katex="\mathscr{A}_{pcf}=\left \langle N,B,0,1,\cdots ,+,true,false,Eq?,\cdots ,\right \rangle"></span></p>

<p>其中<span data-katex="N"></span>是自然数集，<span data-katex="B"></span>是布尔值集，</p>

<p><span data-katex="0,1,\cdots"></span>是自然数，<span data-katex="+"></span>是加法函数。</p>

<p><br/></p>

<h3><strong>代数项的解释</strong></h3>

<p>我们说<span data-katex="\mathscr{A}=\left \langle \left \{ A^s \right \}_{s\in S}, \mathscr{I} \right \rangle"></span>是与所有合法代数项<span data-katex="\left \{ Terms^s\left ( \Sigma,\Gamma \right ) \right \}_{s\in S}"></span>对应的<span data-katex="\Sigma"></span>代数，</p>

<p>指的是如下对应关系成立，</p>

<p>（1）每一个sort，<span data-katex="s\in S"></span>，恰好对应一个载体<span data-katex="A^s"></span></p>

<p>（2）每一个函数符号<span data-katex="f:s_1\times \cdots \times s_k\rightarrow s"></span>，恰好对应一个函数<span data-katex="\mathscr{I}(f):A^{s_1}\times \cdots \times A^{s_k}\rightarrow A^s"></span></p>

<p>习惯上把<span data-katex="\mathscr{I}(f)"></span>写成<span data-katex="f^{\mathscr{A}}"></span>。</p>

<p><br/></p>

<h3><strong>含变量代数项的解释</strong></h3>

<p><span data-katex="\Sigma"></span>代数<span data-katex="\mathscr{A}"></span>的环境<span data-katex="\eta"></span>，是把变量映射到<span data-katex="\mathscr{A}"></span>的各载体中元素的一个映射。</p>

<p><span data-katex="\eta :\mathscr{V} \rightarrow\cup _sA^s"></span></p>

<p>需要环境的原因是，对于含变量<span data-katex="x"></span>的项<span data-katex="M"></span>，叙述<span data-katex="M"></span>的含义必须先给<span data-katex="x"></span>指定一个确定的值。</p>

<p>如果对于每个<span data-katex="x:s\in \Gamma"></span>，都有<span data-katex="\eta (x)\in A^s"></span>，就说环境<span data-katex="\eta"></span>满足指派<span data-katex="\Gamma"></span>。</p>

<p><br/></p>

<p>假定<span data-katex="\Sigma"></span>代数<span data-katex="\mathscr{A}"></span>的一个环境<span data-katex="\eta"></span>满足指派<span data-katex="\Gamma"></span>，</p>

<p>则可以把环境<span data-katex="\eta"></span>下的任何项<span data-katex="M\in Terms\left ( \Sigma ,\Gamma \right )"></span>的含义<span data-katex="\mathscr{A}[[M]]\eta"></span>定义如下，</p>

<p>（1）<span data-katex="\mathscr{A}[[M]]\eta =\eta (x)"></span></p>

<p>（2）<span data-katex="\mathscr{A}[[fM_1\cdots M_k]]\eta =f^{\mathscr{A}}(\mathscr{A}[[M_1]]\eta ,\cdots ,\mathscr{A}[[M_k]]\eta )"></span></p>

<p><br/></p>

<p>若<span data-katex="\Sigma"></span>代数<span data-katex="\mathscr{A}"></span>在上下文中是明确的，通常省略<span data-katex="\mathscr{A}"></span>而直接写<span data-katex="[[M]]\eta"></span>，</p>

<p>若<span data-katex="M"></span>中没有变量，则<span data-katex="\mathscr{A}[[M]]\eta"></span>不依赖于<span data-katex="\eta"></span>，可以写为<span data-katex="\mathscr{A}[[M]]"></span>。</p>

<hr />

<h2><strong>语法和语义的关系</strong></h2>

<h3><strong>可靠性与完备性</strong></h3>

<p>代数数据类型的公理语义是由代数项之间的等式集给出的，签名和等式集合称代数规范（algebraic specification）。</p>

<p>一个代数规范，或者可以使用等式证明系统推导出代数项之间的其他等式，或者可以检验代数项对应的<span data-katex="\Sigma"></span>代数是否满足这些等式的要求。</p>

<p><br/></p>

<p>代数项对应的<span data-katex="\Sigma"></span>代数并不是唯一的。</p>

<p>从一个代数规范推导得到的等式，在该规范对应的任何<span data-katex="\Sigma"></span>代数中都成立，就称该代数证明系统是可靠的（sound）。</p>

<p>一个代数规范对应的任何<span data-katex="\Sigma"></span>代数中都成立的等式，在该规范中都可证，就称该代数证明系统是完备的（complete）。</p>

<p><br/></p>

<h3><strong>等式的可满足性</strong></h3>

<p>等式（equation）是一个公式<span data-katex="M=N[\Gamma ]"></span>，其中<span data-katex="M,N\in Terms^s\left ( \Sigma ,\Gamma \right )"></span>，<span data-katex="s\in S"></span>。</p>

<p>如果环境<span data-katex="\eta"></span>满足指派<span data-katex="\Gamma"></span>，且<span data-katex="[[M]]\eta =[[N]]\eta"></span>，</p>

<p>就说<span data-katex="\Sigma"></span>代数<span data-katex="\mathscr{A}"></span>在环境<span data-katex="\eta"></span>下满足<span data-katex="M=N[\Gamma ]"></span>，记为</p>

<p><span data-katex="\mathscr{A},\eta \models M=N[\Gamma]"></span></p>

<p><br/></p>

<p>对于含变量的项，我们更感兴趣的是一个等式是否在变量所有可能的取值情况下都成立，</p>

<p>而不是在一个特别的环境中成立。</p>

<p>如果对于满足<span data-katex="\Gamma"></span>的任何一个环境<span data-katex="\eta"></span>都有<span data-katex="\mathscr{A},\eta \models M=N[\Gamma]"></span>，</p>

<p>就可以说，<span data-katex="\Sigma"></span>代数<span data-katex="\mathscr{A}"></span>满足等式<span data-katex="M=N[\Gamma ]"></span>，记为</p>

<p><span data-katex="\mathscr{A} \models M=N[\Gamma]"></span></p>

<p><br/></p>

<p>可满足性也可以扩展到等式集和代数集，</p>

<p>设<span data-katex="E"></span>是一个等式集，如果<span data-katex="\mathscr{A}"></span>满足所有等式，就说<span data-katex="\mathscr{A}"></span>满足<span data-katex="E"></span>。</p>

<p>类似的，若<span data-katex="C"></span>是一类<span data-katex="\Sigma"></span>代数，且对每个<span data-katex="\mathscr{A}\in C"></span>都有<span data-katex="\mathscr{A}\models M=N[\Gamma ]"></span>，则<span data-katex="C\models M=N[\Gamma ]"></span></p>

<p><br/></p>

<p>若任何一个<span data-katex="\Sigma"></span>代数都满足代数项之间的等式<span data-katex="M=N[\Gamma ]"></span>，就说该等式是永真的（valid），写为<span data-katex="\models M=N[\Gamma ]"></span>。</p>

<p>例如，<span data-katex="x=x[x:s]"></span>就是永真的。</p>

<p><br/></p>

<p>若<span data-katex="\mathscr{A}"></span>满足签名<span data-katex="\Sigma=\left \langle S,F \right \rangle"></span>上的所有等式，就说<span data-katex="\Sigma"></span>代数是平凡的（trivial）。</p>

<p><br/></p>

<h3><strong>语义蕴含（semantic implication）</strong></h3>

<p>若满足等式集<span data-katex="E"></span>的每一个<span data-katex="\Sigma"></span>代数<span data-katex="\mathscr{A}"></span>都满足等式<span data-katex="M=N[\Gamma ]"></span>，</p>

<p>则称签名<span data-katex="\Sigma"></span>上的等式集<span data-katex="E"></span>在语义上蕴含等式<span data-katex="M=N[\Gamma ]"></span>，记为，</p>

<p><span data-katex="E\models M=N[\Gamma ]"></span></p>

<p><br/></p>

<p>有了签名<span data-katex="\Sigma"></span>和等式集<span data-katex="E"></span>，我们定义代数规范<span data-katex="Spec=\left \langle \Sigma,E \right \rangle"></span>，</p>

<p>则满足代数规范的，在所有<span data-katex="\Sigma"></span>代数中都成立的等式，就是那些由等式集<span data-katex="E"></span>语义蕴含的等式。</p>

<p><br/></p>

<h3><strong>语义理论</strong></h3>

<p>如果等式集<span data-katex="E"></span>在语义蕴含下封闭（closed），则把它称为一个理论（theory）。</p>

<p>更准确的说，如果<span data-katex="E\models M=N[\Gamma ]"></span>，则<span data-katex="M=N[\Gamma ]\in E"></span>，那么等式集<span data-katex="E"></span>就称为一个语义理论（semantic theory）。</p>

<p>一个<span data-katex="\Sigma"></span>代数<span data-katex="\mathscr{A}"></span>的理论<span data-katex="Th(\mathscr{A})"></span>，就是在<span data-katex="\mathscr{A}"></span>中成立的所有等式的集合。</p>

<p>可以证明一个<span data-katex="\Sigma"></span>代数的理论是一个语义理论。</p>

<p><br/></p>

<h3><strong>形式证明</strong></h3>

<p>一个证明系统的推导规则如下，<span data-katex="\frac{antecedent}{consequent}"></span>，</p>

<p>使得从前件（antecedent）的任何实例出发，通过使用该证明系统的公理和其他规则，</p>

<p>可以推导出后件（consequent）的相应实例。</p>

<p><br/></p>

<p>例如：<span data-katex="\frac{M=N[\Gamma ],N=P[\Gamma ],P=Q[\Gamma ]}{M=Q[\Gamma ]}"></span></p>

<p><br/></p>

<p>若证明了一条规则是可推导的，则能够把它当做系统的一条证明规则来使用。</p>

<p>如果某条规则没有前件，则称它是证明系统的一条公理（axiom）。</p>

<p><br/></p>

<p>我们说等式<span data-katex="M=N[\Gamma ]"></span>是可证的（provable），记为<span data-katex="E\vdash M=N[\Gamma ]"></span></p>

<p>如果从<span data-katex="E"></span>到<span data-katex="M=N[\Gamma ]"></span>存在一个等式序列，</p>

<p>使得每个等式或者是公理（axiom），或者是<span data-katex="E"></span>中的等式，</p>

<p>或者是从序列中之前出现的一个或多个等式经一步推导得到的结果。</p>

<p><br/></p>

<h3><strong>语法理论</strong></h3>

<p>若在可证性下等式集<span data-katex="E"></span>是封闭的，则称<span data-katex="E"></span>是一个语法理论（syntactic theory）。</p>

<p>换句话说，如果<span data-katex="E\vdash M=N[\Gamma ]"></span>，则<span data-katex="M=N[\Gamma ]\in E"></span>，那么等式集<span data-katex="E"></span>就称为一个语法理论。</p>

<p><span data-katex="E"></span>的语法理论<span data-katex="Th(E)"></span>就是从<span data-katex="E"></span>可证的所有等式的集合。</p>

<p><br/></p>

<h3><strong>等式证明系统的性质</strong></h3>

<p>可靠性（soundness）：若<span data-katex="E\vdash M=N[\Gamma ]"></span>，则<span data-katex="E\models M=N[\Gamma ]"></span></p>

<p>演绎完备性（deductive completeness）：若<span data-katex="E\models M=N[\Gamma ]"></span>，则<span data-katex="E\vdash M=N[\Gamma ]"></span></p>

<hr />

<h2><strong>结语</strong></h2>

<p>《<a href="https://book.douban.com/subject/1761918/">Foundations for Programming Languages</a>》是一本好书，</p>

<p>可是中文的翻译《<a href="https://book.douban.com/subject/1944729/">程序设计语言理论基础</a>》简直是晦涩难懂，</p>

<p>把sort翻译为『类子』，把signature翻译为『基调』，容易让人误以为和同调代数有什么联系。</p>

<p>原版书拿到后，看起来轻松了不少，这里只是对第三章部分内容做了个小结，以便卸下包袱轻装上阵。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何应对需求变更]]></title>
    <link href="https://thzt.github.io/blog/2016/06/02/requirement-change/"/>
    <updated>2016-06-02T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/06/02/requirement-change</id>
    <content type="html"><![CDATA[<h2><strong>对需求的误解</strong></h2>

<p>同学们经常提及的需求变更，其实变更的并不是需求，而是需求的实现方案。</p>

<p>首先，我们要对需求和方案进行区分。</p>

<p>需求包括以下几个方面，需求背景，需求目的，需求范围，需求的详细规格，以及错误处理方式。</p>

<p>UI/UE/UX，前端，后端，共同实现了需求，是同一个解决方案的不同侧面。</p>

<p><br/></p>

<p>因此从广义上来讲，开发者之间的内部沟通，不属于需求变更范畴。</p>

<p>软件的大部分问题，存在于开发者之间的沟通上面，而不是开发者对需求的理解上面。</p>

<p>只有理解了什么是需求，才能衡量出需求是否变更了。</p>

<p><br/></p>

<blockquote><p>在软件工程中，需求分析指的是在建立一个新的或改变一个现存的电脑系统时描写新系统的目的、范围、定义和功能时所要做的所有的工作。</p></blockquote>

<p><br/></p>

<h2><strong>从方法到目的</strong></h2>

<p>实现一个目的有多种方法，如何看到这些方法的共性呢？</p>

<p>最快的方式就是找到这些方法要解决的问题。</p>

<p>软件是以解决问题为目的的，不能解决问题的软件没有任何作用。</p>

<p><br/></p>

<p>这要分两方面来说，</p>

<p>其一，当产品经理发起需求变更时，我们要积极配合。因为，需求变更的主要原因在于当前软件不能解决某些问题。</p>

<p>不配合，那么做出的软件就没有用，我们的工作就没有价值。</p>

<p><br/></p>

<p>其二，我们要知道当前软件要解决的问题是什么，才能灵活的改变策略。</p>

<p>甚至可以利用工程师的领域特长，找到更合适的解决方案。</p>

<p><br/></p>

<h2><strong>变更与管控</strong></h2>

<p>我们不怕变化，怕的是对变化失去控制。</p>

<p>当产品经理发起需求变更时，我们要重新安排未完成任务的优先级，这是需要与产品经理沟通的。</p>

<p>因为，变更是需要成本的，意味着原计划要做的某些事情不能做完了，我们得让他们知道。</p>

<p><br/></p>

<p>我们自己首先得有一个任务列表。</p>

<p>然后以优先级的方式管理待办事项。</p>

<p><br/></p>

<h2><strong>知识共享</strong></h2>

<p>不同的人，对需求的理解不同。</p>

<p>每个人都会按照自己的方式去实现想法。</p>

<p>如何设计一个策略，怎样实现这个设计，大相径庭。</p>

<p><br/></p>

<p>因此，我们要预先做一些知识的分享。</p>

<p>在设计阶段排除问题，会比在实现阶段排除问题，成本低很多。</p>

<p>我们不妨谈一谈，我计划怎样解决这个问题，我打算怎样实现。</p>

<p>因为，很有可能，这个计划就是错的。</p>

<p><br/></p>

<h2><strong>主动去沟通</strong></h2>

<p>如果我想改某个文件，担心其他人也在改，以后合并起来麻烦，怎么办？</p>

<p>去问他/她。</p>

<p>某位同学的代码我看不懂，不敢改怎么办？</p>

<p>去问他/她。</p>

<p>产品经理对需求的描述不清楚，我理解不了怎么办？</p>

<p>去问他/她。</p>

<p>交互稿中文案可能有错误，逻辑矛盾，怎么办？</p>

<p>去问他/她。</p>

<p>测试提了一个缺陷，可是我不知道在说什么，也不知道在哪个场景中会出现，怎么办？</p>

<p>去问他/她。</p>

<p><br/></p>

<p>&ldquo;问"，这个简单的动作，会节省大量的时间。</p>

<p>如果不想打断别人的工作，可以用一些非即时沟通工具。</p>

<p>或者走到他旁边，让他注意到你时，你再发问。</p>

<p><br/></p>

<p>提问，并不愚蠢，不问才蠢。</p>

<p>要相信大部分工程师都是喜欢被问的。</p>

<p><br/></p>

<h2><strong>让设计灵活响应变更</strong></h2>

<p>好的设计，在变更中灵活响应。</p>

<p>这实际上是对设计提出了更高的要求，不止是实现功能那么简单了。</p>

<p><br/></p>

<p>因为现实世界是发展中的，业务场景也在与时俱进。</p>

<p>因此，需求本身不可能是不变的。</p>

<p>软件是一个解决动态问题的方案。</p>

<p><br/></p>

<p>程序设计是用来解决发展中问题的。</p>

<p>我们要看到问题的发展趋势，结合整个过程进行设计。</p>

<p>给未来留下余地，不局限于当前状态进行设计。</p>

<p><br/></p>

<p>需求你怎么改都行，因为你不得不改，我也不得不照做，不然软件本身就没用了。</p>

<p>但是我的设计保障我修改的成本最低。</p>

<p><br/></p>

<h2><strong>原谅别人的失误</strong></h2>

<p>人非圣贤孰能无过。</p>

<p>我们会因为手误打错代码，也会因为大脑一时短路犯逻辑错误。</p>

<p>那么，产品经理同样也会对需求理解和描述产生偏差。</p>

<p>我们不能要求别人做到完美。</p>

<p><br/></p>

<p>一方面，我们要原谅他们，但要让他们知道大家的代价。</p>

<p>另一方面，我们要听思想，不要听描述。抓住中心思想，忽略细节。</p>

<p><br/></p>

<p>严于律己，宽以待人。</p>

<h2><strong>结语</strong></h2>

<p>大部分软件从业者，没有软件工程相关的培训，也没有阅读过相关书籍，</p>

<p>是依靠自己的感觉来做软件的。</p>

<p><br/></p>

<p>结果会沿用一些不恰当的类比来理解软件，</p>

<p>也会逐渐形成小作坊式的软件开发过程。</p>

<p>当团队规模扩大时，问题就会越来越严重。</p>

<p><br/></p>

<p>不过，没关系，这有什么。</p>

<p>痛了才会想办法去解决，也无需过度设计。</p>

<p>只是现在我们是否该学一些软件工程的知识了呢？</p>

<p><br/></p>

<p><strong>参考：</strong></p>

<p><a href="https://book.douban.com/subject/1007738/">快速软件开发</a></p>

<p><a href="https://book.douban.com/subject/1140457/">敏捷软件开发 : 原则、模式与实践</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[让事情去发生]]></title>
    <link href="https://thzt.github.io/blog/2016/05/29/let-things-happen/"/>
    <updated>2016-05-29T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/05/29/let-things-happen</id>
    <content type="html"><![CDATA[<p>经验增长，并不完全是一件好事，</p>

<p>它也许会阻止本来可能发生的事情。</p>

<p><br/></p>

<p>我们凭着经验来进行判断，</p>

<p>除非遇到完全相同的初始条件，</p>

<p>否则，这样的判断和随意猜测并没有什么不同。</p>

<p><br/></p>

<p>我们踩到的坑多了，走路都战战兢兢，</p>

<p>一年被蛇咬，十年怕井绳。</p>

<p><br/></p>

<p>如何打破经验主义的误区呢？</p>

<p>那就是，让事情去发生。</p>

<p><br/></p>

<p>现实世界中的事情都是发展中的，</p>

<p>我们得有胆量让事情去发展，</p>

<p>然后掌控它的发展过程。</p>

<p><br/></p>

<h2><strong>把责任交出去</strong></h2>

<p>篮球是一项团体运动，</p>

<p>在打篮球时，我们用的最多的是传接球。</p>

<p><br/></p>

<p>可是，新手组织后卫往往无法理解，</p>

<p>球传出去以后，自己都无法掌控它了，</p>

<p>怎样组织这次进攻呢？</p>

<p><br/></p>

<p>这类似于其他团队合作中的责任，</p>

<p>不敢把责任交出去，</p>

<p>担心别人做不好。</p>

<p><br/></p>

<p>这样就无法达到默契的配合。</p>

<p><br/></p>

<p>高手组织后卫怎样理解这件事情呢？</p>

<p>他首先会观察比赛的发展态势，</p>

<p>然后通过运球去影响这个态势的走向，</p>

<p>随后，把球顺着态势传出去。</p>

<p><br/></p>

<p>这样的话，其他人的行为就会被态势所牵引。</p>

<p>比赛仍然在掌控中。</p>

<p><br/></p>

<p>所以，难能可贵的是，</p>

<p>让比赛进行，把球传出去。</p>

<p><br/></p>

<h2><strong>最佳实践</strong></h2>

<p>软件项目中，有前人总结的无数最佳实践，</p>

<p>不遵循它们，会犯很多前人已经犯过的错误。</p>

<p><br/></p>

<p>然而，完全遵循它们，</p>

<p>又会抹杀掉未来的某些可能性。</p>

<p><br/></p>

<p>每种方案都有适得其所的用处，</p>

<p>没有在任何情况下都不适用的方案，</p>

<p>不用它，其实很多人是因为没有真正掌握它。</p>

<p><br/></p>

<p>很多方案是发展而来的，</p>

<p>到了那个境地，解决方案是显而易见的，</p>

<p>现在不用费尽心思，假定到时候很糟。</p>

<p><br/></p>

<p>最佳实践的作用，应该是为了选择方向，</p>

<p>强行预测未来的细节，会担惊受怕，畏首畏尾。</p>

<p><br/></p>

<p>你有胆量让不那么好的事情发生吗？</p>

<p>其实，不那么好与不那么坏，并没有什么区别。</p>

<p><br/></p>

<h2><strong>如何培养人</strong></h2>

<p>世界上最困难的就是把一件你很拿手的工作交给别人，</p>

<p>再眼睁睁看着他把事情搞砸，</p>

<p>而你却还能心平气和不发一言，</p>

<p>那是培养人。</p>

<p>世界上最容易的就是把一件你很拿手的工作交给别人，</p>

<p>再手把手地教他把事情做对，</p>

<p>不给他犯错机会，</p>

<p>那不是培养人，而是锻炼你自己。</p>

<p>——《有一种培养叫放手》</p>

<p><br/></p>

<p>并不是每件事情按计划发生就是好的，</p>

<p>不同的发展轨迹，人们从中的收获也不同。</p>

<p><br/></p>

<p>不让坏事情去发生，就不会身临其境，</p>

<p>没有把事情搞砸过，就不会反思过程。</p>

<h2><strong>人与事情的发展</strong></h2>

<p>事情的发展，总是会涉及到很多人，</p>

<p>因此，个人的作用其实并不那么重要。</p>

<p><br/></p>

<p>让事情去发展，才能观察态势，</p>

<p>才能改变它，才能影响它。</p>

<p><br/></p>

<p>不要把自己看得那么重要，</p>

<p>包括自己在内，大家都是顺势而为，</p>

<p>不改变态势，结果早就被决定了，</p>

<p>有你没你都一样。</p>

<p><br/></p>

<p>所以，要想赢得比赛，</p>

<p>就得做那个能影响比赛走势的人。</p>

<p><br/></p>

<p>不然的话，</p>

<p>胜败已定，预测的再准又有什么用？</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>Let things happen, let them win.</p>

<p>这不仅仅是一种洒脱的态度，</p>

<p>更多的是为了影响事情的整个发展过程。</p>

<p><br/></p>

<p>如果说，新手从犯错，到学会提前意识到错误，是一个进步，</p>

<p>那么老手从丰富的经验，到违反经验的大胆尝试，更是一个进步。</p>

<p><br/></p>

<p>新手，通常把方案静态的理解为当前场景的解，</p>

<p>而高手，更能看到事情的发展过程，</p>

<p>以及采取某个方案，会对事情发展产生什么影响。</p>

<p><br/></p>

<p>让事情发生吧，我来做观众。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类型理论之拙见]]></title>
    <link href="https://thzt.github.io/blog/2016/05/19/type-theory-in-my-eye/"/>
    <updated>2016-05-19T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/05/19/type-theory-in-my-eye</id>
    <content type="html"><![CDATA[<p>类型系统，是指一种根据所计算出值的种类，对词语进行分类，</p>

<p>从而证明某程序行为不会发生的，</p>

<p>可行语法手段。——《TAPL》</p>

<p><br/></p>

<p>可见类型系统是形式方法的一种，</p>

<p>也是一种证明方法。</p>

<p><br/></p>

<p>当我们把自己写好的程序提交给别人时，</p>

<p>如果别人质疑『你怎么证明它是对的』，</p>

<p>是不好回答的。</p>

<p><br/></p>

<p>因为通过测试用例来检测程序行为，</p>

<p>本身就是在进行不完全归纳，</p>

<p>我们只能断定验证过的事情是正确，</p>

<p>却不能断定一般性质。</p>

<p><br/></p>

<p>类型理论与数学，逻辑学，计算机科学相关，</p>

<p>甚至渗透到了其他学科之中。</p>

<p><br/></p>

<p>类型系统是程序语言之上的一套逻辑系统，</p>

<p>可以对程序进行推理，来断定某些性质。</p>

<p>不同的逻辑系统，『诱导』出了不同的类型系统。</p>

<p><br/></p>

<p>形式系统有个特点，那就是稍微改变一点约束条件，</p>

<p>就会得到一系列好玩的附加特性，</p>

<p>有大量丰富的逻辑系统可以玩。</p>

<p>例如，直觉主义逻辑，模态逻辑，时态逻辑，等等。</p>

<p><br/></p>

<p>可是，仅从代码进行静态分析，来断定程序运行时的所有行为，是不可判定的。</p>

<p>因此只能保证well typed的程序没有某类错误，</p>

<p>每个类型系统有各自要阻止的行为。</p>

<p><br/></p>

<p>类型系统种类繁多，支持各种好玩的特性，</p>

<p>例如，支持Polymorphism的类型系统，某类型可以由其他类型参数化，</p>

<p>支持Dependent type的系统，类型可以由值来决定，</p>

<p>子类型允许我们适当放宽类型要求，</p>

<p>递归类型，存在类型，全称类型。</p>

<p><br/></p>

<p>1934年，Curry意识到简单类型化lambda演算中的类型，与直觉主义逻辑之间的关系，</p>

<p>后面的研究发现，人们把这种对应关系推广为了Curry-Howard-Lambek Correspondance，</p>

<p>它将程序语言的类型，逻辑系统中的命题，和指称语义笛卡尔闭范畴，联系起来了。</p>

<p>一个合法项的存在，就证明了对应它类型的一个命题为真，程序即构造出来的证明。</p>

<p><br/></p>

<p>类型理论的实用内容还有很多，</p>

<p>Gradual typing的动静结合，例如flow，</p>

<p>以及Rust和Linear typeing的应用，</p>

<p>另外还有，Hindley–Milner类型推导算法。</p>

<p><br/></p>

<p>类型系统有一些性质可以衡量，</p>

<p>例如，type soundness，type safety，</p>

<p>以及检查类型的方式，static check，dynamic check，</p>

<p>包括某些语言是explicitly typed，而某些是implicitly typed，</p>

<p>某些语言是被stronger checked，有些则是weaker checked。</p>

<p><br/></p>

<p>现在是学习时间了。</p>

<p><br/></p>

<p>参考：</p>

<p><a href="https://wiki.haskell.org/Curry-Howard-Lambek_correspondence">Curry-Howard-Lambek correspondence</a></p>

<p><a href="https://book.douban.com/subject/1318672/">类型和程序设计语言</a></p>

<p><a href="http://lucacardelli.name/papers/typesystems.pdf">Type System - Luca Cardelli</a></p>

<p><a href="https://book.douban.com/subject/1944729/">程序设计语言理论基础</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[不要依赖『道听途说』]]></title>
    <link href="https://thzt.github.io/blog/2016/05/18/do-not-rely-on-the-hearsay/"/>
    <updated>2016-05-18T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/05/18/do-not-rely-on-the-hearsay</id>
    <content type="html"><![CDATA[<p>这几年，信息化的速度明显加快了，</p>

<p>我们获取知识的途径，也大大增多了，</p>

<p>然而，无论是微信，微博，朋友圈，还是论坛，专栏，博客，</p>

<p>大多充斥的是<strong>未经梳理过的碎片化知识</strong>。</p>

<p><br/></p>

<p>我们路过那里，道听途说，</p>

<p>完全凭借别人的只言片语，或他们的心得，去窥探某个领域的内容。</p>

<p>随后，我们马上又急匆匆的转移注意力，把之前看到的都抛之脑后。</p>

<p><br/></p>

<p>似乎，很努力的样子。</p>

<p><br/></p>

<p>结果，</p>

<p>我们虽然看起来什么都懂，却什么也不懂，</p>

<p><strong>阅读了很多科普，也依然不懂科学。</strong></p>

<p><br/></p>

<p>这是危险的。</p>

<p>当我们把努力当做一种习惯的时候，就会忘了反思自己是否在进步。</p>

<p><br/></p>

<p>可是，怎样避免被大量的碎片知识淹没呢？</p>

<p>我们还是要回归本原，<strong>从基础开始，老老实实搭建自己的知识体系</strong>。</p>

<p><br/></p>

<p>对于新知识点，要进行<strong>主动</strong>扩展，</p>

<p>深挖其中的原理和它依赖的内容，<strong>建立起和自己知识体系之间的永久联系</strong>。</p>

<p>只有这样，这块新内容才是有用的，才能为后续的成长做好准备。</p>

<p><br/></p>

<p>必要时，我们还得学会<strong>舍弃</strong>，</p>

<p>过滤大部分信息，虽然它们看起来全都有趣，</p>

<p>从简单处着手，向高大上的方向努力。</p>

<p><br/></p>

<p>于是，</p>

<p>消除浮躁和满怀的斗志吧，回到安静的书房，</p>

<p><strong>打开教科书，静下心来学习</strong>。</p>

<p><br/></p>

<p>读一篇文章，不足以观世界，</p>

<p>阅一部小说，不足以鉴人生。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面向痛点的应变之道]]></title>
    <link href="https://thzt.github.io/blog/2016/05/16/pain-oriented-design/"/>
    <updated>2016-05-16T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/05/16/pain-oriented-design</id>
    <content type="html"><![CDATA[<p>上学写论文时，流传着这么一句话，</p>

<p>『大家虽然不知道鬼的样子，却都在画鬼。』</p>

<p>当时，觉得好有道理啊，我们提出了各种理论模型，却不知道世界到底是什么样子。</p>

<p><br/></p>

<p>没想到后来进入了软件行业，也会遇到同样的问题。</p>

<p><br/></p>

<p>我们很多项目，发起人其实并不知道要做成什么，</p>

<p>只是想做这个，想做那个，</p>

<p>似乎把想做的功能都做完，项目就成了。</p>

<p><br/></p>

<p>我们假想存在某个问题，甚至都没有去调查，</p>

<p>我们觉得别人一定会来用，甚至都没想着去接受反馈，</p>

<p>我们自以为现存方案的问题很多，甚至都没用过它。</p>

<p><br/></p>

<p>这就是在『<strong>画鬼</strong>』，</p>

<p>是一群人憋着实在想做些什么的时候的宏观表现。</p>

<p><br/></p>

<p>那么，我们积极向上的心态，不对吗，</p>

<p>我们想造福社会，推动进步，不好吗？</p>

<p><br/></p>

<p>当然好，只不过要坚持一些设计原则。</p>

<p><br/></p>

<h2><strong>痛点</strong></h2>

<p>学过软件工程之后，我们知道，进行需求分析时，我们得先确定需求的背景和目的。</p>

<p>为什么要做这件事，是什么引起的，<strong>动机</strong>是什么。</p>

<p>只有确定了问题，才能有的放矢。</p>

<p>这是对新项目而言。</p>

<p><br/></p>

<p>而对于实际的项目，几乎都是以现有的解决方案为起点的，</p>

<p>我们还要问，当前方案的<strong>痛点</strong>是什么，哪里做的不够好，</p>

<p>这些问题的优先级怎么安排，怎样逐步解决它。</p>

<p><br/></p>

<p>通过分析痛点，我们才能找到<strong>立项的原因</strong>。</p>

<p>不是我们想做什么，而是我们不得不解决它。</p>

<p>没有迫不得已的形势，事情就不会往前发展。</p>

<p><br/></p>

<p>我们不要急着去解决问题，</p>

<p>而是先要确定，<strong>到底要解决什么问题</strong>。</p>

<p><br/></p>

<h2><strong>应变之道</strong></h2>

<p>应变，是可以锻炼的。</p>

<p><br/></p>

<p>看到每一个方案时，不妨考虑下，它们是<strong>怎样被设计出来的</strong>。</p>

<p>这样才能积累经验，在遇到困难的时候，找到切实可用的办法。</p>

<p><br/></p>

<p>每一个解决方案，都是为它的目的服务的，</p>

<p>人们做了哪些折衷和让步，又是以何种程度达到目的的。</p>

<p><br/></p>

<p>我们要学的，不是会用哪些招数，</p>

<p>而是，<strong>学会这些招数的创造方法</strong>。</p>

<p><br/></p>

<p>由此，繁杂的方案就不会迷惑我们了，</p>

<p>像工匠能看到工具的问题一样，我们会看到<strong>方案的缺陷</strong>，和它们引起的新问题。</p>

<p><br/></p>

<p>无招胜有招。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>不能确定待解决的问题。</p>

<p>给定一个问题，想不出适用的解决方案。</p>

<p><br/></p>

<p>这是两个难点。</p>

<p>我们会假想一个问题，结果做完了以后才发现白费心思。</p>

<p>我们会用流行的解决方案，结果发现越走越远。</p>

<p><br/></p>

<p>经验多了，熟练掌握各种框架类库之后，这两个能力并不会相应提高。</p>

<p>我们需要刻意的训练，才能学会『面向痛点的应变之道』。</p>

<p><br/></p>

<p>Love of bustle is not industry. ——Seneca</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何突破瓶颈]]></title>
    <link href="https://thzt.github.io/blog/2016/05/12/break-through-the-bottleneck/"/>
    <updated>2016-05-12T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/05/12/break-through-the-bottleneck</id>
    <content type="html"><![CDATA[<p>经常遇到有人说，</p>

<p>我现在处于『<strong>瓶颈期</strong>』，无法突破。</p>

<p><br/></p>

<p>什么是瓶颈期呢？</p>

<p>维基百科上这样解释：</p>

<p>瓶颈期为事物在变化发展过程中因无法改变<strong>自身条件</strong>和<strong>外部环境</strong>的情况下，而产生的一个停滞时期。</p>

<p><br/></p>

<p>这个停滞期在学习过程中会出现很多次，</p>

<p>每次遇到都会觉得无处发力，不能超越自己，</p>

<p>而每次突破，都能感觉到明显的进步。</p>

<p><br/></p>

<p>既然，瓶颈期是一个经常出现的现象，</p>

<p>那么突破它的策略，就有<strong>规律</strong>可循了。</p>

<p>通过仔细的分析，我们下文将看到。</p>

<p><br/></p>

<p>是什么造成了瓶颈期？</p>

<p>为什么无法突破瓶颈？</p>

<p>下一个瓶颈为什么更难突破？</p>

<p><br/></p>

<h2><strong>原因</strong></h2>

<p>所谓学习和进步，实际上指的是<strong>对自己有利的改变。</strong></p>

<p>之所以出现停滞期，是因为我们无法做出这些改变了，</p>

<p>我们无法改变自身或者环境，无法更新自己。</p>

<p><br/></p>

<p>对于大多数人而言，环境只能选择，无法迅速改变它，</p>

<p>而选择环境的过程，也是先从改变自己开始的。</p>

<p><br/></p>

<p>所以，停滞期的原因一下子就明朗了，</p>

<p>那就是<strong>行为习惯造成了我们的惰性，使我们不想或无法做出改变。</strong></p>

<p><br/></p>

<p>不主动做出改变，只依靠环境来影响自己，</p>

<p>长此以往，当我们<strong>适应环境</strong>的时候，</p>

<p>瓶颈期就来了，不可避免的来了。</p>

<p><br/></p>

<p>环境已经无法给我们带来新知识了，</p>

<p>内在的更新意识也没有形成，也没有改变环境的契机出现，</p>

<p>一切还是跟昨天一样，那么的平淡无奇，这就是瓶颈。</p>

<p><br/></p>

<p>因此，不要再沉迷过去了，不要再停留了，</p>

<p><strong>做出改变吧，不要等明天，就从现在开始。</strong></p>

<p><br/></p>

<h2><strong>策略</strong></h2>

<p>我们已经决定做出改变了，不达目的誓不罢休。</p>

<p>可是，为什么我们不知道做什么，向哪个方向改变呢？</p>

<p><br/></p>

<p>往往这个时候，<strong>并不是没有改变的方向，</strong></p>

<p><strong>而是，可以改变的方向太多了，我们不知道选择哪个。</strong></p>

<p>哪个选择是最好的，我一直纠结这个，</p>

<p>于是，我什么都不想做，一直纠结到了明天。</p>

<p><br/></p>

<p>放弃吧，骚年。</p>

<p><strong>何不对每个可能的选择做出敏捷的尝试呢？</strong></p>

<p>我们总是对神秘的事物保持自卑和敬畏，</p>

<p>是因为我们从未主动向前探出一步。</p>

<p><br/></p>

<p>因此，我们的策略也就清晰了。</p>

<p>首先，对每个可能的改变，全部做出<strong>试探</strong>，寻找兴趣点，</p>

<p>然后，找到兴趣点后，确立未来的<strong>目标</strong>，</p>

<p>第三，分析目前的状态和目标之间的<strong>差距</strong>，</p>

<p>最后，制定行之有效的短期<strong>计划</strong>，逐步实现它。</p>

<p><br/></p>

<p>这其实是一个<strong>目标管理过程</strong>，</p>

<p>是管理专家彼得·德鲁克（Peter Drucker）在1954年的名著《管理实践》中最先提出的，</p>

<p>德鲁克认为，<strong>并不是有了工作才有目标，而是相反，有了目标才能确定工作内容。</strong></p>

<p><br/></p>

<p>诚然，目标管理对大多数人来说是一个生疏的概念，</p>

<p>可是，<strong>确定目标</strong>，仍然是大环境下同学们的难题，</p>

<p>无法走出第一步，寻找到<strong>兴趣点</strong>，是应试教育的悲剧。</p>

<p><br/></p>

<h2><strong>包袱</strong></h2>

<p>可能，某些人已经越过了好多个瓶颈期了，</p>

<p>从技术修炼，到团队管理，</p>

<p>从不善交流，到布道表达，</p>

<p>从独善其身，到兼济天下。</p>

<p><br/></p>

<p>他们会发现，<strong>每一个瓶颈期的突破都更难一分</strong>，</p>

<p>我虽然知道要做出改变了，为何还是无法行动？</p>

<p>这是因为历史的包袱和惯性。</p>

<p><br/></p>

<p>可能，曾经对某个领域进行了尝试，心灰意冷，</p>

<p>就失去了以后<strong>再次尝试</strong>的热情。</p>

<p>可能，改变工作地点，会导致拖家带口的行动，</p>

<p>这么大的<strong>麻烦</strong>，会阻碍我们做出最有利的决策。</p>

<p>可能，某个知识点太难了，如果学它，</p>

<p>那意味着我要开始画更大的圆，我<strong>没那么多精力</strong>。</p>

<p><br/></p>

<p>这些都是心理包袱，是一切没有尝试的懒惰者的借口。</p>

<p><br/></p>

<p><strong>是我们的每一次决定，而不是努力，</strong></p>

<p><strong>改变了我们的人生轨迹。</strong></p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>与其说，我们谈论了瓶颈期，</p>

<p>不如说，我们讨论了<strong>改变自己的方法论</strong>。</p>

<p><br/></p>

<p>这个方法，不仅适用于个人，</p>

<p>还适用于团队，企业，等团体组织。</p>

<p><br/></p>

<p>大胆试错，是一个必要的环节，</p>

<p>如何降低试错成本，如何提高试错的速度，</p>

<p>是另一个不小的话题。</p>

<p><br/></p>

<p><strong>失败固然痛苦，但更糟糕的是从未去尝试。——西奧多·罗斯福</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[出奇制胜]]></title>
    <link href="https://thzt.github.io/blog/2016/04/27/surprise-move/"/>
    <updated>2016-04-27T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/04/27/surprise-move</id>
    <content type="html"><![CDATA[<p>孙子兵法『兵势篇』中提到，</p>

<p>凡战者，以正合，以奇胜。</p>

<p><br/></p>

<p>战争一开始时局势不太明朗，双方旗鼓相当时就是『以正合』的阶段，</p>

<p>而到后来局势开始明朗，到了决战时刻就是『以奇胜』的时候。</p>

<p><br/></p>

<p>对于『以奇胜』，不同的人有不同的解释，这很正常，</p>

<p>有人说『奇』读作ji，表示预备队，</p>

<p>然而，理解为qi，也无碍，只看目前哪种理解对我们有用。</p>

<p><br/></p>

<p>学习过程，就好像一场持久战，</p>

<p>个人的竞争力与我们采用的学习策略紧密相关。</p>

<p>出奇制胜，指的是用对方意料不到的方法取得胜利。</p>

<p><br/></p>

<p>如何做到这一点呢？</p>

<p>还要从几个层面来说明。</p>

<p><br/></p>

<h2><strong>先不败而后谋胜</strong></h2>

<p>无论从事什么行业，学习什么领域的知识，</p>

<p>扎实的基本功都是很重要的，</p>

<p>为什么呢？</p>

<p><br/></p>

<p>因为，首先要做到不被轻易打败，才能抓住获胜的机会。</p>

<p><br/></p>

<p>以正兵合战，就是这个道理。</p>

<p>合战时输了，奇兵就没有用武之地了。</p>

<p><br/></p>

<p>这个道理还可以用来指导团队建设，</p>

<p>只有在平时不溃败，在关键时期才能发挥更大力量。</p>

<p><br/></p>

<p>怎样才能做到不败呢？</p>

<p>这就要求我们乐于向其他人学习，关注别人在做什么，</p>

<p>用别人的优点，对比自己的弱点，努力弥补。</p>

<p><br/></p>

<p>正面看没有弱点，是制胜的先决条件。</p>

<p><br/></p>

<h2><strong>行进中开火</strong></h2>

<p>Joel Spolsky在『Fire And Motion』中提到，</p>

<p>在进行中开火，你要一边开火一边朝着敌人冲过去，</p>

<p>火力让敌人抬不起头来，不能朝你开火。</p>

<p>前进了，你就可以占领阵地接近敌人，从而搞清楚形势，增加胜算。</p>

<p><br/></p>

<p>在学习过程中，有很多敌军向我方开火的例子。</p>

<p><br/></p>

<p>各路大神发表了数不胜数的文章，会让我们乱了阵脚，</p>

<p>我们无法达到他们中任何一个人的高度。</p>

<p>各个公司，发布了眼花缭乱的类库，框架，开发工具，</p>

<p>让我们沉浸在跟风中无法自拔。</p>

<p><br/></p>

<p>这是敌军在向我们开火呀。</p>

<p><br/></p>

<p>根据别人的优势来规划自己的学习路线，</p>

<p>就会时刻处于被动。</p>

<p>没有自己的优势，就好比刺刀没有开刃一样。</p>

<p><br/></p>

<p>因此，我们要认识自己，找到，</p>

<p>行业的需要，自己的优势，别人的劣势，</p>

<p>三线合一，敢于亮剑。</p>

<p><br/></p>

<h2><strong>后劲十足</strong></h2>

<p>司马懿说过，『夫处世之道，亦即应变之术，岂可偏执一端？』</p>

<p>我们再来看下，如果『奇』理解为ji，我们还有什么收获。</p>

<p><br/></p>

<p>奇兵，指的是预备队，</p>

<p>『以正合，以奇ji胜』，可以解释为，</p>

<p>不要一下子把所有的牌都打完，留一些在手上，关键时候打出去。</p>

<p><br/></p>

<p>这就告诉我们，要留有余地，保持后劲。</p>

<p>做人的道理也是如此，学习和成长都是悄悄完成的。</p>

<p>后劲也必须要有顽强的毅力才能打造出来。</p>

<p><br/></p>

<p>互联网时代，碎片化知识遍布，分散了我们的精力，</p>

<p>让我们没有时间系统的学习任何一块知识，</p>

<p>以奇ji胜，指导我们，在课下静下心来系统学习，维持后劲。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>大家都在学习，那么学习的策略就有了意义，</p>

<p>大家都在努力，那么努力的方向就有了意义。</p>

<p><br/></p>

<p>知识只是学习内容的一种，</p>

<p>对学习策略的调整，本身也是一种学习吧。</p>
]]></content>
  </entry>
  
</feed>
