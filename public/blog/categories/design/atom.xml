<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Design | 何幻]]></title>
  <link href="https://thzt.github.io/blog/categories/design/atom.xml" rel="self"/>
  <link href="https://thzt.github.io/"/>
  <updated>2016-07-23T17:02:57+08:00</updated>
  <id>https://thzt.github.io/</id>
  <author>
    <name><![CDATA[thzt]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[让事情去发生]]></title>
    <link href="https://thzt.github.io/blog/2016/05/29/let-things-happen/"/>
    <updated>2016-05-29T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/05/29/let-things-happen</id>
    <content type="html"><![CDATA[<p>经验增长，并不完全是一件好事，</p>

<p>它也许会阻止本来可能发生的事情。</p>

<p><br/></p>

<p>我们凭着经验来进行判断，</p>

<p>除非遇到完全相同的初始条件，</p>

<p>否则，这样的判断和随意猜测并没有什么不同。</p>

<p><br/></p>

<p>我们踩到的坑多了，走路都战战兢兢，</p>

<p>一年被蛇咬，十年怕井绳。</p>

<p><br/></p>

<p>如何打破经验主义的误区呢？</p>

<p>那就是，让事情去发生。</p>

<p><br/></p>

<p>现实世界中的事情都是发展中的，</p>

<p>我们得有胆量让事情去发展，</p>

<p>然后掌控它的发展过程。</p>

<p><br/></p>

<h2><strong>把责任交出去</strong></h2>

<p>篮球是一项团体运动，</p>

<p>在打篮球时，我们用的最多的是传接球。</p>

<p><br/></p>

<p>可是，新手组织后卫往往无法理解，</p>

<p>球传出去以后，自己都无法掌控它了，</p>

<p>怎样组织这次进攻呢？</p>

<p><br/></p>

<p>这类似于其他团队合作中的责任，</p>

<p>不敢把责任交出去，</p>

<p>担心别人做不好。</p>

<p><br/></p>

<p>这样就无法达到默契的配合。</p>

<p><br/></p>

<p>高手组织后卫怎样理解这件事情呢？</p>

<p>他首先会观察比赛的发展态势，</p>

<p>然后通过运球去影响这个态势的走向，</p>

<p>随后，把球顺着态势传出去。</p>

<p><br/></p>

<p>这样的话，其他人的行为就会被态势所牵引。</p>

<p>比赛仍然在掌控中。</p>

<p><br/></p>

<p>所以，难能可贵的是，</p>

<p>让比赛进行，把球传出去。</p>

<p><br/></p>

<h2><strong>最佳实践</strong></h2>

<p>软件项目中，有前人总结的无数最佳实践，</p>

<p>不遵循它们，会犯很多前人已经犯过的错误。</p>

<p><br/></p>

<p>然而，完全遵循它们，</p>

<p>又会抹杀掉未来的某些可能性。</p>

<p><br/></p>

<p>每种方案都有适得其所的用处，</p>

<p>没有在任何情况下都不适用的方案，</p>

<p>不用它，其实很多人是因为没有真正掌握它。</p>

<p><br/></p>

<p>很多方案是发展而来的，</p>

<p>到了那个境地，解决方案是显而易见的，</p>

<p>现在不用费尽心思，假定到时候很糟。</p>

<p><br/></p>

<p>最佳实践的作用，应该是为了选择方向，</p>

<p>强行预测未来的细节，会担惊受怕，畏首畏尾。</p>

<p><br/></p>

<p>你有胆量让不那么好的事情发生吗？</p>

<p>其实，不那么好与不那么坏，并没有什么区别。</p>

<p><br/></p>

<h2><strong>如何培养人</strong></h2>

<p>世界上最困难的就是把一件你很拿手的工作交给别人，</p>

<p>再眼睁睁看着他把事情搞砸，</p>

<p>而你却还能心平气和不发一言，</p>

<p>那是培养人。</p>

<p>世界上最容易的就是把一件你很拿手的工作交给别人，</p>

<p>再手把手地教他把事情做对，</p>

<p>不给他犯错机会，</p>

<p>那不是培养人，而是锻炼你自己。</p>

<p>——《有一种培养叫放手》</p>

<p><br/></p>

<p>并不是每件事情按计划发生就是好的，</p>

<p>不同的发展轨迹，人们从中的收获也不同。</p>

<p><br/></p>

<p>不让坏事情去发生，就不会身临其境，</p>

<p>没有把事情搞砸过，就不会反思过程。</p>

<h2><strong>人与事情的发展</strong></h2>

<p>事情的发展，总是会涉及到很多人，</p>

<p>因此，个人的作用其实并不那么重要。</p>

<p><br/></p>

<p>让事情去发展，才能观察态势，</p>

<p>才能改变它，才能影响它。</p>

<p><br/></p>

<p>不要把自己看得那么重要，</p>

<p>包括自己在内，大家都是顺势而为，</p>

<p>不改变态势，结果早就被决定了，</p>

<p>有你没你都一样。</p>

<p><br/></p>

<p>所以，要想赢得比赛，</p>

<p>就得做那个能影响比赛走势的人。</p>

<p><br/></p>

<p>不然的话，</p>

<p>胜败已定，预测的再准又有什么用？</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>Let things happen, let them win.</p>

<p>这不仅仅是一种洒脱的态度，</p>

<p>更多的是为了影响事情的整个发展过程。</p>

<p><br/></p>

<p>如果说，新手从犯错，到学会提前意识到错误，是一个进步，</p>

<p>那么老手从丰富的经验，到违反经验的大胆尝试，更是一个进步。</p>

<p><br/></p>

<p>新手，通常把方案静态的理解为当前场景的解，</p>

<p>而高手，更能看到事情的发展过程，</p>

<p>以及采取某个方案，会对事情发展产生什么影响。</p>

<p><br/></p>

<p>让事情发生吧，我来做观众。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面向痛点的应变之道]]></title>
    <link href="https://thzt.github.io/blog/2016/05/16/pain-oriented-design/"/>
    <updated>2016-05-16T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/05/16/pain-oriented-design</id>
    <content type="html"><![CDATA[<p>上学写论文时，流传着这么一句话，</p>

<p>『大家虽然不知道鬼的样子，却都在画鬼。』</p>

<p>当时，觉得好有道理啊，我们提出了各种理论模型，却不知道世界到底是什么样子。</p>

<p><br/></p>

<p>没想到后来进入了软件行业，也会遇到同样的问题。</p>

<p><br/></p>

<p>我们很多项目，发起人其实并不知道要做成什么，</p>

<p>只是想做这个，想做那个，</p>

<p>似乎把想做的功能都做完，项目就成了。</p>

<p><br/></p>

<p>我们假想存在某个问题，甚至都没有去调查，</p>

<p>我们觉得别人一定会来用，甚至都没想着去接受反馈，</p>

<p>我们自以为现存方案的问题很多，甚至都没用过它。</p>

<p><br/></p>

<p>这就是在『<strong>画鬼</strong>』，</p>

<p>是一群人憋着实在想做些什么的时候的宏观表现。</p>

<p><br/></p>

<p>那么，我们积极向上的心态，不对吗，</p>

<p>我们想造福社会，推动进步，不好吗？</p>

<p><br/></p>

<p>当然好，只不过要坚持一些设计原则。</p>

<p><br/></p>

<h2><strong>痛点</strong></h2>

<p>学过软件工程之后，我们知道，进行需求分析时，我们得先确定需求的背景和目的。</p>

<p>为什么要做这件事，是什么引起的，<strong>动机</strong>是什么。</p>

<p>只有确定了问题，才能有的放矢。</p>

<p>这是对新项目而言。</p>

<p><br/></p>

<p>而对于实际的项目，几乎都是以现有的解决方案为起点的，</p>

<p>我们还要问，当前方案的<strong>痛点</strong>是什么，哪里做的不够好，</p>

<p>这些问题的优先级怎么安排，怎样逐步解决它。</p>

<p><br/></p>

<p>通过分析痛点，我们才能找到<strong>立项的原因</strong>。</p>

<p>不是我们想做什么，而是我们不得不解决它。</p>

<p>没有迫不得已的形势，事情就不会往前发展。</p>

<p><br/></p>

<p>我们不要急着去解决问题，</p>

<p>而是先要确定，<strong>到底要解决什么问题</strong>。</p>

<p><br/></p>

<h2><strong>应变之道</strong></h2>

<p>应变，是可以锻炼的。</p>

<p><br/></p>

<p>看到每一个方案时，不妨考虑下，它们是<strong>怎样被设计出来的</strong>。</p>

<p>这样才能积累经验，在遇到困难的时候，找到切实可用的办法。</p>

<p><br/></p>

<p>每一个解决方案，都是为它的目的服务的，</p>

<p>人们做了哪些折衷和让步，又是以何种程度达到目的的。</p>

<p><br/></p>

<p>我们要学的，不是会用哪些招数，</p>

<p>而是，<strong>学会这些招数的创造方法</strong>。</p>

<p><br/></p>

<p>由此，繁杂的方案就不会迷惑我们了，</p>

<p>像工匠能看到工具的问题一样，我们会看到<strong>方案的缺陷</strong>，和它们引起的新问题。</p>

<p><br/></p>

<p>无招胜有招。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>不能确定待解决的问题。</p>

<p>给定一个问题，想不出适用的解决方案。</p>

<p><br/></p>

<p>这是两个难点。</p>

<p>我们会假想一个问题，结果做完了以后才发现白费心思。</p>

<p>我们会用流行的解决方案，结果发现越走越远。</p>

<p><br/></p>

<p>经验多了，熟练掌握各种框架类库之后，这两个能力并不会相应提高。</p>

<p>我们需要刻意的训练，才能学会『面向痛点的应变之道』。</p>

<p><br/></p>

<p>Love of bustle is not industry. ——Seneca</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[论工具]]></title>
    <link href="https://thzt.github.io/blog/2016/03/11/tools/"/>
    <updated>2016-03-11T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/03/11/tools</id>
    <content type="html"><![CDATA[<p>中学的历史课本上曾经讲过，</p>

<p>学会制作工具，是人类进步的标志。</p>

<p><br/></p>

<p>我深以为然。</p>

<p>可是现实生活中，<strong>存在着对工具很多的误解</strong>。</p>

<p><br/></p>

<p>有的人，认为制作工具浪费时间和精力，做了不必要的事情，</p>

<p>有的人，认为既然有现成的工具可用，为什么还要自己造轮子。</p>

<p>有的人，认为应该专门区分开制作工具的人和使用工具的人。</p>

<p><br/></p>

<p>这些看法，在各自的角度来讲，都说的通，</p>

<p>可以没有对工具有个<strong>全面的</strong>认识。</p>

<p><br/></p>

<p>下面，我们仔细分析一下，</p>

<p>看能不能从更高的角度来看待它，</p>

<p>做好工具，用好工具。</p>

<p><br/></p>

<h2><strong>工具就是解决方案</strong></h2>

<p>无论是日常生活中，还是在软件开发中，</p>

<p>我们经常有直接解决问题的场景，</p>

<p>貌似并没有使用工具。</p>

<p><br/></p>

<p>这就给了人们一种<strong>假象</strong>，</p>

<p>那种特意找来的才叫工具，</p>

<p>用了别人的东西，才叫用了工具。</p>

<p><br/></p>

<p>其实不然。</p>

<p>一个<strong>解决方案</strong>，实际上就是一个具体的工具了，</p>

<p>只不过它只能用来解决那个问题罢了。</p>

<p><br/></p>

<p>好的解决方案，就好比适用的工具，</p>

<p>用最直接的办法解决了问题，</p>

<p>不拖泥带水，不带来附加的问题。</p>

<p><br/></p>

<h2><strong>不得已而造轮子</strong></h2>

<p>着手实施的过程，</p>

<p>实际上就是将目前的项目问题<strong>还原</strong>成历史上已经解决过问题的过程。</p>

<p><br/></p>

<p>这个阶段，我们在进行问题求解。</p>

<p>为了尽可能的少耗费精力，我们总会优先选择已经成型的工具，</p>

<p>在软件开发中，相当于找到各种类库，框架来用。</p>

<p><br/></p>

<p>可是，市面上广为流传的那些通用工具，</p>

<p>并不一定非常切题，我们必须做出调整，甚至废弃一部分功能，</p>

<p>这个时候，就有点造轮子的萌芽了。</p>

<p><br/></p>

<p>随着业务的发展，业务模型逐渐清晰起来了，</p>

<p>没有趁手的工具，也无法跟得上业务的发展需要了，</p>

<p><strong>只能从基础开始，借用各种工具的设计思想，让工具和业务共同发展。</strong></p>

<p><br/></p>

<p>此之所谓，重新造轮子。</p>

<p><br/></p>

<p>这样不好吗？</p>

<p>在项目初期，诚然不太合适，</p>

<p>但是，全程中我们的目的都是为了找到合适的工具解决问题呀，</p>

<p>并没有偏离主题，并没有为了造而造。</p>

<p><br/></p>

<p>这也是<strong>不得已而为之</strong>的事情。</p>

<p><br/></p>

<h2><strong>工具的创造者和使用者</strong></h2>

<p>在大多数人眼中，</p>

<p>工具都是一些人造出来，给另外一些不同的人来使用的，</p>

<p>这里就又有误区了。</p>

<p><br/></p>

<p>其实不必强制如此，</p>

<p>一个能工巧匠，必然有<strong>自己的</strong>一套工具箱，</p>

<p>这些工具箱中都是他趁手的工具。</p>

<p><br/></p>

<p>这些工具，全是跟别人一样的吗？</p>

<p>未必啊。</p>

<p>有雷同的，有调整过的，更有自创的。</p>

<p><br/></p>

<p>工具完全可以自己造给自己用，是<strong>为了给自己的工作助力</strong>，</p>

<p>在软件行业，这有一个名词叫『dog fooding』，</p>

<p>很多软件公司都深谙此道。</p>

<p><br/></p>

<p>比如，Visual Studio本来只是Microsoft内部使用的一个编辑器，</p>

<p>随着不断完善，它完全可以作为一个产品来卖了，</p>

<p>那么就可以拿出来了，面向普通大众开放了。</p>

<p><br/></p>

<p>再比如，Facebook很多项目都主张尽量开源，</p>

<p>首先解决本公司自己的问题，</p>

<p>再通过解决社区的问题逐渐完善，同时也降低了维护成本。</p>

<p><br/></p>

<p>此外，如果不事先限定工具的未来使用者的话，</p>

<p>还会促进人们对工具进行更好的设计。</p>

<p><br/></p>

<p>另一方面，有些人喜欢写工具给别人用，</p>

<p>但是，<strong>眼高手低，只是解决一些假想的问题</strong>，过于理想主义。</p>

<p><br/></p>

<p>不能解决问题的工具，还不如没有，</p>

<p>它会造成解决方案的混乱，加大原始问题的难度。</p>

<p><br/></p>

<p>因此，工具的创造者和使用者，必须紧密合作。</p>

<p>工具才能发挥它最大的作用。</p>

<p><br/></p>

<h2><strong>业务逻辑并不啰嗦</strong></h2>

<p>有些人不喜欢写业务逻辑，说是因为它繁琐。</p>

<p>我觉得这是对编程认识的<strong>偏见</strong>。</p>

<p><br/></p>

<p>因为编程就是用代码解决问题的，</p>

<p>业务逻辑繁琐，本身就是一个问题。</p>

<p><br/></p>

<p>我们完全可以写一个业务逻辑的管理器，</p>

<p>把这些复杂业务逻辑分离开，然后用这个管理器统筹规划，</p>

<p>非常干净清爽了，不是吗？</p>

<p><br/></p>

<p>因此，这种情况下，代码要做的事情不是关键，</p>

<p><strong>关键在于，怎样写，用什么样的策略来写，</strong></p>

<p><strong>没有注定繁琐的代码，只有不合理的繁琐表述。</strong></p>

<p><br/></p>

<h2><strong>工具还可以用来制造工具</strong></h2>

<p>只要存在问题，我们就可以想到借助工具来解决它，</p>

<p>那么假设这里有好多人需要斧子这种工具，</p>

<p>就要造出那么多斧子来吗，好累啊。</p>

<p><br/></p>

<p>其实，这引出了另外一个问题，</p>

<p>那就是如何制造多个斧子的问题。</p>

<p><br/></p>

<p>我们可以造一个机器，它用来生产斧子，</p>

<p>这个机器，就是<strong>用来制造工具的工具</strong>，</p>

<p>而制作这个机器所用的道具，同样也是工具。</p>

<p><br/></p>

<p>原来，世界这么奇妙，</p>

<p>工具可以组合，还可以互相影响。</p>

<p><br/></p>

<h2><strong>学会别人的设计思想</strong></h2>

<p>当我们定位问题后，怎样将适用工具制造出来呢？</p>

<p>现存的解决方案是怎样想出来的呢？</p>

<p><br/></p>

<p>这就得求助历史了，求助于同行们前辈们的经验教训。</p>

<p><br/></p>

<p>我们要先找到类似的工具，</p>

<p><strong>看它是如何解决问题的，用了什么办法，它的作者是怎么想的。</strong></p>

<p><br/></p>

<p>学会了这些，抓住思考问题的方式，</p>

<p>我们就能<strong>随机应变，灵活处理</strong>，做出趁手适用的工具来。</p>

<p><br/></p>

<p>其他工具中任何有用的部分，都可以借来，只要能达到目的。</p>

<p>即，目的明确后，方法可以灵活多变。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>过分的依赖工具和过度的排斥工具，都是盲目的。</p>

<p><strong>做到正视一个事物，是非常困难的。</strong></p>

<p><br/></p>

<p>jQuery的作者在《Secrets of the JavaScript Ninja》中所言，</p>

<p>很多人都被教导说，不要使用eval，这是不对的，</p>

<p>相反，<strong>我们应该学会它，从而才有能力善用它。</strong></p>

<p><br/></p>

<p>对于其他事物也是如此啊，</p>

<p>全盘接受和全盘否定，都会丢掉半壁江山，</p>

<p>我们要深入理解，目的是把它用到可以用的地方，发挥它的作用。</p>

<p><br/></p>

<p>不理解它，怎么做到在需要的时候使用呢？</p>

<p><br/></p>

<p>君子生非异也，善假于物也。</p>

<p>——荀子《劝学》</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件工程师的前瞻性]]></title>
    <link href="https://thzt.github.io/blog/2016/03/08/forward-looking-engineer/"/>
    <updated>2016-03-08T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/03/08/forward-looking-engineer</id>
    <content type="html"><![CDATA[<p>受过多年学校教育的我们，容易产生一个误区。</p>

<p>我们学会了很多知识，学会了怎样解决问题，</p>

<p>但是却不知道这些问题是怎么来的，</p>

<p>以后将要如何发展。</p>

<p><br/></p>

<p>我们要解决的问题都是静态的，</p>

<p>只要我们给出方案，</p>

<p>那它就永远是这个问题的解。</p>

<p><br/></p>

<p>然而，现实生活中的问题，却复杂得多。</p>

<p><br/></p>

<p>我们不仅需要考虑问题的解法，</p>

<p>而且更重要的还要考虑问题本身。</p>

<p>我们当前是否在把精力用于解决一个正确的问题，还说不定，</p>

<p>我们的方案是否在一段时间内仍然有效，也未可知。</p>

<p><br/></p>

<p>这也是软件行业的主要特点。</p>

<p><br/></p>

<h2><strong>困难的软件工程</strong></h2>

<p>人们常把软件工程比作建筑，我认为这极不合理。</p>

<p>完全忽视了软件的本质特点。</p>

<p><br/></p>

<p>与建筑行业不同的是，软件所解决的问题都是动态的，</p>

<p>楼还没有盖完，我们的图纸就变了，</p>

<p>怎样在这种情况下把楼盖起来，才是软件工程所面临的问题。</p>

<p><br/></p>

<p>诚然，用户的需求是不稳定的，今天说这个，明天说那个，</p>

<p>但这并不是一个主要方面。</p>

<p>短期内，需求的稳定性取决于我们的挖掘和控制。</p>

<p><br/></p>

<p>然而，从长远来看，市场在变，业务在变，</p>

<p>用户使用软件的目的就会改变，</p>

<p>软件岂能不变？</p>

<p><br/></p>

<p>采取什么样的方案，应对这些发展中的业务需要，</p>

<p>才是软件要解决的本质问题。</p>

<p><br/></p>

<p>这是困难的。</p>

<p><br/></p>

<p>且不谈增加新功能了，</p>

<p>甚至对于有缺陷的地方进行修改，也得慎重考虑。</p>

<p>所有依赖这个错误的特性而表现良好的程序，都是有问题的。</p>

<p><br/></p>

<p>每改一处都可能意味着全盘重写。</p>

<p><br/></p>

<h2><strong>编程层面的技术修炼</strong></h2>

<p>好的软件工程师，可以隔离变化，简化依赖关系。</p>

<p>他们通过抽象搭建框架，通过组装分离影响，</p>

<p>让每一个功能点都是可拆卸的。</p>

<p><br/></p>

<p>为了抽象，就得理解问题背后的数学结构，</p>

<p>为了封装，就得理解子问题之间的逻辑关联。</p>

<p><br/></p>

<p>好的代码，行云流水，层次分明，逻辑清晰，赏心悦目，</p>

<p>更重要的是，解决了当前问题，并留有余地。</p>

<p><br/></p>

<p>到了这一步，才可以谈论软件是如何进行设计的了，</p>

<p>的确，编程是一门设计手法，</p>

<p>更多的是考虑如何描述，如何组织，如何扩展等等问题。</p>

<p><br/></p>

<p>不但如此，一个架构师，还要考虑如何量产，</p>

<p>如何并行开发，如何降低抽象层次，</p>

<p>如何交流，如何推广。</p>

<p><br/></p>

<p>这绝对是一门手艺。</p>

<p><br/></p>

<h2><strong>工程师需要前瞻性</strong></h2>

<p>要想给出一个灵活可扩展的方案，</p>

<p>只是知道用动态的观点看待问题，作用是微小的。</p>

<p>我们还需要明白业务场景，分析它的趋势，看到它的未来。</p>

<p><br/></p>

<p>随着业务规模扩大，软件越来越复杂，</p>

<p>前瞻性将是衡量一个软件工程师的首要标准了，</p>

<p>这也是工程与编程的重要区别。</p>

<p><br/></p>

<p>可是，要想获得前瞻性是很难的，</p>

<p>我们必须先认识当前，明白现状，</p>

<p>必须跳出当前的生活，从更高的角度俯视它。</p>

<p><br/></p>

<p>我们得看到，现行方案已经帮助问题解决到了什么程度，</p>

<p>当前的痛点在哪，客观约束条件有哪些，</p>

<p>只有看清这些，才能确定目的地和实现路线。</p>

<p><br/></p>

<p>没有前瞻性的工程师是可怕的，</p>

<p>因为他自己都不知道要去哪，以及正在做什么，</p>

<p>那么他当前选择的路线就可能是盲目的，有风险的。</p>

<p><br/></p>

<p>只有确定目标，并逐步实现，</p>

<p>才有达到目标的可能。</p>

<p><br/></p>

<p>世界上，可没有那么多的巧合出现。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>知道自己在哪里，有计划要去哪里，</p>

<p>并努力付诸实践，才能达成目标。</p>

<p><br/></p>

<p>人们在计划出行时，总是这么考虑，</p>

<p>然而在其他问题上却容易迷茫</p>

<p><br/></p>

<p>其实，当不知道自己要去哪里的时候，</p>

<p>往往是对现在做的事情，不求甚解。</p>

<p><br/></p>

<p>还是从认识自己开始吧，</p>

<p>锻炼有前瞻性的思维习惯，</p>

<p>才能越走越稳，看尽沿途的风光美景。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[消除重复与可复用相距多远]]></title>
    <link href="https://thzt.github.io/blog/2015/09/11/reuse-oriented-programming/"/>
    <updated>2015-09-11T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/09/11/reuse-oriented-programming</id>
    <content type="html"><![CDATA[<p>程序员们都讨厌重复，</p>

<p>因为他们知道，</p>

<p>这是可以避免的冗余工作量。</p>

<p>——代码坏味</p>

<p><br/></p>

<p>如果本来就不可避免，</p>

<p>那只好认了，</p>

<p>就好像需求不可能不变的事实一样。</p>

<p><br/></p>

<p>但是，<strong>盲目的消除重复</strong>，</p>

<p>并不是正确的姿势，</p>

<p>反而会把简单的事情搞复杂。</p>

<p><br/></p>

<p>为什么程序员们甘心写那么多“public class XXX {}”，</p>

<p>甘心写那么多“END”，“;”或者“)”，</p>

<p>而不设法避免呢？</p>

<p><br/></p>

<p>为什么不把所有的“this”都提取出来，</p>

<p>放在一个地方，</p>

<p>在编译前，再把他们塞入代码中呢。</p>

<p><br/></p>

<p>诚然，通过macro，</p>

<p>可以做一些代码生成之类的事情，</p>

<p>但是直觉告诉我们，不能乱来。</p>

<p><br/></p>

<p>原因是什么？</p>

<p>消除重复与面向复用其实还相距太远。</p>

<p><br/></p>

<h2>什么是面向复用的编程</h2>

<p>“面向”，指的是目的，目标。</p>

<p><br/></p>

<p>方法论告诉我们，</p>

<p>要完成一件事需要3个步骤，</p>

<p>（1）确定目标</p>

<p>（2）分析差距</p>

<p>（3）缩小差距</p>

<p><br/></p>

<p>确定目标是第一步。</p>

<p><br/></p>

<p>要想让我们的程序被复用，</p>

<p>首先他要设计成<strong>可以</strong>被复用的，</p>

<p>不是哪天要用了，忽然就行了。</p>

<p><br/></p>

<p>而且，在一套软件中，</p>

<p>并不是所有的代码都是可复用的，</p>

<p>有些根本无法复用。</p>

<p><br/></p>

<p>承认了这两个事实以后，</p>

<p>任务一下子简单了很多。</p>

<p><br/></p>

<h2><strong>提取并不意味着抽象</strong></h2>

<p>一段代码，在很多地方都出现了，</p>

<p>我们马上就能想到，</p>

<p>把它<strong>提取</strong>到了一个函数中。</p>

<p><br/></p>

<p>然而这对可复用并没有任何作用，</p>

<p>我们只是凑巧成功了几次。</p>

<p><br/></p>

<p>假如某个调用处的<strong>业务逻辑</strong>发生了变化，</p>

<p>我们就遇到麻烦了，</p>

<p>不能修改提取出去的代码，因为别人也在用，</p>

<p>还要把代码再复制回去，只调整这一块。</p>

<p><br/></p>

<p>自讨苦吃啊。</p>

<p>那可如何是好？</p>

<p><br/></p>

<p>这是因为，提取和抽象是不同的，</p>

<p>提取是文本层次的观察，</p>

<p>而抽象是逻辑层次的考察。</p>

<p><br/></p>

<p>这段代码虽然在很多地方出现了，</p>

<p>可是它却由不同的<strong>逻辑单元</strong>组成，</p>

<p>这就隐藏了很多引起它改变的因素。</p>

<p>——单一职责原则</p>

<p><br/></p>

<p>我们应该先把这些逻辑单元封装好，</p>

<p>然后<strong>拼装</strong>出统一的抽象接口，</p>

<p>各处对接口进行调用。</p>

<p>——依赖倒置原则</p>

<p>——合成/聚合复用原则</p>

<p><br/></p>

<p>一旦某个逻辑单元需要调整了，</p>

<p>那么只需要单独为某处调用，</p>

<p>再<strong>实现</strong>一个新的接口函数就行了。</p>

<p>——开-闭原则</p>

<p><br/></p>

<h2><strong>外表要简单，内心不要太简单</strong></h2>

<p>有人觉得有个<strong>拼装层</strong>太麻烦了，</p>

<p>还不如直接提取函数好呢，</p>

<p>这其实是混淆了抽象与实现。</p>

<p><br/></p>

<p>接口的使用者是看不到实现方式的，</p>

<p>实现很复杂是为了有更高的灵活性。</p>

<p>——迪米特法则</p>

<p><br/></p>

<p><strong>语言的魅力不就是，把复杂藏于只言片语之后吗？</strong></p>

<p>编程的目的不就是，为多变的业务逻辑提供简洁的描述语言吗？</p>

<p>——领域特定语言</p>

<p><br/></p>

<p>一切都应该尽可能地简单,但不要太简单。</p>

<p>——爱因斯坦</p>

<p><br/></p>

<h2><strong>业务与功能</strong></h2>

<p>经常变动的是业务逻辑，</p>

<p>而可复用的是功能模块。</p>

<p><br/></p>

<p>对逻辑我们要抽象，</p>

<p>而对功能我们要封装。</p>

<p><br/></p>

<p><strong>很多新手认为，</strong></p>

<p><strong>把相关的代码组织在一起就是封装了，</strong></p>

<p><strong>这与认为把代码提取出来了就是抽象了一样失败。</strong></p>

<p><br/></p>

<p>要封装，是因为它们“能够封装”，</p>

<p>而不是代码恰好出现在了一起。</p>

<p><br/></p>

<p>只有<strong>与要描述的业务无关</strong>的功能，</p>

<p>才是可复用的单元。</p>

<p><br/></p>

<p>每个页面都发送AJAX请求，</p>

<p>然后更新一个id=&ldquo;message"的标签，</p>

<p>这是不可封装的。</p>

<p><br/></p>

<p>而发送AJAX模块，</p>

<p>更新任一标签内容的模块，</p>

<p>才是可封装的。</p>

<p><br/></p>

<p>一致的业务流程，也是可以封装的。</p>

<p>例如，如果有定时任务，</p>

<p>可以封装一个定时任务管理器，</p>

<p>只需要挂载任务的配置信息就可以自动执行。</p>

<p><br/></p>

<p>对了，别人有写好了的，</p>

<p>不用自己做，</p>

<p>但我们要这么想。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>能闻到坏味是好事，</p>

<p>但是不正确的打扫方法，</p>

<p>反而会使代码更难维护。</p>

<p><br/></p>

<p>消除重复是表象，</p>

<p>而面向复用才是目的。</p>

<p><br/></p>

<p><strong>和别人读同样的书，</strong></p>

<p><strong>不一定考上一样的大学，</strong></p>

<p><strong>更不一定有相同的人生。</strong></p>
]]></content>
  </entry>
  
</feed>
