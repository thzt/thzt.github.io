<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Design | 何幻]]></title>
  <link href="https://thzt.github.io/blog/categories/design/atom.xml" rel="self"/>
  <link href="https://thzt.github.io/"/>
  <updated>2016-09-07T15:52:57+08:00</updated>
  <id>https://thzt.github.io/</id>
  <author>
    <name><![CDATA[thzt]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[如何应对需求变更]]></title>
    <link href="https://thzt.github.io/blog/2016/06/02/requirement-change/"/>
    <updated>2016-06-02T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/06/02/requirement-change</id>
    <content type="html"><![CDATA[<h2><strong>对需求的误解</strong></h2>

<p>同学们经常提及的需求变更，其实变更的并不是需求，而是需求的实现方案。</p>

<p>首先，我们要对需求和方案进行区分。</p>

<p>需求包括以下几个方面，需求背景，需求目的，需求范围，需求的详细规格，以及错误处理方式。</p>

<p>UI/UE/UX，前端，后端，共同实现了需求，是同一个解决方案的不同侧面。</p>

<p><br/></p>

<p>因此从广义上来讲，开发者之间的内部沟通，不属于需求变更范畴。</p>

<p>软件的大部分问题，存在于开发者之间的沟通上面，而不是开发者对需求的理解上面。</p>

<p>只有理解了什么是需求，才能衡量出需求是否变更了。</p>

<p><br/></p>

<blockquote><p>在软件工程中，需求分析指的是在建立一个新的或改变一个现存的电脑系统时描写新系统的目的、范围、定义和功能时所要做的所有的工作。</p></blockquote>

<p><br/></p>

<h2><strong>从方法到目的</strong></h2>

<p>实现一个目的有多种方法，如何看到这些方法的共性呢？</p>

<p>最快的方式就是找到这些方法要解决的问题。</p>

<p>软件是以解决问题为目的的，不能解决问题的软件没有任何作用。</p>

<p><br/></p>

<p>这要分两方面来说，</p>

<p>其一，当产品经理发起需求变更时，我们要积极配合。因为，需求变更的主要原因在于当前软件不能解决某些问题。</p>

<p>不配合，那么做出的软件就没有用，我们的工作就没有价值。</p>

<p><br/></p>

<p>其二，我们要知道当前软件要解决的问题是什么，才能灵活的改变策略。</p>

<p>甚至可以利用工程师的领域特长，找到更合适的解决方案。</p>

<p><br/></p>

<h2><strong>变更与管控</strong></h2>

<p>我们不怕变化，怕的是对变化失去控制。</p>

<p>当产品经理发起需求变更时，我们要重新安排未完成任务的优先级，这是需要与产品经理沟通的。</p>

<p>因为，变更是需要成本的，意味着原计划要做的某些事情不能做完了，我们得让他们知道。</p>

<p><br/></p>

<p>我们自己首先得有一个任务列表。</p>

<p>然后以优先级的方式管理待办事项。</p>

<p><br/></p>

<h2><strong>知识共享</strong></h2>

<p>不同的人，对需求的理解不同。</p>

<p>每个人都会按照自己的方式去实现想法。</p>

<p>如何设计一个策略，怎样实现这个设计，大相径庭。</p>

<p><br/></p>

<p>因此，我们要预先做一些知识的分享。</p>

<p>在设计阶段排除问题，会比在实现阶段排除问题，成本低很多。</p>

<p>我们不妨谈一谈，我计划怎样解决这个问题，我打算怎样实现。</p>

<p>因为，很有可能，这个计划就是错的。</p>

<p><br/></p>

<h2><strong>主动去沟通</strong></h2>

<p>如果我想改某个文件，担心其他人也在改，以后合并起来麻烦，怎么办？</p>

<p>去问他/她。</p>

<p>某位同学的代码我看不懂，不敢改怎么办？</p>

<p>去问他/她。</p>

<p>产品经理对需求的描述不清楚，我理解不了怎么办？</p>

<p>去问他/她。</p>

<p>交互稿中文案可能有错误，逻辑矛盾，怎么办？</p>

<p>去问他/她。</p>

<p>测试提了一个缺陷，可是我不知道在说什么，也不知道在哪个场景中会出现，怎么办？</p>

<p>去问他/她。</p>

<p><br/></p>

<p>&ldquo;问"，这个简单的动作，会节省大量的时间。</p>

<p>如果不想打断别人的工作，可以用一些非即时沟通工具。</p>

<p>或者走到他旁边，让他注意到你时，你再发问。</p>

<p><br/></p>

<p>提问，并不愚蠢，不问才蠢。</p>

<p>要相信大部分工程师都是喜欢被问的。</p>

<p><br/></p>

<h2><strong>让设计灵活响应变更</strong></h2>

<p>好的设计，在变更中灵活响应。</p>

<p>这实际上是对设计提出了更高的要求，不止是实现功能那么简单了。</p>

<p><br/></p>

<p>因为现实世界是发展中的，业务场景也在与时俱进。</p>

<p>因此，需求本身不可能是不变的。</p>

<p>软件是一个解决动态问题的方案。</p>

<p><br/></p>

<p>程序设计是用来解决发展中问题的。</p>

<p>我们要看到问题的发展趋势，结合整个过程进行设计。</p>

<p>给未来留下余地，不局限于当前状态进行设计。</p>

<p><br/></p>

<p>需求你怎么改都行，因为你不得不改，我也不得不照做，不然软件本身就没用了。</p>

<p>但是我的设计保障我修改的成本最低。</p>

<p><br/></p>

<h2><strong>原谅别人的失误</strong></h2>

<p>人非圣贤孰能无过。</p>

<p>我们会因为手误打错代码，也会因为大脑一时短路犯逻辑错误。</p>

<p>那么，产品经理同样也会对需求理解和描述产生偏差。</p>

<p>我们不能要求别人做到完美。</p>

<p><br/></p>

<p>一方面，我们要原谅他们，但要让他们知道大家的代价。</p>

<p>另一方面，我们要听思想，不要听描述。抓住中心思想，忽略细节。</p>

<p><br/></p>

<p>严于律己，宽以待人。</p>

<h2><strong>结语</strong></h2>

<p>大部分软件从业者，没有软件工程相关的培训，也没有阅读过相关书籍，</p>

<p>是依靠自己的感觉来做软件的。</p>

<p><br/></p>

<p>结果会沿用一些不恰当的类比来理解软件，</p>

<p>也会逐渐形成小作坊式的软件开发过程。</p>

<p>当团队规模扩大时，问题就会越来越严重。</p>

<p><br/></p>

<p>不过，没关系，这有什么。</p>

<p>痛了才会想办法去解决，也无需过度设计。</p>

<p>只是现在我们是否该学一些软件工程的知识了呢？</p>

<p><br/></p>

<p><strong>参考：</strong></p>

<p><a href="https://book.douban.com/subject/1007738/">快速软件开发</a></p>

<p><a href="https://book.douban.com/subject/1140457/">敏捷软件开发 : 原则、模式与实践</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[让事情去发生]]></title>
    <link href="https://thzt.github.io/blog/2016/05/29/let-things-happen/"/>
    <updated>2016-05-29T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/05/29/let-things-happen</id>
    <content type="html"><![CDATA[<p>经验增长，并不完全是一件好事，</p>

<p>它也许会阻止本来可能发生的事情。</p>

<p><br/></p>

<p>我们凭着经验来进行判断，</p>

<p>除非遇到完全相同的初始条件，</p>

<p>否则，这样的判断和随意猜测并没有什么不同。</p>

<p><br/></p>

<p>我们踩到的坑多了，走路都战战兢兢，</p>

<p>一年被蛇咬，十年怕井绳。</p>

<p><br/></p>

<p>如何打破经验主义的误区呢？</p>

<p>那就是，让事情去发生。</p>

<p><br/></p>

<p>现实世界中的事情都是发展中的，</p>

<p>我们得有胆量让事情去发展，</p>

<p>然后掌控它的发展过程。</p>

<p><br/></p>

<h2><strong>把责任交出去</strong></h2>

<p>篮球是一项团体运动，</p>

<p>在打篮球时，我们用的最多的是传接球。</p>

<p><br/></p>

<p>可是，新手组织后卫往往无法理解，</p>

<p>球传出去以后，自己都无法掌控它了，</p>

<p>怎样组织这次进攻呢？</p>

<p><br/></p>

<p>这类似于其他团队合作中的责任，</p>

<p>不敢把责任交出去，</p>

<p>担心别人做不好。</p>

<p><br/></p>

<p>这样就无法达到默契的配合。</p>

<p><br/></p>

<p>高手组织后卫怎样理解这件事情呢？</p>

<p>他首先会观察比赛的发展态势，</p>

<p>然后通过运球去影响这个态势的走向，</p>

<p>随后，把球顺着态势传出去。</p>

<p><br/></p>

<p>这样的话，其他人的行为就会被态势所牵引。</p>

<p>比赛仍然在掌控中。</p>

<p><br/></p>

<p>所以，难能可贵的是，</p>

<p>让比赛进行，把球传出去。</p>

<p><br/></p>

<h2><strong>最佳实践</strong></h2>

<p>软件项目中，有前人总结的无数最佳实践，</p>

<p>不遵循它们，会犯很多前人已经犯过的错误。</p>

<p><br/></p>

<p>然而，完全遵循它们，</p>

<p>又会抹杀掉未来的某些可能性。</p>

<p><br/></p>

<p>每种方案都有适得其所的用处，</p>

<p>没有在任何情况下都不适用的方案，</p>

<p>不用它，其实很多人是因为没有真正掌握它。</p>

<p><br/></p>

<p>很多方案是发展而来的，</p>

<p>到了那个境地，解决方案是显而易见的，</p>

<p>现在不用费尽心思，假定到时候很糟。</p>

<p><br/></p>

<p>最佳实践的作用，应该是为了选择方向，</p>

<p>强行预测未来的细节，会担惊受怕，畏首畏尾。</p>

<p><br/></p>

<p>你有胆量让不那么好的事情发生吗？</p>

<p>其实，不那么好与不那么坏，并没有什么区别。</p>

<p><br/></p>

<h2><strong>如何培养人</strong></h2>

<p>世界上最困难的就是把一件你很拿手的工作交给别人，</p>

<p>再眼睁睁看着他把事情搞砸，</p>

<p>而你却还能心平气和不发一言，</p>

<p>那是培养人。</p>

<p>世界上最容易的就是把一件你很拿手的工作交给别人，</p>

<p>再手把手地教他把事情做对，</p>

<p>不给他犯错机会，</p>

<p>那不是培养人，而是锻炼你自己。</p>

<p>——《有一种培养叫放手》</p>

<p><br/></p>

<p>并不是每件事情按计划发生就是好的，</p>

<p>不同的发展轨迹，人们从中的收获也不同。</p>

<p><br/></p>

<p>不让坏事情去发生，就不会身临其境，</p>

<p>没有把事情搞砸过，就不会反思过程。</p>

<h2><strong>人与事情的发展</strong></h2>

<p>事情的发展，总是会涉及到很多人，</p>

<p>因此，个人的作用其实并不那么重要。</p>

<p><br/></p>

<p>让事情去发展，才能观察态势，</p>

<p>才能改变它，才能影响它。</p>

<p><br/></p>

<p>不要把自己看得那么重要，</p>

<p>包括自己在内，大家都是顺势而为，</p>

<p>不改变态势，结果早就被决定了，</p>

<p>有你没你都一样。</p>

<p><br/></p>

<p>所以，要想赢得比赛，</p>

<p>就得做那个能影响比赛走势的人。</p>

<p><br/></p>

<p>不然的话，</p>

<p>胜败已定，预测的再准又有什么用？</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>Let things happen, let them win.</p>

<p>这不仅仅是一种洒脱的态度，</p>

<p>更多的是为了影响事情的整个发展过程。</p>

<p><br/></p>

<p>如果说，新手从犯错，到学会提前意识到错误，是一个进步，</p>

<p>那么老手从丰富的经验，到违反经验的大胆尝试，更是一个进步。</p>

<p><br/></p>

<p>新手，通常把方案静态的理解为当前场景的解，</p>

<p>而高手，更能看到事情的发展过程，</p>

<p>以及采取某个方案，会对事情发展产生什么影响。</p>

<p><br/></p>

<p>让事情发生吧，我来做观众。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面向痛点的应变之道]]></title>
    <link href="https://thzt.github.io/blog/2016/05/16/pain-oriented-design/"/>
    <updated>2016-05-16T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/05/16/pain-oriented-design</id>
    <content type="html"><![CDATA[<p>上学写论文时，流传着这么一句话，</p>

<p>『大家虽然不知道鬼的样子，却都在画鬼。』</p>

<p>当时，觉得好有道理啊，我们提出了各种理论模型，却不知道世界到底是什么样子。</p>

<p><br/></p>

<p>没想到后来进入了软件行业，也会遇到同样的问题。</p>

<p><br/></p>

<p>我们很多项目，发起人其实并不知道要做成什么，</p>

<p>只是想做这个，想做那个，</p>

<p>似乎把想做的功能都做完，项目就成了。</p>

<p><br/></p>

<p>我们假想存在某个问题，甚至都没有去调查，</p>

<p>我们觉得别人一定会来用，甚至都没想着去接受反馈，</p>

<p>我们自以为现存方案的问题很多，甚至都没用过它。</p>

<p><br/></p>

<p>这就是在『<strong>画鬼</strong>』，</p>

<p>是一群人憋着实在想做些什么的时候的宏观表现。</p>

<p><br/></p>

<p>那么，我们积极向上的心态，不对吗，</p>

<p>我们想造福社会，推动进步，不好吗？</p>

<p><br/></p>

<p>当然好，只不过要坚持一些设计原则。</p>

<p><br/></p>

<h2><strong>痛点</strong></h2>

<p>学过软件工程之后，我们知道，进行需求分析时，我们得先确定需求的背景和目的。</p>

<p>为什么要做这件事，是什么引起的，<strong>动机</strong>是什么。</p>

<p>只有确定了问题，才能有的放矢。</p>

<p>这是对新项目而言。</p>

<p><br/></p>

<p>而对于实际的项目，几乎都是以现有的解决方案为起点的，</p>

<p>我们还要问，当前方案的<strong>痛点</strong>是什么，哪里做的不够好，</p>

<p>这些问题的优先级怎么安排，怎样逐步解决它。</p>

<p><br/></p>

<p>通过分析痛点，我们才能找到<strong>立项的原因</strong>。</p>

<p>不是我们想做什么，而是我们不得不解决它。</p>

<p>没有迫不得已的形势，事情就不会往前发展。</p>

<p><br/></p>

<p>我们不要急着去解决问题，</p>

<p>而是先要确定，<strong>到底要解决什么问题</strong>。</p>

<p><br/></p>

<h2><strong>应变之道</strong></h2>

<p>应变，是可以锻炼的。</p>

<p><br/></p>

<p>看到每一个方案时，不妨考虑下，它们是<strong>怎样被设计出来的</strong>。</p>

<p>这样才能积累经验，在遇到困难的时候，找到切实可用的办法。</p>

<p><br/></p>

<p>每一个解决方案，都是为它的目的服务的，</p>

<p>人们做了哪些折衷和让步，又是以何种程度达到目的的。</p>

<p><br/></p>

<p>我们要学的，不是会用哪些招数，</p>

<p>而是，<strong>学会这些招数的创造方法</strong>。</p>

<p><br/></p>

<p>由此，繁杂的方案就不会迷惑我们了，</p>

<p>像工匠能看到工具的问题一样，我们会看到<strong>方案的缺陷</strong>，和它们引起的新问题。</p>

<p><br/></p>

<p>无招胜有招。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>不能确定待解决的问题。</p>

<p>给定一个问题，想不出适用的解决方案。</p>

<p><br/></p>

<p>这是两个难点。</p>

<p>我们会假想一个问题，结果做完了以后才发现白费心思。</p>

<p>我们会用流行的解决方案，结果发现越走越远。</p>

<p><br/></p>

<p>经验多了，熟练掌握各种框架类库之后，这两个能力并不会相应提高。</p>

<p>我们需要刻意的训练，才能学会『面向痛点的应变之道』。</p>

<p><br/></p>

<p>Love of bustle is not industry. ——Seneca</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[论工具]]></title>
    <link href="https://thzt.github.io/blog/2016/03/11/tools/"/>
    <updated>2016-03-11T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/03/11/tools</id>
    <content type="html"><![CDATA[<p>中学的历史课本上曾经讲过，</p>

<p>学会制作工具，是人类进步的标志。</p>

<p><br/></p>

<p>我深以为然。</p>

<p>可是现实生活中，<strong>存在着对工具很多的误解</strong>。</p>

<p><br/></p>

<p>有的人，认为制作工具浪费时间和精力，做了不必要的事情，</p>

<p>有的人，认为既然有现成的工具可用，为什么还要自己造轮子。</p>

<p>有的人，认为应该专门区分开制作工具的人和使用工具的人。</p>

<p><br/></p>

<p>这些看法，在各自的角度来讲，都说的通，</p>

<p>可以没有对工具有个<strong>全面的</strong>认识。</p>

<p><br/></p>

<p>下面，我们仔细分析一下，</p>

<p>看能不能从更高的角度来看待它，</p>

<p>做好工具，用好工具。</p>

<p><br/></p>

<h2><strong>工具就是解决方案</strong></h2>

<p>无论是日常生活中，还是在软件开发中，</p>

<p>我们经常有直接解决问题的场景，</p>

<p>貌似并没有使用工具。</p>

<p><br/></p>

<p>这就给了人们一种<strong>假象</strong>，</p>

<p>那种特意找来的才叫工具，</p>

<p>用了别人的东西，才叫用了工具。</p>

<p><br/></p>

<p>其实不然。</p>

<p>一个<strong>解决方案</strong>，实际上就是一个具体的工具了，</p>

<p>只不过它只能用来解决那个问题罢了。</p>

<p><br/></p>

<p>好的解决方案，就好比适用的工具，</p>

<p>用最直接的办法解决了问题，</p>

<p>不拖泥带水，不带来附加的问题。</p>

<p><br/></p>

<h2><strong>不得已而造轮子</strong></h2>

<p>着手实施的过程，</p>

<p>实际上就是将目前的项目问题<strong>还原</strong>成历史上已经解决过问题的过程。</p>

<p><br/></p>

<p>这个阶段，我们在进行问题求解。</p>

<p>为了尽可能的少耗费精力，我们总会优先选择已经成型的工具，</p>

<p>在软件开发中，相当于找到各种类库，框架来用。</p>

<p><br/></p>

<p>可是，市面上广为流传的那些通用工具，</p>

<p>并不一定非常切题，我们必须做出调整，甚至废弃一部分功能，</p>

<p>这个时候，就有点造轮子的萌芽了。</p>

<p><br/></p>

<p>随着业务的发展，业务模型逐渐清晰起来了，</p>

<p>没有趁手的工具，也无法跟得上业务的发展需要了，</p>

<p><strong>只能从基础开始，借用各种工具的设计思想，让工具和业务共同发展。</strong></p>

<p><br/></p>

<p>此之所谓，重新造轮子。</p>

<p><br/></p>

<p>这样不好吗？</p>

<p>在项目初期，诚然不太合适，</p>

<p>但是，全程中我们的目的都是为了找到合适的工具解决问题呀，</p>

<p>并没有偏离主题，并没有为了造而造。</p>

<p><br/></p>

<p>这也是<strong>不得已而为之</strong>的事情。</p>

<p><br/></p>

<h2><strong>工具的创造者和使用者</strong></h2>

<p>在大多数人眼中，</p>

<p>工具都是一些人造出来，给另外一些不同的人来使用的，</p>

<p>这里就又有误区了。</p>

<p><br/></p>

<p>其实不必强制如此，</p>

<p>一个能工巧匠，必然有<strong>自己的</strong>一套工具箱，</p>

<p>这些工具箱中都是他趁手的工具。</p>

<p><br/></p>

<p>这些工具，全是跟别人一样的吗？</p>

<p>未必啊。</p>

<p>有雷同的，有调整过的，更有自创的。</p>

<p><br/></p>

<p>工具完全可以自己造给自己用，是<strong>为了给自己的工作助力</strong>，</p>

<p>在软件行业，这有一个名词叫『dog fooding』，</p>

<p>很多软件公司都深谙此道。</p>

<p><br/></p>

<p>比如，Visual Studio本来只是Microsoft内部使用的一个编辑器，</p>

<p>随着不断完善，它完全可以作为一个产品来卖了，</p>

<p>那么就可以拿出来了，面向普通大众开放了。</p>

<p><br/></p>

<p>再比如，Facebook很多项目都主张尽量开源，</p>

<p>首先解决本公司自己的问题，</p>

<p>再通过解决社区的问题逐渐完善，同时也降低了维护成本。</p>

<p><br/></p>

<p>此外，如果不事先限定工具的未来使用者的话，</p>

<p>还会促进人们对工具进行更好的设计。</p>

<p><br/></p>

<p>另一方面，有些人喜欢写工具给别人用，</p>

<p>但是，<strong>眼高手低，只是解决一些假想的问题</strong>，过于理想主义。</p>

<p><br/></p>

<p>不能解决问题的工具，还不如没有，</p>

<p>它会造成解决方案的混乱，加大原始问题的难度。</p>

<p><br/></p>

<p>因此，工具的创造者和使用者，必须紧密合作。</p>

<p>工具才能发挥它最大的作用。</p>

<p><br/></p>

<h2><strong>业务逻辑并不啰嗦</strong></h2>

<p>有些人不喜欢写业务逻辑，说是因为它繁琐。</p>

<p>我觉得这是对编程认识的<strong>偏见</strong>。</p>

<p><br/></p>

<p>因为编程就是用代码解决问题的，</p>

<p>业务逻辑繁琐，本身就是一个问题。</p>

<p><br/></p>

<p>我们完全可以写一个业务逻辑的管理器，</p>

<p>把这些复杂业务逻辑分离开，然后用这个管理器统筹规划，</p>

<p>非常干净清爽了，不是吗？</p>

<p><br/></p>

<p>因此，这种情况下，代码要做的事情不是关键，</p>

<p><strong>关键在于，怎样写，用什么样的策略来写，</strong></p>

<p><strong>没有注定繁琐的代码，只有不合理的繁琐表述。</strong></p>

<p><br/></p>

<h2><strong>工具还可以用来制造工具</strong></h2>

<p>只要存在问题，我们就可以想到借助工具来解决它，</p>

<p>那么假设这里有好多人需要斧子这种工具，</p>

<p>就要造出那么多斧子来吗，好累啊。</p>

<p><br/></p>

<p>其实，这引出了另外一个问题，</p>

<p>那就是如何制造多个斧子的问题。</p>

<p><br/></p>

<p>我们可以造一个机器，它用来生产斧子，</p>

<p>这个机器，就是<strong>用来制造工具的工具</strong>，</p>

<p>而制作这个机器所用的道具，同样也是工具。</p>

<p><br/></p>

<p>原来，世界这么奇妙，</p>

<p>工具可以组合，还可以互相影响。</p>

<p><br/></p>

<h2><strong>学会别人的设计思想</strong></h2>

<p>当我们定位问题后，怎样将适用工具制造出来呢？</p>

<p>现存的解决方案是怎样想出来的呢？</p>

<p><br/></p>

<p>这就得求助历史了，求助于同行们前辈们的经验教训。</p>

<p><br/></p>

<p>我们要先找到类似的工具，</p>

<p><strong>看它是如何解决问题的，用了什么办法，它的作者是怎么想的。</strong></p>

<p><br/></p>

<p>学会了这些，抓住思考问题的方式，</p>

<p>我们就能<strong>随机应变，灵活处理</strong>，做出趁手适用的工具来。</p>

<p><br/></p>

<p>其他工具中任何有用的部分，都可以借来，只要能达到目的。</p>

<p>即，目的明确后，方法可以灵活多变。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>过分的依赖工具和过度的排斥工具，都是盲目的。</p>

<p><strong>做到正视一个事物，是非常困难的。</strong></p>

<p><br/></p>

<p>jQuery的作者在《Secrets of the JavaScript Ninja》中所言，</p>

<p>很多人都被教导说，不要使用eval，这是不对的，</p>

<p>相反，<strong>我们应该学会它，从而才有能力善用它。</strong></p>

<p><br/></p>

<p>对于其他事物也是如此啊，</p>

<p>全盘接受和全盘否定，都会丢掉半壁江山，</p>

<p>我们要深入理解，目的是把它用到可以用的地方，发挥它的作用。</p>

<p><br/></p>

<p>不理解它，怎么做到在需要的时候使用呢？</p>

<p><br/></p>

<p>君子生非异也，善假于物也。</p>

<p>——荀子《劝学》</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件工程师的前瞻性]]></title>
    <link href="https://thzt.github.io/blog/2016/03/08/forward-looking-engineer/"/>
    <updated>2016-03-08T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/03/08/forward-looking-engineer</id>
    <content type="html"><![CDATA[<p>受过多年学校教育的我们，容易产生一个误区。</p>

<p>我们学会了很多知识，学会了怎样解决问题，</p>

<p>但是却不知道这些问题是怎么来的，</p>

<p>以后将要如何发展。</p>

<p><br/></p>

<p>我们要解决的问题都是静态的，</p>

<p>只要我们给出方案，</p>

<p>那它就永远是这个问题的解。</p>

<p><br/></p>

<p>然而，现实生活中的问题，却复杂得多。</p>

<p><br/></p>

<p>我们不仅需要考虑问题的解法，</p>

<p>而且更重要的还要考虑问题本身。</p>

<p>我们当前是否在把精力用于解决一个正确的问题，还说不定，</p>

<p>我们的方案是否在一段时间内仍然有效，也未可知。</p>

<p><br/></p>

<p>这也是软件行业的主要特点。</p>

<p><br/></p>

<h2><strong>困难的软件工程</strong></h2>

<p>人们常把软件工程比作建筑，我认为这极不合理。</p>

<p>完全忽视了软件的本质特点。</p>

<p><br/></p>

<p>与建筑行业不同的是，软件所解决的问题都是动态的，</p>

<p>楼还没有盖完，我们的图纸就变了，</p>

<p>怎样在这种情况下把楼盖起来，才是软件工程所面临的问题。</p>

<p><br/></p>

<p>诚然，用户的需求是不稳定的，今天说这个，明天说那个，</p>

<p>但这并不是一个主要方面。</p>

<p>短期内，需求的稳定性取决于我们的挖掘和控制。</p>

<p><br/></p>

<p>然而，从长远来看，市场在变，业务在变，</p>

<p>用户使用软件的目的就会改变，</p>

<p>软件岂能不变？</p>

<p><br/></p>

<p>采取什么样的方案，应对这些发展中的业务需要，</p>

<p>才是软件要解决的本质问题。</p>

<p><br/></p>

<p>这是困难的。</p>

<p><br/></p>

<p>且不谈增加新功能了，</p>

<p>甚至对于有缺陷的地方进行修改，也得慎重考虑。</p>

<p>所有依赖这个错误的特性而表现良好的程序，都是有问题的。</p>

<p><br/></p>

<p>每改一处都可能意味着全盘重写。</p>

<p><br/></p>

<h2><strong>编程层面的技术修炼</strong></h2>

<p>好的软件工程师，可以隔离变化，简化依赖关系。</p>

<p>他们通过抽象搭建框架，通过组装分离影响，</p>

<p>让每一个功能点都是可拆卸的。</p>

<p><br/></p>

<p>为了抽象，就得理解问题背后的数学结构，</p>

<p>为了封装，就得理解子问题之间的逻辑关联。</p>

<p><br/></p>

<p>好的代码，行云流水，层次分明，逻辑清晰，赏心悦目，</p>

<p>更重要的是，解决了当前问题，并留有余地。</p>

<p><br/></p>

<p>到了这一步，才可以谈论软件是如何进行设计的了，</p>

<p>的确，编程是一门设计手法，</p>

<p>更多的是考虑如何描述，如何组织，如何扩展等等问题。</p>

<p><br/></p>

<p>不但如此，一个架构师，还要考虑如何量产，</p>

<p>如何并行开发，如何降低抽象层次，</p>

<p>如何交流，如何推广。</p>

<p><br/></p>

<p>这绝对是一门手艺。</p>

<p><br/></p>

<h2><strong>工程师需要前瞻性</strong></h2>

<p>要想给出一个灵活可扩展的方案，</p>

<p>只是知道用动态的观点看待问题，作用是微小的。</p>

<p>我们还需要明白业务场景，分析它的趋势，看到它的未来。</p>

<p><br/></p>

<p>随着业务规模扩大，软件越来越复杂，</p>

<p>前瞻性将是衡量一个软件工程师的首要标准了，</p>

<p>这也是工程与编程的重要区别。</p>

<p><br/></p>

<p>可是，要想获得前瞻性是很难的，</p>

<p>我们必须先认识当前，明白现状，</p>

<p>必须跳出当前的生活，从更高的角度俯视它。</p>

<p><br/></p>

<p>我们得看到，现行方案已经帮助问题解决到了什么程度，</p>

<p>当前的痛点在哪，客观约束条件有哪些，</p>

<p>只有看清这些，才能确定目的地和实现路线。</p>

<p><br/></p>

<p>没有前瞻性的工程师是可怕的，</p>

<p>因为他自己都不知道要去哪，以及正在做什么，</p>

<p>那么他当前选择的路线就可能是盲目的，有风险的。</p>

<p><br/></p>

<p>只有确定目标，并逐步实现，</p>

<p>才有达到目标的可能。</p>

<p><br/></p>

<p>世界上，可没有那么多的巧合出现。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>知道自己在哪里，有计划要去哪里，</p>

<p>并努力付诸实践，才能达成目标。</p>

<p><br/></p>

<p>人们在计划出行时，总是这么考虑，</p>

<p>然而在其他问题上却容易迷茫</p>

<p><br/></p>

<p>其实，当不知道自己要去哪里的时候，</p>

<p>往往是对现在做的事情，不求甚解。</p>

<p><br/></p>

<p>还是从认识自己开始吧，</p>

<p>锻炼有前瞻性的思维习惯，</p>

<p>才能越走越稳，看尽沿途的风光美景。</p>
]]></content>
  </entry>
  
</feed>
