<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Design | 何幻]]></title>
  <link href="https://thzt.github.io/blog/categories/design/atom.xml" rel="self"/>
  <link href="https://thzt.github.io/"/>
  <updated>2016-03-18T15:47:54+08:00</updated>
  <id>https://thzt.github.io/</id>
  <author>
    <name><![CDATA[thzt]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[论工具]]></title>
    <link href="https://thzt.github.io/blog/2016/03/11/tools/"/>
    <updated>2016-03-11T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/03/11/tools</id>
    <content type="html"><![CDATA[<p>中学的历史课本上曾经讲过，</p>

<p>学会制作工具，是人类进步的标志。</p>

<p><br/></p>

<p>我深以为然。</p>

<p>可是现实生活中，<strong>存在着对工具很多的误解</strong>。</p>

<p><br/></p>

<p>有的人，认为制作工具浪费时间和精力，做了不必要的事情，</p>

<p>有的人，认为既然有现成的工具可用，为什么还要自己造轮子。</p>

<p>有的人，认为应该专门区分开制作工具的人和使用工具的人。</p>

<p><br/></p>

<p>这些看法，在各自的角度来讲，都说的通，</p>

<p>可以没有对工具有个<strong>全面的</strong>认识。</p>

<p><br/></p>

<p>下面，我们仔细分析一下，</p>

<p>看能不能从更高的角度来看待它，</p>

<p>做好工具，用好工具。</p>

<p><br/></p>

<h2><strong>工具就是解决方案</strong></h2>

<p>无论是日常生活中，还是在软件开发中，</p>

<p>我们经常有直接解决问题的场景，</p>

<p>貌似并没有使用工具。</p>

<p><br/></p>

<p>这就给了人们一种<strong>假象</strong>，</p>

<p>那种特意找来的才叫工具，</p>

<p>用了别人的东西，才叫用了工具。</p>

<p><br/></p>

<p>其实不然。</p>

<p>一个<strong>解决方案</strong>，实际上就是一个具体的工具了，</p>

<p>只不过它只能用来解决那个问题罢了。</p>

<p><br/></p>

<p>好的解决方案，就好比适用的工具，</p>

<p>用最直接的办法解决了问题，</p>

<p>不拖泥带水，不带来附加的问题。</p>

<p><br/></p>

<h2><strong>不得已而造轮子</strong></h2>

<p>着手实施的过程，</p>

<p>实际上就是将目前的项目问题<strong>还原</strong>成历史上已经解决过问题的过程。</p>

<p><br/></p>

<p>这个阶段，我们在进行问题求解。</p>

<p>为了尽可能的少耗费精力，我们总会优先选择已经成型的工具，</p>

<p>在软件开发中，相当于找到各种类库，框架来用。</p>

<p><br/></p>

<p>可是，市面上广为流传的那些通用工具，</p>

<p>并不一定非常切题，我们必须做出调整，甚至废弃一部分功能，</p>

<p>这个时候，就有点造轮子的萌芽了。</p>

<p><br/></p>

<p>随着业务的发展，业务模型逐渐清晰起来了，</p>

<p>没有趁手的工具，也无法跟得上业务的发展需要了，</p>

<p><strong>只能从基础开始，借用各种工具的设计思想，让工具和业务共同发展。</strong></p>

<p><br/></p>

<p>此之所谓，重新造轮子。</p>

<p><br/></p>

<p>这样不好吗？</p>

<p>在项目初期，诚然不太合适，</p>

<p>但是，全程中我们的目的都是为了找到合适的工具解决问题呀，</p>

<p>并没有偏离主题，并没有为了造而造。</p>

<p><br/></p>

<p>这也是<strong>不得已而为之</strong>的事情。</p>

<p><br/></p>

<h2><strong>工具的创造者和使用者</strong></h2>

<p>在大多数人眼中，</p>

<p>工具都是一些人造出来，给另外一些不同的人来使用的，</p>

<p>这里就又有误区了。</p>

<p><br/></p>

<p>其实不必强制如此，</p>

<p>一个能工巧匠，必然有<strong>自己的</strong>一套工具箱，</p>

<p>这些工具箱中都是他趁手的工具。</p>

<p><br/></p>

<p>这些工具，全是跟别人一样的吗？</p>

<p>未必啊。</p>

<p>有雷同的，有调整过的，更有自创的。</p>

<p><br/></p>

<p>工具完全可以自己造给自己用，是<strong>为了给自己的工作助力</strong>，</p>

<p>在软件行业，这有一个名词叫『dog fooding』，</p>

<p>很多软件公司都深谙此道。</p>

<p><br/></p>

<p>比如，Visual Studio本来只是Microsoft内部使用的一个编辑器，</p>

<p>随着不断完善，它完全可以作为一个产品来卖了，</p>

<p>那么就可以拿出来了，面向普通大众开放了。</p>

<p><br/></p>

<p>再比如，Facebook很多项目都主张尽量开源，</p>

<p>首先解决本公司自己的问题，</p>

<p>再通过解决社区的问题逐渐完善，同时也降低了维护成本。</p>

<p><br/></p>

<p>此外，如果不事先限定工具的未来使用者的话，</p>

<p>还会促进人们对工具进行更好的设计。</p>

<p><br/></p>

<p>另一方面，有些人喜欢写工具给别人用，</p>

<p>但是，<strong>眼高手低，只是解决一些假想的问题</strong>，过于理想主义。</p>

<p><br/></p>

<p>不能解决问题的工具，还不如没有，</p>

<p>它会造成解决方案的混乱，加大原始问题的难度。</p>

<p><br/></p>

<p>因此，工具的创造者和使用者，必须紧密合作。</p>

<p>工具才能发挥它最大的作用。</p>

<p><br/></p>

<h2><strong>业务逻辑并不啰嗦</strong></h2>

<p>有些人不喜欢写业务逻辑，说是因为它繁琐。</p>

<p>我觉得这是对编程认识的<strong>偏见</strong>。</p>

<p><br/></p>

<p>因为编程就是用代码解决问题的，</p>

<p>业务逻辑繁琐，本身就是一个问题。</p>

<p><br/></p>

<p>我们完全可以写一个业务逻辑的管理器，</p>

<p>把这些复杂业务逻辑分离开，然后用这个管理器统筹规划，</p>

<p>非常干净清爽了，不是吗？</p>

<p><br/></p>

<p>因此，这种情况下，代码要做的事情不是关键，</p>

<p><strong>关键在于，怎样写，用什么样的策略来写，</strong></p>

<p><strong>没有注定繁琐的代码，只有不合理的繁琐表述。</strong></p>

<p><br/></p>

<h2><strong>工具还可以用来制造工具</strong></h2>

<p>只要存在问题，我们就可以想到借助工具来解决它，</p>

<p>那么假设这里有好多人需要斧子这种工具，</p>

<p>就要造出那么多斧子来吗，好累啊。</p>

<p><br/></p>

<p>其实，这引出了另外一个问题，</p>

<p>那就是如何制造多个斧子的问题。</p>

<p><br/></p>

<p>我们可以造一个机器，它用来生产斧子，</p>

<p>这个机器，就是<strong>用来制造工具的工具</strong>，</p>

<p>而制作这个机器所用的道具，同样也是工具。</p>

<p><br/></p>

<p>原来，世界这么奇妙，</p>

<p>工具可以组合，还可以互相影响。</p>

<p><br/></p>

<h2><strong>学会别人的设计思想</strong></h2>

<p>当我们定位问题后，怎样将适用工具制造出来呢？</p>

<p>现存的解决方案是怎样想出来的呢？</p>

<p><br/></p>

<p>这就得求助历史了，求助于同行们前辈们的经验教训。</p>

<p><br/></p>

<p>我们要先找到类似的工具，</p>

<p><strong>看它是如何解决问题的，用了什么办法，它的作者是怎么想的。</strong></p>

<p><br/></p>

<p>学会了这些，抓住思考问题的方式，</p>

<p>我们就能<strong>随机应变，灵活处理</strong>，做出趁手适用的工具来。</p>

<p><br/></p>

<p>其他工具中任何有用的部分，都可以借来，只要能达到目的。</p>

<p>即，目的明确后，方法可以灵活多变。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>过分的依赖工具和过度的排斥工具，都是盲目的。</p>

<p><strong>做到正视一个事物，是非常困难的。</strong></p>

<p><br/></p>

<p>jQuery的作者在《Secrets of the JavaScript Ninja》中所言，</p>

<p>很多人都被教导说，不要使用eval，这是不对的，</p>

<p>相反，<strong>我们应该学会它，从而才有能力善用它。</strong></p>

<p><br/></p>

<p>对于其他事物也是如此啊，</p>

<p>全盘接受和全盘否定，都会丢掉半壁江山，</p>

<p>我们要深入理解，目的是把它用到可以用的地方，发挥它的作用。</p>

<p><br/></p>

<p>不理解它，怎么做到在需要的时候使用呢？</p>

<p><br/></p>

<p>君子生非异也，善假于物也。</p>

<p>——荀子《劝学》</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[软件工程师的前瞻性]]></title>
    <link href="https://thzt.github.io/blog/2016/03/08/forward-looking-engineer/"/>
    <updated>2016-03-08T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/03/08/forward-looking-engineer</id>
    <content type="html"><![CDATA[<p>受过多年学校教育的我们，容易产生一个误区。</p>

<p>我们学会了很多知识，学会了怎样解决问题，</p>

<p>但是却不知道这些问题是怎么来的，</p>

<p>以后将要如何发展。</p>

<p><br/></p>

<p>我们要解决的问题都是静态的，</p>

<p>只要我们给出方案，</p>

<p>那它就永远是这个问题的解。</p>

<p><br/></p>

<p>然而，现实生活中的问题，却复杂得多。</p>

<p><br/></p>

<p>我们不仅需要考虑问题的解法，</p>

<p>而且更重要的还要考虑问题本身。</p>

<p>我们当前是否在把精力用于解决一个正确的问题，还说不定，</p>

<p>我们的方案是否在一段时间内仍然有效，也未可知。</p>

<p><br/></p>

<p>这也是软件行业的主要特点。</p>

<p><br/></p>

<h2><strong>困难的软件工程</strong></h2>

<p>人们常把软件工程比作建筑，我认为这极不合理。</p>

<p>完全忽视了软件的本质特点。</p>

<p><br/></p>

<p>与建筑行业不同的是，软件所解决的问题都是动态的，</p>

<p>楼还没有盖完，我们的图纸就变了，</p>

<p>怎样在这种情况下把楼盖起来，才是软件工程所面临的问题。</p>

<p><br/></p>

<p>诚然，用户的需求是不稳定的，今天说这个，明天说那个，</p>

<p>但这并不是一个主要方面。</p>

<p>短期内，需求的稳定性取决于我们的挖掘和控制。</p>

<p><br/></p>

<p>然而，从长远来看，市场在变，业务在变，</p>

<p>用户使用软件的目的就会改变，</p>

<p>软件岂能不变？</p>

<p><br/></p>

<p>采取什么样的方案，应对这些发展中的业务需要，</p>

<p>才是软件要解决的本质问题。</p>

<p><br/></p>

<p>这是困难的。</p>

<p><br/></p>

<p>且不谈增加新功能了，</p>

<p>甚至对于有缺陷的地方进行修改，也得慎重考虑。</p>

<p>所有依赖这个错误的特性而表现良好的程序，都是有问题的。</p>

<p><br/></p>

<p>每改一处都可能意味着全盘重写。</p>

<p><br/></p>

<h2><strong>编程层面的技术修炼</strong></h2>

<p>好的软件工程师，可以隔离变化，简化依赖关系。</p>

<p>他们通过抽象搭建框架，通过组装分离影响，</p>

<p>让每一个功能点都是可拆卸的。</p>

<p><br/></p>

<p>为了抽象，就得理解问题背后的数学结构，</p>

<p>为了封装，就得理解子问题之间的逻辑关联。</p>

<p><br/></p>

<p>好的代码，行云流水，层次分明，逻辑清晰，赏心悦目，</p>

<p>更重要的是，解决了当前问题，并留有余地。</p>

<p><br/></p>

<p>到了这一步，才可以谈论软件是如何进行设计的了，</p>

<p>的确，编程是一门设计手法，</p>

<p>更多的是考虑如何描述，如何组织，如何扩展等等问题。</p>

<p><br/></p>

<p>不但如此，一个架构师，还要考虑如何量产，</p>

<p>如何并行开发，如何降低抽象层次，</p>

<p>如何交流，如何推广。</p>

<p><br/></p>

<p>这绝对是一门手艺。</p>

<p><br/></p>

<h2><strong>工程师需要前瞻性</strong></h2>

<p>要想给出一个灵活可扩展的方案，</p>

<p>只是知道用动态的观点看待问题，作用是微小的。</p>

<p>我们还需要明白业务场景，分析它的趋势，看到它的未来。</p>

<p><br/></p>

<p>随着业务规模扩大，软件越来越复杂，</p>

<p>前瞻性将是衡量一个软件工程师的首要标准了，</p>

<p>这也是工程与编程的重要区别。</p>

<p><br/></p>

<p>可是，要想获得前瞻性是很难的，</p>

<p>我们必须先认识当前，明白现状，</p>

<p>必须跳出当前的生活，从更高的角度俯视它。</p>

<p><br/></p>

<p>我们得看到，现行方案已经帮助问题解决到了什么程度，</p>

<p>当前的痛点在哪，客观约束条件有哪些，</p>

<p>只有看清这些，才能确定目的地和实现路线。</p>

<p><br/></p>

<p>没有前瞻性的工程师是可怕的，</p>

<p>因为他自己都不知道要去哪，以及正在做什么，</p>

<p>那么他当前选择的路线就可能是盲目的，有风险的。</p>

<p><br/></p>

<p>只有确定目标，并逐步实现，</p>

<p>才有达到目标的可能。</p>

<p><br/></p>

<p>世界上，可没有那么多的巧合出现。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>知道自己在哪里，有计划要去哪里，</p>

<p>并努力付诸实践，才能达成目标。</p>

<p><br/></p>

<p>人们在计划出行时，总是这么考虑，</p>

<p>然而在其他问题上却容易迷茫</p>

<p><br/></p>

<p>其实，当不知道自己要去哪里的时候，</p>

<p>往往是对现在做的事情，不求甚解。</p>

<p><br/></p>

<p>还是从认识自己开始吧，</p>

<p>锻炼有前瞻性的思维习惯，</p>

<p>才能越走越稳，看尽沿途的风光美景。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[消除重复与可复用相距多远]]></title>
    <link href="https://thzt.github.io/blog/2015/09/11/reuse-oriented-programming/"/>
    <updated>2015-09-11T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/09/11/reuse-oriented-programming</id>
    <content type="html"><![CDATA[<p>程序员们都讨厌重复，</p>

<p>因为他们知道，</p>

<p>这是可以避免的冗余工作量。</p>

<p>——代码坏味</p>

<p><br/></p>

<p>如果本来就不可避免，</p>

<p>那只好认了，</p>

<p>就好像需求不可能不变的事实一样。</p>

<p><br/></p>

<p>但是，<strong>盲目的消除重复</strong>，</p>

<p>并不是正确的姿势，</p>

<p>反而会把简单的事情搞复杂。</p>

<p><br/></p>

<p>为什么程序员们甘心写那么多“public class XXX {}”，</p>

<p>甘心写那么多“END”，“;”或者“)”，</p>

<p>而不设法避免呢？</p>

<p><br/></p>

<p>为什么不把所有的“this”都提取出来，</p>

<p>放在一个地方，</p>

<p>在编译前，再把他们塞入代码中呢。</p>

<p><br/></p>

<p>诚然，通过macro，</p>

<p>可以做一些代码生成之类的事情，</p>

<p>但是直觉告诉我们，不能乱来。</p>

<p><br/></p>

<p>原因是什么？</p>

<p>消除重复与面向复用其实还相距太远。</p>

<p><br/></p>

<h2>什么是面向复用的编程</h2>

<p>“面向”，指的是目的，目标。</p>

<p><br/></p>

<p>方法论告诉我们，</p>

<p>要完成一件事需要3个步骤，</p>

<p>（1）确定目标</p>

<p>（2）分析差距</p>

<p>（3）缩小差距</p>

<p><br/></p>

<p>确定目标是第一步。</p>

<p><br/></p>

<p>要想让我们的程序被复用，</p>

<p>首先他要设计成<strong>可以</strong>被复用的，</p>

<p>不是哪天要用了，忽然就行了。</p>

<p><br/></p>

<p>而且，在一套软件中，</p>

<p>并不是所有的代码都是可复用的，</p>

<p>有些根本无法复用。</p>

<p><br/></p>

<p>承认了这两个事实以后，</p>

<p>任务一下子简单了很多。</p>

<p><br/></p>

<h2><strong>提取并不意味着抽象</strong></h2>

<p>一段代码，在很多地方都出现了，</p>

<p>我们马上就能想到，</p>

<p>把它<strong>提取</strong>到了一个函数中。</p>

<p><br/></p>

<p>然而这对可复用并没有任何作用，</p>

<p>我们只是凑巧成功了几次。</p>

<p><br/></p>

<p>假如某个调用处的<strong>业务逻辑</strong>发生了变化，</p>

<p>我们就遇到麻烦了，</p>

<p>不能修改提取出去的代码，因为别人也在用，</p>

<p>还要把代码再复制回去，只调整这一块。</p>

<p><br/></p>

<p>自讨苦吃啊。</p>

<p>那可如何是好？</p>

<p><br/></p>

<p>这是因为，提取和抽象是不同的，</p>

<p>提取是文本层次的观察，</p>

<p>而抽象是逻辑层次的考察。</p>

<p><br/></p>

<p>这段代码虽然在很多地方出现了，</p>

<p>可是它却由不同的<strong>逻辑单元</strong>组成，</p>

<p>这就隐藏了很多引起它改变的因素。</p>

<p>——单一职责原则</p>

<p><br/></p>

<p>我们应该先把这些逻辑单元封装好，</p>

<p>然后<strong>拼装</strong>出统一的抽象接口，</p>

<p>各处对接口进行调用。</p>

<p>——依赖倒置原则</p>

<p>——合成/聚合复用原则</p>

<p><br/></p>

<p>一旦某个逻辑单元需要调整了，</p>

<p>那么只需要单独为某处调用，</p>

<p>再<strong>实现</strong>一个新的接口函数就行了。</p>

<p>——开-闭原则</p>

<p><br/></p>

<h2><strong>外表要简单，内心不要太简单</strong></h2>

<p>有人觉得有个<strong>拼装层</strong>太麻烦了，</p>

<p>还不如直接提取函数好呢，</p>

<p>这其实是混淆了抽象与实现。</p>

<p><br/></p>

<p>接口的使用者是看不到实现方式的，</p>

<p>实现很复杂是为了有更高的灵活性。</p>

<p>——迪米特法则</p>

<p><br/></p>

<p><strong>语言的魅力不就是，把复杂藏于只言片语之后吗？</strong></p>

<p>编程的目的不就是，为多变的业务逻辑提供简洁的描述语言吗？</p>

<p>——领域特定语言</p>

<p><br/></p>

<p>一切都应该尽可能地简单,但不要太简单。</p>

<p>——爱因斯坦</p>

<p><br/></p>

<h2><strong>业务与功能</strong></h2>

<p>经常变动的是业务逻辑，</p>

<p>而可复用的是功能模块。</p>

<p><br/></p>

<p>对逻辑我们要抽象，</p>

<p>而对功能我们要封装。</p>

<p><br/></p>

<p><strong>很多新手认为，</strong></p>

<p><strong>把相关的代码组织在一起就是封装了，</strong></p>

<p><strong>这与认为把代码提取出来了就是抽象了一样失败。</strong></p>

<p><br/></p>

<p>要封装，是因为它们“能够封装”，</p>

<p>而不是代码恰好出现在了一起。</p>

<p><br/></p>

<p>只有<strong>与要描述的业务无关</strong>的功能，</p>

<p>才是可复用的单元。</p>

<p><br/></p>

<p>每个页面都发送AJAX请求，</p>

<p>然后更新一个id=&ldquo;message"的标签，</p>

<p>这是不可封装的。</p>

<p><br/></p>

<p>而发送AJAX模块，</p>

<p>更新任一标签内容的模块，</p>

<p>才是可封装的。</p>

<p><br/></p>

<p>一致的业务流程，也是可以封装的。</p>

<p>例如，如果有定时任务，</p>

<p>可以封装一个定时任务管理器，</p>

<p>只需要挂载任务的配置信息就可以自动执行。</p>

<p><br/></p>

<p>对了，别人有写好了的，</p>

<p>不用自己做，</p>

<p>但我们要这么想。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>能闻到坏味是好事，</p>

<p>但是不正确的打扫方法，</p>

<p>反而会使代码更难维护。</p>

<p><br/></p>

<p>消除重复是表象，</p>

<p>而面向复用才是目的。</p>

<p><br/></p>

<p><strong>和别人读同样的书，</strong></p>

<p><strong>不一定考上一样的大学，</strong></p>

<p><strong>更不一定有相同的人生。</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[抽象的层次]]></title>
    <link href="https://thzt.github.io/blog/2015/08/11/hierarchy-of-abstraction/"/>
    <updated>2015-08-11T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/08/11/hierarchy-of-abstraction</id>
    <content type="html"><![CDATA[<p>从最终用户来看，</p>

<p>软件是一个整体，</p>

<p>所有的代码提供一个功能。</p>

<p><br/></p>

<p>从工程师的角度来看，</p>

<p>软件由多个互相联系的模块组成，</p>

<p>每个模块提供一部分功能。</p>

<p><br/></p>

<p><strong>然而，这些都是静态的观点，</strong></p>

<p>是在软件发布的那一瞬间观察到的。</p>

<p><br/></p>

<p>实际上呢？</p>

<p><br/></p>

<p><strong>实际上，软件是一个动态的事物，</strong></p>

<p>像一个生命体一样活着，</p>

<p>软件发布，只是它的一次快照。</p>

<p><br/></p>

<p>这就提醒了我们，</p>

<p>不能像设计建筑一样设计软件。</p>

<p><br/></p>

<p>更要考虑到它的成长。</p>

<p><br/></p>

<h2><strong>模块间的接口</strong></h2>

<p>我们永远不能假定，</p>

<p>软件提供的功能只被人来使用。</p>

<p><br/></p>

<p>其实，更多的是，</p>

<p>被其他软件系统来调用。</p>

<p><br/></p>

<p>这就要求我们，</p>

<p><strong>首先提供程序可调用的接口，</strong></p>

<p>而不是人机交互界面。</p>

<p><br/></p>

<p>这其实是测试驱动开发的直接结果，</p>

<p>我们首先要有自动化的用例，</p>

<p>才能保证功能的稳定。</p>

<p><br/></p>

<h2><strong>变化的接口</strong></h2>

<p>当我们确定了模块的调用接口后，</p>

<p>目的性就更加明确了。</p>

<p><br/></p>

<p>似乎，无论内部怎样设计，</p>

<p>只需要实现功能就行了。</p>

<p><br/></p>

<p>其实不然。</p>

<p><br/></p>

<p>根本原因就在于，</p>

<p><strong>模块的调用接口是变化的。</strong></p>

<p><br/></p>

<p>模块内的设计，</p>

<p>要有能力快速响应这种变化。</p>

<p><br/></p>

<h2><strong>不同的意见</strong></h2>

<p>有人认为，</p>

<p>接口设计的初衷，就是为了把变化隔离开，</p>

<p>接口发生变化了，设计本身就是不对的。</p>

<p><br/></p>

<p>诚然。</p>

<p><br/></p>

<p>但是，回想一下我们做过的项目，</p>

<p>有哪一个功能是稳定的？</p>

<p>又有哪一个设计能预判未来呢？</p>

<p><br/></p>

<p>因此，</p>

<p><strong>接口是隔离变化的手段之一，</strong></p>

<p>它只能<strong>尽量</strong>把变化压缩到模块内部。</p>

<p><br/></p>

<h2><strong>可扩展的设计</strong></h2>

<p>对于功能变更，不要埋怨，</p>

<p>否则，说起来好像我们一开始不知道似的。</p>

<p><br/></p>

<p>精巧的设计，</p>

<p>在设计之初就考虑到了这些，</p>

<p>留有扩展的余地。</p>

<p><br/></p>

<p>什么样的设计才是可扩展的呢？</p>

<p><br/></p>

<p>那就要求我们提取模式，</p>

<p><strong>只对抽象进行编程。</strong></p>

<p><br/></p>

<p>使得接口需要的功能，</p>

<p>作为抽象设计的特定情形。</p>

<p><br/></p>

<p>这样的话，</p>

<p>任何改变，都是抽象设计的不同应用。</p>

<p><br/></p>

<h2><strong>层次性</strong></h2>

<p>何必要这么麻烦呢？</p>

<p>直接提供功能不行吗？</p>

<p><br/></p>

<p>为什么还要先写一个抽象，</p>

<p>然后再具体化呢？</p>

<p><br/></p>

<p><strong>这是因为抽象隔离了变化。</strong></p>

<p>具体功能易变，而功能的模式更稳定。</p>

<p><br/></p>

<p>甚至，随着软件的日益复杂，</p>

<p>功能模式已经不再适用时。</p>

<p><br/></p>

<p>我们还要进一步抽象，</p>

<p>让现在的抽象层变成更高层的实例。</p>

<p><br/></p>

<h2><strong>友好的外观</strong></h2>

<p>优雅的设计，</p>

<p>内部的抽象层次是分明的，</p>

<p><strong>外观同样也是简易的。</strong></p>

<p><br/></p>

<p>这就像人一样，</p>

<p>越是有好的修养，</p>

<p>越是内心华丽，外表朴实。</p>

<p><br/></p>

<p>把精妙藏于简易的接口内部，</p>

<p>是一种艺术。</p>

<p><br/></p>

<p>这需要我们做很多努力，</p>

<p>不要把复杂开放给别人。</p>

<p><br/></p>

<p>不要炫耀。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>与其说，设计是一种创造性的活动，</p>

<p>不如说，设计是一种心智的锻炼活动。</p>

<p><br/></p>

<p>我们在努力学习软件的时候，</p>

<p>也不能忘记磨练自己的品行。</p>

<p><br/></p>

<p><strong>没有藏锋内敛的修养，</strong></p>

<p><strong>就难以完成大巧若拙的设计。</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[可替换的设计策略]]></title>
    <link href="https://thzt.github.io/blog/2015/03/31/choice/"/>
    <updated>2015-03-31T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/03/31/choice</id>
    <content type="html"><![CDATA[<p>人生就像一棵决策树，</p>

<p>每一次选择，走向了不同的子节点。</p>

<p>我们不能后退，也没办法消除历史的影响。</p>

<p><br/></p>

<p>因为时间是单向的，</p>

<p>没有办法更改历史，</p>

<p>只能以今天为基础继续向前。</p>

<p><br/></p>

<p>对于软件，我们也倾向于持有相同的观点。</p>

<p>认为软件的维护成本在后期是不可能缩减的，</p>

<p>不得不背负以前失误的包袱。</p>

<p><br/></p>

<p>然而，幸运的是，</p>

<p>软件其实并非如此。</p>

<p><br/></p>

<p>软件问题，大多数都是设计的问题。</p>

<p><br/></p>

<h2><strong>抽象和具体</strong></h2>

<p>和人生不同，</p>

<p>软件功能的实现，</p>

<p>限制条件相对宽松。</p>

<p><br/></p>

<p>毕业生，决定考研还是就业,</p>

<p>只能选一个。</p>

<p>但是，软件可以选择DoWork。</p>

<p><br/></p>

<p>越抽象，适用范围就越广。</p>

<p>越具体，就越容易被证明是个错误。</p>

<p><br/></p>

<p>好的设计实践，</p>

<p>是把抽象和具体分开，</p>

<p>抽象的每一种实现都是可替换的。</p>

<p><br/></p>

<p>随着软件的发展，</p>

<p>后期的维护成本才可能是常量复杂度的，</p>

<p>因为每一个历史性的错误实现，都是可更改的。</p>

<p><br/></p>

<h2><strong>平凡的模块</strong></h2>

<p>武功高强的人们，</p>

<p>不会频出诡异的绝招，</p>

<p>招数越平凡，内耗就越小。</p>

<p><br/></p>

<p>向外提供抽象接口的人，是在玩小伎俩，</p>

<p>不要将具体的实现方法托付给别人，</p>

<p>当问题出现时，让别人更改实现方案，是不可能的。</p>

<p><br/></p>

<p>我们应该提供具体的功能，</p>

<p>功能内部，封装了我们自己的抽象和实现。</p>

<p><br/></p>

<p>其中，抽象是对需求的提取，用来规范模块的外在表现，</p>

<p>实现是当前采用的解决方案。</p>

<p><br/></p>

<p>随着时间的发展，当模块不再适用时，</p>

<p>我们就能在外在表现不变的前提下，</p>

<p>更改解决方案了。</p>

<p><br/></p>

<p>不是只提供抽象接口，</p>

<p>而是把具体功能封装在抽象的接口下，</p>

<p>一起提供。</p>

<p><br/></p>

<h2><strong>层次与后路</strong></h2>

<p>代码量增加，软件会越来越复杂，</p>

<p>难以定位问题，增加功能，</p>

<p>这其实是没有建立合理的代码层次。</p>

<p><br/></p>

<p>在不同深度的层次上切换。</p>

<p>可以让我们总是面对简单可控的问题。</p>

<p><br/></p>

<p>一千行的函数太复杂了，</p>

<p>那是因为代码本来不该写在一个函数中。</p>

<p><br/></p>

<p>一万行代码太复杂了，</p>

<p>那是因为它本来不该写到一个文件中。</p>

<p><br/></p>

<p>一百个文件太复杂了，</p>

<p>那是因为它们本来不该在一个文件夹下。</p>

<p><br/></p>

<p>划分层次，才能留有后路。</p>

<p>每天关闭电脑前，检查自己的后路，是个好习惯。</p>

<p>可以让我们再打开电脑时，问题还是像今天这样简单。</p>

<p><br/></p>

<h2><strong>唯一性和可选性</strong></h2>

<p>当我们遇到紧急问题时，</p>

<p>通常首先会想到一个权宜之计。</p>

<p><br/></p>

<p>但是，从长久来看，</p>

<p>不得不做的事情总是会带来麻烦，</p>

<p>身不由己的决定，也是错误的根源。</p>

<p><br/></p>

<p>我们应该想尽办法，推迟决定。</p>

<p>直到我们有两个方案，可以从中选择。</p>

<p>可选性意味着可控的未来。</p>

<p><br/></p>

<p>软件的发展，像棋局一样，</p>

<p>必须仔细斟酌局势的变化，</p>

<p>才能避免因小失大。</p>

<p><br/></p>

<p>在客观条件限制的范围内，</p>

<p>有经验的人做出选择，</p>

<p>新手慌张决定，</p>

<p>在尽可能多的选择中，才能酝酿出好的设计。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>软件不同于人生之处在于，</p>

<p>软件可以设计，还可以更改，</p>

<p>只是成本有别。</p>

<p><br/></p>

<p>好的功能模块，在于内部的良好设计。</p>

<p>虽然外在表现没有什么不同。</p>

<p><br/></p>

<p>好的设计和代码组织方式，</p>

<p>威力连绵不绝。</p>

<p><br/></p>

<p>多一种选择，多一种可能。</p>
]]></content>
  </entry>
  
</feed>
