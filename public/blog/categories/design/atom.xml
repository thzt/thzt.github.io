<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Design | 何幻]]></title>
  <link href="https://thzt.github.io/blog/categories/design/atom.xml" rel="self"/>
  <link href="https://thzt.github.io/"/>
  <updated>2016-01-28T09:15:44+08:00</updated>
  <id>https://thzt.github.io/</id>
  <author>
    <name><![CDATA[thzt]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[消除重复与可复用相距多远]]></title>
    <link href="https://thzt.github.io/blog/2015/09/11/reuse-oriented-programming/"/>
    <updated>2015-09-11T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/09/11/reuse-oriented-programming</id>
    <content type="html"><![CDATA[<p>程序员们都讨厌重复，</p>

<p>因为他们知道，</p>

<p>这是可以避免的冗余工作量。</p>

<p>——代码坏味</p>

<p><br/></p>

<p>如果本来就不可避免，</p>

<p>那只好认了，</p>

<p>就好像需求不可能不变的事实一样。</p>

<p><br/></p>

<p>但是，<strong>盲目的消除重复</strong>，</p>

<p>并不是正确的姿势，</p>

<p>反而会把简单的事情搞复杂。</p>

<p><br/></p>

<p>为什么程序员们甘心写那么多“public class XXX {}”，</p>

<p>甘心写那么多“END”，“;”或者“)”，</p>

<p>而不设法避免呢？</p>

<p><br/></p>

<p>为什么不把所有的“this”都提取出来，</p>

<p>放在一个地方，</p>

<p>在编译前，再把他们塞入代码中呢。</p>

<p><br/></p>

<p>诚然，通过macro，</p>

<p>可以做一些代码生成之类的事情，</p>

<p>但是直觉告诉我们，不能乱来。</p>

<p><br/></p>

<p>原因是什么？</p>

<p>消除重复与面向复用其实还相距太远。</p>

<p><br/></p>

<h2>什么是面向复用的编程</h2>

<p>“面向”，指的是目的，目标。</p>

<p><br/></p>

<p>方法论告诉我们，</p>

<p>要完成一件事需要3个步骤，</p>

<p>（1）确定目标</p>

<p>（2）分析差距</p>

<p>（3）缩小差距</p>

<p><br/></p>

<p>确定目标是第一步。</p>

<p><br/></p>

<p>要想让我们的程序被复用，</p>

<p>首先他要设计成<strong>可以</strong>被复用的，</p>

<p>不是哪天要用了，忽然就行了。</p>

<p><br/></p>

<p>而且，在一套软件中，</p>

<p>并不是所有的代码都是可复用的，</p>

<p>有些根本无法复用。</p>

<p><br/></p>

<p>承认了这两个事实以后，</p>

<p>任务一下子简单了很多。</p>

<p><br/></p>

<h2><strong>提取并不意味着抽象</strong></h2>

<p>一段代码，在很多地方都出现了，</p>

<p>我们马上就能想到，</p>

<p>把它<strong>提取</strong>到了一个函数中。</p>

<p><br/></p>

<p>然而这对可复用并没有任何作用，</p>

<p>我们只是凑巧成功了几次。</p>

<p><br/></p>

<p>假如某个调用处的<strong>业务逻辑</strong>发生了变化，</p>

<p>我们就遇到麻烦了，</p>

<p>不能修改提取出去的代码，因为别人也在用，</p>

<p>还要把代码再复制回去，只调整这一块。</p>

<p><br/></p>

<p>自讨苦吃啊。</p>

<p>那可如何是好？</p>

<p><br/></p>

<p>这是因为，提取和抽象是不同的，</p>

<p>提取是文本层次的观察，</p>

<p>而抽象是逻辑层次的考察。</p>

<p><br/></p>

<p>这段代码虽然在很多地方出现了，</p>

<p>可是它却由不同的<strong>逻辑单元</strong>组成，</p>

<p>这就隐藏了很多引起它改变的因素。</p>

<p>——单一职责原则</p>

<p><br/></p>

<p>我们应该先把这些逻辑单元封装好，</p>

<p>然后<strong>拼装</strong>出统一的抽象接口，</p>

<p>各处对接口进行调用。</p>

<p>——依赖倒置原则</p>

<p>——合成/聚合复用原则</p>

<p><br/></p>

<p>一旦某个逻辑单元需要调整了，</p>

<p>那么只需要单独为某处调用，</p>

<p>再<strong>实现</strong>一个新的接口函数就行了。</p>

<p>——开-闭原则</p>

<p><br/></p>

<h2><strong>外表要简单，内心不要太简单</strong></h2>

<p>有人觉得有个<strong>拼装层</strong>太麻烦了，</p>

<p>还不如直接提取函数好呢，</p>

<p>这其实是混淆了抽象与实现。</p>

<p><br/></p>

<p>接口的使用者是看不到实现方式的，</p>

<p>实现很复杂是为了有更高的灵活性。</p>

<p>——迪米特法则</p>

<p><br/></p>

<p><strong>语言的魅力不就是，把复杂藏于只言片语之后吗？</strong></p>

<p>编程的目的不就是，为多变的业务逻辑提供简洁的描述语言吗？</p>

<p>——领域特定语言</p>

<p><br/></p>

<p>一切都应该尽可能地简单,但不要太简单。</p>

<p>——爱因斯坦</p>

<p><br/></p>

<h2><strong>业务与功能</strong></h2>

<p>经常变动的是业务逻辑，</p>

<p>而可复用的是功能模块。</p>

<p><br/></p>

<p>对逻辑我们要抽象，</p>

<p>而对功能我们要封装。</p>

<p><br/></p>

<p><strong>很多新手认为，</strong></p>

<p><strong>把相关的代码组织在一起就是封装了，</strong></p>

<p><strong>这与认为把代码提取出来了就是抽象了一样失败。</strong></p>

<p><br/></p>

<p>要封装，是因为它们“能够封装”，</p>

<p>而不是代码恰好出现在了一起。</p>

<p><br/></p>

<p>只有<strong>与要描述的业务无关</strong>的功能，</p>

<p>才是可复用的单元。</p>

<p><br/></p>

<p>每个页面都发送AJAX请求，</p>

<p>然后更新一个id=&ldquo;message"的标签，</p>

<p>这是不可封装的。</p>

<p><br/></p>

<p>而发送AJAX模块，</p>

<p>更新任一标签内容的模块，</p>

<p>才是可封装的。</p>

<p><br/></p>

<p>一致的业务流程，也是可以封装的。</p>

<p>例如，如果有定时任务，</p>

<p>可以封装一个定时任务管理器，</p>

<p>只需要挂载任务的配置信息就可以自动执行。</p>

<p><br/></p>

<p>对了，别人有写好了的，</p>

<p>不用自己做，</p>

<p>但我们要这么想。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>能闻到坏味是好事，</p>

<p>但是不正确的打扫方法，</p>

<p>反而会使代码更难维护。</p>

<p><br/></p>

<p>消除重复是表象，</p>

<p>而面向复用才是目的。</p>

<p><br/></p>

<p><strong>和别人读同样的书，</strong></p>

<p><strong>不一定考上一样的大学，</strong></p>

<p><strong>更不一定有相同的人生。</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[抽象的层次]]></title>
    <link href="https://thzt.github.io/blog/2015/08/11/hierarchy-of-abstraction/"/>
    <updated>2015-08-11T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/08/11/hierarchy-of-abstraction</id>
    <content type="html"><![CDATA[<p>从最终用户来看，</p>

<p>软件是一个整体，</p>

<p>所有的代码提供一个功能。</p>

<p><br/></p>

<p>从工程师的角度来看，</p>

<p>软件由多个互相联系的模块组成，</p>

<p>每个模块提供一部分功能。</p>

<p><br/></p>

<p><strong>然而，这些都是静态的观点，</strong></p>

<p>是在软件发布的那一瞬间观察到的。</p>

<p><br/></p>

<p>实际上呢？</p>

<p><br/></p>

<p><strong>实际上，软件是一个动态的事物，</strong></p>

<p>像一个生命体一样活着，</p>

<p>软件发布，只是它的一次快照。</p>

<p><br/></p>

<p>这就提醒了我们，</p>

<p>不能像设计建筑一样设计软件。</p>

<p><br/></p>

<p>更要考虑到它的成长。</p>

<p><br/></p>

<h2><strong>模块间的接口</strong></h2>

<p>我们永远不能假定，</p>

<p>软件提供的功能只被人来使用。</p>

<p><br/></p>

<p>其实，更多的是，</p>

<p>被其他软件系统来调用。</p>

<p><br/></p>

<p>这就要求我们，</p>

<p><strong>首先提供程序可调用的接口，</strong></p>

<p>而不是人机交互界面。</p>

<p><br/></p>

<p>这其实是测试驱动开发的直接结果，</p>

<p>我们首先要有自动化的用例，</p>

<p>才能保证功能的稳定。</p>

<p><br/></p>

<h2><strong>变化的接口</strong></h2>

<p>当我们确定了模块的调用接口后，</p>

<p>目的性就更加明确了。</p>

<p><br/></p>

<p>似乎，无论内部怎样设计，</p>

<p>只需要实现功能就行了。</p>

<p><br/></p>

<p>其实不然。</p>

<p><br/></p>

<p>根本原因就在于，</p>

<p><strong>模块的调用接口是变化的。</strong></p>

<p><br/></p>

<p>模块内的设计，</p>

<p>要有能力快速响应这种变化。</p>

<p><br/></p>

<h2><strong>不同的意见</strong></h2>

<p>有人认为，</p>

<p>接口设计的初衷，就是为了把变化隔离开，</p>

<p>接口发生变化了，设计本身就是不对的。</p>

<p><br/></p>

<p>诚然。</p>

<p><br/></p>

<p>但是，回想一下我们做过的项目，</p>

<p>有哪一个功能是稳定的？</p>

<p>又有哪一个设计能预判未来呢？</p>

<p><br/></p>

<p>因此，</p>

<p><strong>接口是隔离变化的手段之一，</strong></p>

<p>它只能<strong>尽量</strong>把变化压缩到模块内部。</p>

<p><br/></p>

<h2><strong>可扩展的设计</strong></h2>

<p>对于功能变更，不要埋怨，</p>

<p>否则，说起来好像我们一开始不知道似的。</p>

<p><br/></p>

<p>精巧的设计，</p>

<p>在设计之初就考虑到了这些，</p>

<p>留有扩展的余地。</p>

<p><br/></p>

<p>什么样的设计才是可扩展的呢？</p>

<p><br/></p>

<p>那就要求我们提取模式，</p>

<p><strong>只对抽象进行编程。</strong></p>

<p><br/></p>

<p>使得接口需要的功能，</p>

<p>作为抽象设计的特定情形。</p>

<p><br/></p>

<p>这样的话，</p>

<p>任何改变，都是抽象设计的不同应用。</p>

<p><br/></p>

<h2><strong>层次性</strong></h2>

<p>何必要这么麻烦呢？</p>

<p>直接提供功能不行吗？</p>

<p><br/></p>

<p>为什么还要先写一个抽象，</p>

<p>然后再具体化呢？</p>

<p><br/></p>

<p><strong>这是因为抽象隔离了变化。</strong></p>

<p>具体功能易变，而功能的模式更稳定。</p>

<p><br/></p>

<p>甚至，随着软件的日益复杂，</p>

<p>功能模式已经不再适用时。</p>

<p><br/></p>

<p>我们还要进一步抽象，</p>

<p>让现在的抽象层变成更高层的实例。</p>

<p><br/></p>

<h2><strong>友好的外观</strong></h2>

<p>优雅的设计，</p>

<p>内部的抽象层次是分明的，</p>

<p><strong>外观同样也是简易的。</strong></p>

<p><br/></p>

<p>这就像人一样，</p>

<p>越是有好的修养，</p>

<p>越是内心华丽，外表朴实。</p>

<p><br/></p>

<p>把精妙藏于简易的接口内部，</p>

<p>是一种艺术。</p>

<p><br/></p>

<p>这需要我们做很多努力，</p>

<p>不要把复杂开放给别人。</p>

<p><br/></p>

<p>不要炫耀。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>与其说，设计是一种创造性的活动，</p>

<p>不如说，设计是一种心智的锻炼活动。</p>

<p><br/></p>

<p>我们在努力学习软件的时候，</p>

<p>也不能忘记磨练自己的品行。</p>

<p><br/></p>

<p><strong>没有藏锋内敛的修养，</strong></p>

<p><strong>就难以完成大巧若拙的设计。</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[可替换的设计策略]]></title>
    <link href="https://thzt.github.io/blog/2015/03/31/choice/"/>
    <updated>2015-03-31T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/03/31/choice</id>
    <content type="html"><![CDATA[<p>人生就像一棵决策树，</p>

<p>每一次选择，走向了不同的子节点。</p>

<p>我们不能后退，也没办法消除历史的影响。</p>

<p><br/></p>

<p>因为时间是单向的，</p>

<p>没有办法更改历史，</p>

<p>只能以今天为基础继续向前。</p>

<p><br/></p>

<p>对于软件，我们也倾向于持有相同的观点。</p>

<p>认为软件的维护成本在后期是不可能缩减的，</p>

<p>不得不背负以前失误的包袱。</p>

<p><br/></p>

<p>然而，幸运的是，</p>

<p>软件其实并非如此。</p>

<p><br/></p>

<p>软件问题，大多数都是设计的问题。</p>

<p><br/></p>

<h2><strong>抽象和具体</strong></h2>

<p>和人生不同，</p>

<p>软件功能的实现，</p>

<p>限制条件相对宽松。</p>

<p><br/></p>

<p>毕业生，决定考研还是就业,</p>

<p>只能选一个。</p>

<p>但是，软件可以选择DoWork。</p>

<p><br/></p>

<p>越抽象，适用范围就越广。</p>

<p>越具体，就越容易被证明是个错误。</p>

<p><br/></p>

<p>好的设计实践，</p>

<p>是把抽象和具体分开，</p>

<p>抽象的每一种实现都是可替换的。</p>

<p><br/></p>

<p>随着软件的发展，</p>

<p>后期的维护成本才可能是常量复杂度的，</p>

<p>因为每一个历史性的错误实现，都是可更改的。</p>

<p><br/></p>

<h2><strong>平凡的模块</strong></h2>

<p>武功高强的人们，</p>

<p>不会频出诡异的绝招，</p>

<p>招数越平凡，内耗就越小。</p>

<p><br/></p>

<p>向外提供抽象接口的人，是在玩小伎俩，</p>

<p>不要将具体的实现方法托付给别人，</p>

<p>当问题出现时，让别人更改实现方案，是不可能的。</p>

<p><br/></p>

<p>我们应该提供具体的功能，</p>

<p>功能内部，封装了我们自己的抽象和实现。</p>

<p><br/></p>

<p>其中，抽象是对需求的提取，用来规范模块的外在表现，</p>

<p>实现是当前采用的解决方案。</p>

<p><br/></p>

<p>随着时间的发展，当模块不再适用时，</p>

<p>我们就能在外在表现不变的前提下，</p>

<p>更改解决方案了。</p>

<p><br/></p>

<p>不是只提供抽象接口，</p>

<p>而是把具体功能封装在抽象的接口下，</p>

<p>一起提供。</p>

<p><br/></p>

<h2><strong>层次与后路</strong></h2>

<p>代码量增加，软件会越来越复杂，</p>

<p>难以定位问题，增加功能，</p>

<p>这其实是没有建立合理的代码层次。</p>

<p><br/></p>

<p>在不同深度的层次上切换。</p>

<p>可以让我们总是面对简单可控的问题。</p>

<p><br/></p>

<p>一千行的函数太复杂了，</p>

<p>那是因为代码本来不该写在一个函数中。</p>

<p><br/></p>

<p>一万行代码太复杂了，</p>

<p>那是因为它本来不该写到一个文件中。</p>

<p><br/></p>

<p>一百个文件太复杂了，</p>

<p>那是因为它们本来不该在一个文件夹下。</p>

<p><br/></p>

<p>划分层次，才能留有后路。</p>

<p>每天关闭电脑前，检查自己的后路，是个好习惯。</p>

<p>可以让我们再打开电脑时，问题还是像今天这样简单。</p>

<p><br/></p>

<h2><strong>唯一性和可选性</strong></h2>

<p>当我们遇到紧急问题时，</p>

<p>通常首先会想到一个权宜之计。</p>

<p><br/></p>

<p>但是，从长久来看，</p>

<p>不得不做的事情总是会带来麻烦，</p>

<p>身不由己的决定，也是错误的根源。</p>

<p><br/></p>

<p>我们应该想尽办法，推迟决定。</p>

<p>直到我们有两个方案，可以从中选择。</p>

<p>可选性意味着可控的未来。</p>

<p><br/></p>

<p>软件的发展，像棋局一样，</p>

<p>必须仔细斟酌局势的变化，</p>

<p>才能避免因小失大。</p>

<p><br/></p>

<p>在客观条件限制的范围内，</p>

<p>有经验的人做出选择，</p>

<p>新手慌张决定，</p>

<p>在尽可能多的选择中，才能酝酿出好的设计。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>软件不同于人生之处在于，</p>

<p>软件可以设计，还可以更改，</p>

<p>只是成本有别。</p>

<p><br/></p>

<p>好的功能模块，在于内部的良好设计。</p>

<p>虽然外在表现没有什么不同。</p>

<p><br/></p>

<p>好的设计和代码组织方式，</p>

<p>威力连绵不绝。</p>

<p><br/></p>

<p>多一种选择，多一种可能。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[jQuery插件的把玩方式]]></title>
    <link href="https://thzt.github.io/blog/2015/03/24/jquery-plugin/"/>
    <updated>2015-03-24T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/03/24/jquery-plugin</id>
    <content type="html"><![CDATA[<p>类库，框架，层出不穷。</p>

<p>Web前端，似乎经历着历史上已经发生过很多次的事情。</p>

<p><br/></p>

<p>很多人找不到自己的努力方向了，</p>

<p>Backbone，Ember，AngularJS，ReactJS，&hellip;</p>

<p>到底该学哪个？</p>

<p><br/></p>

<p>一阵阵枪林弹雨，扫的我们抬不起头来，</p>

<p>各大公司为了抢占资源，霸占程序员的时间，</p>

<p>总是宣传它们的东西是最好的。</p>

<p><br/></p>

<p>其实，我们不必太较真，</p>

<p>我们只需要抓住已有知识的精髓即可，</p>

<p>举一反三，用创造力改变世界。</p>

<p><br/></p>

<p>编程，就好像古时候写诗一样。</p>

<p>伟大的诗人，不一定会背所有的诗词。</p>

<p>他们的伟大之处在于借鉴。</p>

<p><br/></p>

<p>学习别人好的思想，拿来灵活运用，恰如其分的表达，</p>

<p>就足够了，</p>

<p>至于是否伟大，让后人去说吧。</p>

<p><br/></p>

<p>比如说，jQuery过时了吗，</p>

<p>前端各种MVC框架，MVVM框架，说的比什么都好听。</p>

<p>好像不用框架就没办法生存似的。</p>

<p><br/></p>

<p>作为一个学过辩证法的人，</p>

<p>我们马上就意识到了，这可能是有人在故意炒作它。</p>

<p>另一方面，我们也知道这些框架确实也有可取之处。</p>

<p><br/></p>

<p>要做到不骄不躁，</p>

<p>只有强大自身，这一个办法了。</p>

<p><br/></p>

<p>慢慢的，我们就发现了，</p>

<p>框架也只不过是别人活学活用的成果罢了。</p>

<p><br/></p>

<h2><strong>扩展性</strong></h2>

<p>我们来学习一下jQuery的设计思想。</p>

<p><br/></p>

<p>JavaScript经常做的，</p>

<p>大概就是选取页面的元素，然后做一些事情了。</p>

<p><br/></p>

<p>而怎样选取元素呢，CSS已经给我们提供办法了，</p>

<p>那就是CSS选择器selector，</p>

<p>这样选中的其实是满足条件的HTML元素集合。</p>

<p><br/></p>

<p>如果能在集合上定义自己的操作就好了，</p>

<p>我们就可以把选中的集合整体看做一个对象，</p>

<p>调用这个对象的方法。</p>

<p><br/></p>

<p>这其实就是面向对象的思想呀。</p>

<p><br/></p>

<p>有了这个想法之后，我们先设计测试用例。</p>

<p>也就是说，我们要考虑，假如我们已经有了某个类库，</p>

<p>我们将如何使用它呢？</p>

<p><br/></p>

<p>这其实是编程活动中，最具创造力的环节。</p>

<p>也是自顶向下编程，或者测试驱动开发思想的一种应用。</p>

<p><br/></p>

<p>jQuery作者是这样设计的，</p>

<p>类库的使用者接口如下，</p>

<p>$(selector).method(parameter);</p>

<p><br/></p>

<p>类库的开发者接口如下，</p>

<p>扩展静态方法，</p>

<p>$.extend({</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;staticMethod:function(){}</p>

<p>});</p>

<p><br/></p>

<p>扩展实例方法，</p>

<p>$.prototype.extend({</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;instanceMethod:function(){}</p>

<p>});</p>

<p><br/></p>

<p>这种思路，很值得借鉴，</p>

<p>它说明，最灵活的设计，是那些只包含扩展方法的设计。</p>

<p>类库中所有的功能，都是用统一的方式扩展出来的。</p>

<p><br/></p>

<p>类库自带的功能越多，</p>

<p>以后修改这些功能的可能性就越大。</p>

<p><br/></p>

<h2><strong>实现</strong></h2>

<p>至于如何实现，网上可以找到很多教程，</p>

<p>下面只写了一下我自己的实现。</p>

<p><br/></p>

<p>(function(global,document){</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;jQuery.prototype=InstanceCreation.prototype;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;jQuery.extend=jQuery.prototype.extend=extend;</p>

<p><br/></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;function jQuery(selector){</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new InstanceCreation(selector);</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>

<p><br/></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;function InstanceCreation(selector){</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var instance=this;</p>

<p><br/></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instance[0]=document.querySelector(selector);</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>

<p><br/></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;function extend(material){</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var depository=this;</p>

<p><br/></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(var property in material){</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(!material.hasOwnProperty(property)){</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>

<p><br/></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;depository[property]=material[property];</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>

<p><br/></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;};</p>

<p><br/></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;//export:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;global.$=jQuery;</p>

<p>}(window,document));</p>

<p><br/></p>

<p>对实现不详细描述，还有其他原因，</p>

<p>因为，实现是灵活的，而用户接口是用来表达思想的。</p>

<p>任何一种实现都能达到目的，</p>

<p>但并非所有人都能设计出具有表现力的用户接口。</p>

<p><br/></p>

<p>贴到这里，而不是放置Github超链接，</p>

<p>是为了有个直观的印象，jQuery核心其实很小。</p>

<p>所有其他功能都是扩展出来的。</p>

<p><br/></p>

<h2><strong>插件</strong></h2>

<p>类似jQuery这样，</p>

<p>提供基础核心，再提供对核心的扩展方式，</p>

<p>称为插件式开发。</p>

<p><br/></p>

<p>我们只需要使用</p>

<p>$.prototype.extend({</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;pluginName:function(){}</p>

<p>});</p>

<p><br/></p>

<p>$(selector)就有了一个pluginName方法了。$(selector).pluginName</p>

<p><br/></p>

<p>正因为有这么便捷的功能，</p>

<p>jQuery插件的数量才惊人的多。</p>

<p><br/></p>

<p>我们还可以把页面切分为几个部分，</p>

<p>每个部分是一个插件对象，只对这一块元素进行操作，</p>

<p>这符合面向对象的思想。</p>

<p><br/></p>

<p>$(container1).pluginName1(&hellip;);</p>

<p>$(container1).pluginName2(&hellip;);</p>

<p><br/></p>

<p>我们把问题简化了，</p>

<p>对整个页面的控制，转换成对这些自定义插件的控制了。</p>

<p><br/></p>

<h2><strong>缺点和改进</strong></h2>

<p>经过一段时间使用后，</p>

<p>我们发现jQuery插件有一个缺点，</p>

<p>$(container).pluginName(&hellip;);</p>

<p><br/></p>

<p>一个插件的所有操作，都必须放到同一个pluginName方法中。</p>

<p>如果我们想初始化和取值，就不得不这样操作，</p>

<p>$(container).pluginName(&lsquo;init&rsquo;,data);</p>

<p>$(container).pluginName(&lsquo;getValue&rsquo;);</p>

<p><br/></p>

<p>后果就是pluginName这个函数中，我们就要写很多switch语句。</p>

<p>$.prototype.extend({</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;pluginName:function(operationName,arg0){</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;switch(operationName){</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case &lsquo;init&rsquo;:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&hellip;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case &lsquo;getValue&rsquo;:</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&hellip;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&hellip;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>

<p>});</p>

<p><br/></p>

<p>还算清晰，</p>

<p>不过最致命的就是，如果我们想添加一个对插件的操作，</p>

<p>我们必须去改同一个文件，在switch中添加case子句。</p>

<p>这太烦人了。</p>

<p><br/></p>

<p>而且，取data的值也比较麻烦。</p>

<p>按理说它是init操作的第1个参数，</p>

<p>但是它实际上是作为pluginName的第2个参数传递的。</p>

<p><br/></p>

<p>我们为什么不能设计一个工具，来改变现状呢？</p>

<p>让我们踏上程序设计之路吧。</p>

<p>假如我们已经设计好了，想这样用。pluginManager.extend</p>

<p><br/></p>

<p>(function($){</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;$.pluginManager.extend(&lsquo;pluginName&rsquo;,{</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init:initPlugin</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;});</p>

<p><br/></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;function initPlugin(){</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var $selector=this;</p>

<p><br/></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//arguments[0]===data</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&hellip;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>

<p>}(jQuery));</p>

<p><br/></p>

<p>(function($){</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;$.pluginManager.extend(&lsquo;pluginName&rsquo;,{</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getValue:getValueFromPlugin</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;});</p>

<p><br/></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;function getValueFromPlugin(){</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var $selector=this;</p>

<p><br/></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&hellip;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>

<p>}(jQuery));</p>

<p><br/></p>

<p>我们避免了为插件添加操作的麻烦，</p>

<p>还把data参数的位置调节好了。</p>

<p>并且将插件操作的具体实现，分离到了不同的文件中。</p>

<p><br/></p>

<p>这能实现吗？</p>

<p>可以的，我已经做好了。</p>

<p>但是，实现并不重要，关键是思想。</p>

<p><br/></p>

<h2><strong>持续改进</strong></h2>

<p>并不是技术本身想要更新，</p>

<p>是创新的业务需要，促进了创新的技术出现，</p>

<p>不适应性越强烈，改进工具的可能性就越大。</p>

<p><br/></p>

<p>随着时间的发展，</p>

<p>我们发现了另一个问题。</p>

<p><br/></p>

<p>插件在使用过程中，可能会设置一些缺省值，</p>

<p>例如：初始化，</p>

<p>$(container).pluginName(&lsquo;init&rsquo;,data);</p>

<p>$(container).pluginName(&lsquo;init&rsquo;);</p>

<p>都是有可能的。</p>

<p><br/></p>

<p>每个插件中都单独处理缺省值，是很啰嗦的事情。</p>

<p>function initPlugin(){</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;var $selector=this,</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data=arguments[0]||&lsquo;Hello&rsquo;;</p>

<p><br/></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;//&hellip;
}</p>

<p><br/></p>

<p>啰嗦也就罢了，</p>

<p>最不能容忍的是，代码中出现了硬编码。</p>

<p>&lsquo;Hello'是业务数据，跟插件本身无关。</p>

<p><br/></p>

<p>还记得吗，</p>

<p>类库自带的功能越多，</p>

<p>以后修改这些功能的可能性就越大。</p>

<p><br/></p>

<p>所以，我们得想一个办法把他们分离出去。pluginManager.filter</p>

<p>(function($){</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;$.pluginManager.extend(&lsquo;pluginName&rsquo;,{</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init:initPlugin</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;});</p>

<p><br/></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;function initPlugin(){</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var $selector=this,</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;data=arguments[0];</p>

<p><br/></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&hellip;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>

<p>}(jQuery));</p>

<p><br/></p>

<p>(function($){</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;$.pluginManager.<strong>filter</strong>(&lsquo;pluginName&rsquo;,{</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;init:filterInit</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;});</p>

<p><br/></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;function filterInit(){</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var $selector=this;</p>

<p><br/></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return [</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;arguments[0]||&lsquo;Hello&rsquo;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;];</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>

<p>}(jQuery));</p>

<p><br/></p>

<p>因此，我们增加了一层，</p>

<p>作为插件核心的开发者，接受所有需要配置的参数。</p>

<p><br/></p>

<p>作为实际插件的使用者，为了避免多次配置，</p>

<p>可以一次性为插件设置默认值。</p>

<p>filter将pluginName插件的init操作实际调用的实参，</p>

<p>转换一下，传递给了核心。</p>

<p><br/></p>

<p>这样的话，插件核心的开发者，就可以提供更松散的功能，</p>

<p>不用假设实际的使用情况，</p>

<p>实际和具体业务相关的处理，放到了filter里面。</p>

<p><br/></p>

<p>另外，我们看到filter是很灵活的，</p>

<p>它可以将任何实参，以任何方式转换成核心需要的实参，</p>

<p>哪怕核心需要的实参是一个函数。</p>

<p><br/></p>

<p>这能实现吗？</p>

<p>也是可以的，我也已经做好了。</p>

<p>但是，实现并不重要，关键是思想。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>我们分析了jQuery的设计思想，</p>

<p>并拿来随机应变，设计了自己的插件管理器。</p>

<p><br/></p>

<p>使用框架了吗？</p>

<p>并没有。</p>

<p>连jQuery核心也是自己写的。</p>

<p><br/></p>

<p>但是，在思考过程中，无处不闪烁着许多优秀框架的思想。</p>

<p><br/></p>

<p>因此，我们也应该知道了，</p>

<p>插件管理器本身，并没有什么，</p>

<p>关键是思考过程，以及我们想到什么样的办法解决实际问题。</p>

<p><br/></p>

<p>我们的所能掌握的知识，总是不够的。</p>

<p>但这不影响我们去创造好用的工具。</p>

<p><br/></p>

<p>比如，为了借鉴MVVM的思想，不必使用knockout.js，</p>

<p>我们可以自己写一个bindTemplate来进行模板的读写操作。</p>

<p><br/></p>

<p>设置值</p>

<p>$(container).bindTemplate(&lsquo;setData&rsquo;,{</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;attr:&lsquo;data-model&rsquo;,</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;data:json,</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;set:setFieldValue</p>

<p>});</p>

<p><br/></p>

<p>读取值</p>

<p>$(container).bindTemplate(&lsquo;getData&rsquo;,{</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;attr:&lsquo;data-model&rsquo;,</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;get:getFieldValue</p>

<p>});</p>

<p><br/></p>

<p>我们可以把json对象，绑定到HTML对象上，再从HTML中取回同样结构的json对象。</p>

<p>而与HTML元素的排列方式无关。</p>

<p>json=[</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;0,</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;{</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;val:1</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>

<p>];</p>

<p><br/></p>

<p>&lt;span data-model=&ldquo;[0]&rdquo;&gt;&lt;/span&gt;</p>

<p>&lt;div></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&lt;span data-model=&ldquo;[1].val&rdquo;&gt;&lt;/span&gt;</p>

<p>&lt;/div&gt;</p>

<p><br/></p>

<p>setFieldValue与getFieldValue我设置成了函数，</p>

<p>用来询问对于某个HTML元素，如何绑定值，如何获取值，</p>

<p>以获得最大的灵活性。</p>

<p><br/></p>

<p>并且，利用$.pluginManager.filter，接口可以简化成，</p>

<p>$(container).bindTemplate(&lsquo;setData&rsquo;,{</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;data:json</p>

<p>});</p>

<p>$(container).bindTemplate(&lsquo;getData&rsquo;);</p>

<p><br/></p>

<p>源代码如下：</p>

<p><a href="https://github.com/thzt/web.frontend.component/blob/master/library/jquerycore/jquerycore.js">jQuery core</a></p>

<p><a href="https://github.com/thzt/web.frontend.component/blob/master/library/pluginmanager/pluginmanager.js">plugin Manager</a></p>

<p>还好Github可以控制版本，如果以后文件更改了，还能找到今天的版本。</p>

<p><br/></p>

<p>于是，阳光还是那么灿烂，日子还是那么美好。</p>

<p>关键是生活的方式。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[设计的连续性]]></title>
    <link href="https://thzt.github.io/blog/2015/03/20/design/"/>
    <updated>2015-03-20T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/03/20/design</id>
    <content type="html"><![CDATA[<p>代码写的好，主要原因并不在于文字的输入水平。</p>

<p>而在于编写者在进行什么样的思考。</p>

<p>软件就是这样一点一滴逐步构建起来的。</p>

<p><br/></p>

<p>微小的改变累积起来，它的影响就是可观的。</p>

<p>是编写者无时无刻进行的选择，造就了软件的演变。</p>

<p>编写者的作用，经常被低估。</p>

<p><br/></p>

<p>好的设计，才能产生好的产品。</p>

<p>而不同于其他行业的是，</p>

<p>软件设计在设计之初是无法具体化的。</p>

<p><br/></p>

<p>只有设计者才能实现他的设计。</p>

<p>在遇到意外情况时，</p>

<p>也只有设计者知道怎样调整，才能保持一致。</p>

<p><br/></p>

<p>像行云和流水一样，</p>

<p>优美的设计体现在它遇到困难时的应变选择上，</p>

<p>而不体现在于它现阶段的实现方式上。</p>

<p><br/></p>

<p>好的设计，也会遇到问题，</p>

<p>但只有设计者才知道，</p>

<p>怎样用准备好的方式来解决它。</p>

<p><br/></p>

<h2><strong>设计和实现</strong></h2>

<p>水平较高的程序员，通常会被安排做设计。</p>

<p>而普通程序员，则要求去实现他们的设计。</p>

<p><br/></p>

<p>这其实是非常危险的。</p>

<p><br/></p>

<p>一方面，</p>

<p>设计的好坏，主要在面对具体问题时的选择上，</p>

<p>而这些选择，其实是由普通程序员来完成的。</p>

<p>设计者的水平虽高，却没有起到任何作用。</p>

<p><br/></p>

<p>另一方面，</p>

<p>设计者，如果不设身处地的遭遇问题，</p>

<p>就不能提供合适的解决方案。</p>

<p>因此，他的设计很可能是偏离实际的。</p>

<p><br/></p>

<p>最后，</p>

<p>高明的想法，是不容易被理解的。</p>

<p>普通程序员按着自己的理解，来编写代码。</p>

<p>会导致设计者遇到本来不会出现的问题。</p>

<p><br/></p>

<p>因此，不同的人，可以负责不同的功能模块，</p>

<p>但是，对问题的思考和解决，必须由一个人来完成。</p>

<p><br/></p>

<p>“我是这么想的，你来做吧。”</p>

<p>在软件行业中，通常是行不通的。</p>

<p><br/></p>

<p>高水平的程序员，可以被安排去做复杂的模块。</p>

<p>普通程序员，可以去做简单的模块。</p>

<p>让他们互相隔离，尽量少的产生影响。</p>

<p><br/></p>

<h2><strong>模块的自我保护——输入保护</strong></h2>

<p>软件提供的功能是分层次的，</p>

<p>虽然整个软件是交由目标用户来使用的，</p>

<p>但是，也可能软件的一部分是另一个部分的用户。</p>

<p><br/></p>

<p>处理好层次之间的依赖性，</p>

<p>才能保证软件稳定。</p>

<p><br/></p>

<p>作为功能的使用者来说，</p>

<p>最担心的就是，我们所依赖的模块发生变化了。</p>

<p><br/></p>

<p>这种变化其实是不可避免的。</p>

<p>因为，不断演变，是软件的本质特征，</p>

<p>就算不变坏，变好也是变化的一种。</p>

<p><br/></p>

<p>那该怎么办呢？</p>

<p><br/></p>

<p>事实上，我们需要知道自己想要什么，</p>

<p>并且，用可替换的方式实现自己的想要的功能。</p>

<p><br/></p>

<p>也就是说，我们并不依赖任何模块，</p>

<p>只依赖于我们的需要。</p>

<p>至于如何实现我们的需要，是灵活的，经得起变化的。</p>

<p><br/></p>

<p>例如：</p>

<p>在web应用中，我们需要一个对话框。</p>

<p>并不关心它是如何实现的。</p>

<p><br/></p>

<p>为了避免产生依赖，</p>

<p>我们首先封装自己的需要。</p>

<p>我们需要一个dialog，它可以弹出消息，dialog.pop(message)。</p>

<p><br/></p>

<p>然后，我们可以寻找任何已有的组件来实现需要。</p>

<p>var dialog={</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;pop:function(message){</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//调用已有组件，实现弹出消息功能</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>

<p>};</p>

<p><br/></p>

<p>这样的话，如果我们用来实现功能的组件发生了变化，</p>

<p>我们的需要并没有改变。</p>

<p>只需要用另一个组件来实现dialog.pop(message)即可。</p>

<p><br/></p>

<p>可以这样做的原因就是，</p>

<p>需要通常是稳定的，</p>

<p>而实现方式，通常是不稳定的。</p>

<p><br/></p>

<p>我们清楚的知道自己需要什么，</p>

<p>而别人提供的功能，我们并不清楚。</p>

<p><br/></p>

<h2><strong>模块的自我保护——输出保护</strong></h2>

<p>好的模块，内部也是层次良好的。</p>

<p>它们不是为同一目的而服务的。</p>

<p>也像整个软件那样，模块的一部分为另一部分提供服务。</p>

<p><br/></p>

<p>整个模块是变化中的，</p>

<p>其主要推动力在于，别人对模块的需求在不断变化。</p>

<p><br/></p>

<p>任何外在表现的更改，总是会影响到内部结构。</p>

<p>但是影响的方式，却与模块内部层次的划分有关。</p>

<p><br/></p>

<p>怎样保证在需求变更时，影响最小呢？</p>

<p><br/></p>

<p>这一次，我们就不能再使用封装的办法了。</p>

<p>因为我们无法封装变动的需求。</p>

<p>这也是面向对象思想，经常误用的地方。</p>

<p><br/></p>

<p>应该避免跟随别人的需要进行编程。</p>

<p>我们要有自己的功能集，</p>

<p>就像一个车厂要随时准备好零件一样。</p>

<p><br/></p>

<p>我们打算用零件来拼装需求。</p>

<p>当需求变更后，我们只需要添加或更换零件即可。</p>

<p>中国的“活字印刷术”就是这种思想的应用。</p>

<p><br/></p>

<p>例如：</p>

<p>在web应用中，我们需要提供一个对话框。</p>

<p>通常使用者会告诉我们，他们需要，dialog.pop(message)。</p>

<p><br/></p>

<p>为了避免需求的变化过度影响我们，</p>

<p>我们将需要的功能划分为可拼装的零件。</p>

<p><br/></p>

<p>myDialog.create(html);</p>

<p>myDialog.addClass(style);</p>

<p>myDialog.bindEvent(event);</p>

<p>myDialog.setMessage(message);</p>

<p><br/></p>

<p>这些足够了，我们并不想创建多余的功能。</p>

<p>然后，我们拼装产品。</p>

<p><br/></p>

<p>var dialog={</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;pop:function(message){</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myDialog.create(html);</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myDialog.addClass(style);</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myDialog.bindEvent(event);</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;myDialog.setMessage(message);</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;}</p>

<p>};</p>

<p><br/></p>

<p>这样的话，当需求发生变化时，myDialog不会整体受到影响，</p>

<p>增加或者更改部分功能以后，就可以制造新的产品了。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>对模块的保护，在输入端和输出端，是不同的。</p>

<p>不进行保护，或者不区分的进行保护，</p>

<p>都是危险的。</p>

<p><br/></p>

<p>模块的设计和实现，必须由一个人来完成。</p>

<p>因为，模块是可替换的，</p>

<p>而设计和实现是相联系的。</p>

<p><br/></p>

<p>本文提到的方法，只是一种解决方案。</p>

<p>其中包含的思想才是重要的。</p>

<p>可惜的是，它们包含的思想，也可能是过时的。</p>

<p>而发现这些思想的方法，是永不落伍的。</p>
]]></content>
  </entry>
  
</feed>
