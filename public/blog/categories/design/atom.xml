<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Design | 何幻]]></title>
  <link href="https://thzt.github.io/blog/categories/design/atom.xml" rel="self"/>
  <link href="https://thzt.github.io/"/>
  <updated>2016-10-30T20:52:09+08:00</updated>
  <id>https://thzt.github.io/</id>
  <author>
    <name><![CDATA[thzt]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[抽象与现实]]></title>
    <link href="https://thzt.github.io/blog/2016/09/21/abstraction/"/>
    <updated>2016-09-21T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/09/21/abstraction</id>
    <content type="html"><![CDATA[<p>抽象化，是数学的一种研究方法。</p>

<p>使用得当，则能扩大我们的视野，有助于看清问题的本质，</p>

<p>可是，有时候我们也会被抽象所累，使解决方案变得更复杂。</p>

<p><br/></p>

<p>在数学中，站在更高的角度看问题，是司空见惯的事情。</p>

<p>而且从每个层级来看，都可以再次抽象，站得更高。</p>

<p><br/></p>

<p>例如，从实际问题到线性方程组，从线性方程组到矩阵运算，</p>

<p>从矩阵运算到抽象代数，从群环域再到范畴论；</p>

<p>从实际问题到计算过程，从计算过程到它的描述方式，</p>

<p>从描述方式到形式语言，从语法和语义再到形式逻辑。</p>

<p><br/></p>

<h2><strong>两个极端</strong></h2>

<p>虽然数学有其自身的研究目的，</p>

<p>但是，在现实生活或者应用工程中，都把数学当做工具来看。</p>

<p>人们大多数的时间，都在解决具体问题，</p>

<p>看清问题背后的数学结构似乎毫无意义。</p>

<p><br/></p>

<p>其实不然，这是其中的一个极端，</p>

<p>忽略了全局性思考和洞见所起的作用。</p>

<p><br/></p>

<p>另一个极端，是试图总将问题抽丝剥茧，</p>

<p>也会引入不必要的层次性，使解决方案不够切题，</p>

<p>毕竟具体情况的特殊性和复杂性，才是主要特征。</p>

<p><br/></p>

<p>编程就是考虑了这两个极端之后权衡的结果，</p>

<p>我们既要为现实问题建立模型，简化它的描述方式，</p>

<p>又要适度的建模减少逻辑层次。</p>

<p><br/></p>

<p>不进行抽象是不行的，过度抽象也是不行的，</p>

<p>我们应该怎样做呢？</p>

<p><br/></p>

<h2><strong>封装</strong></h2>

<p>软件领域，有一个概念称为“封装”，</p>

<p>可以让我们把复杂性隐藏在某个“界面”之下，</p>

<p>使用这个“界面”的人，可以不关心内部的实现细节。</p>

<p><br/></p>

<p>这给我们提供了一种思路，</p>

<p>让我们可以在保持内部层次性的同时，</p>

<p>给最终用户提供朴素的“界面”，把锋芒藏起来。</p>

<p><br/></p>

<p>此外，“使用者”和“提供者”只是相对的概念，</p>

<p>内部的各个层次分别扮演着这些角色，</p>

<p>上层提供普适性的功能，下层作为使用者来具体化应用，</p>

<p>层层具体化，抵达最终“界面”。</p>

<p><br/></p>

<p>这种方式确实能让软件变得灵活，提高扩展性，</p>

<p>在需求不断变更的驱动下，最高层的适用范围会越来越广，</p>

<p>新出现的场景，都将成为某一层次不同具体化的结果。</p>

<p><br/></p>

<p>不幸的是，随着层次的增加，逻辑深度也会增加，</p>

<p>理解整套方案会变得越来越困难。</p>

<p><br/></p>

<p>我们提取出抽象，本来想让它具有普适性，</p>

<p>能用于更多类似的场景，</p>

<p>可悲的是，通常也是只适用于当前场景罢了。</p>

<p><br/></p>

<h2><strong>选择不做</strong></h2>

<p>经验告诉我们，我们如果不做一件事情，</p>

<p>往往不应该是我们没有看到它，</p>

<p>而是应该在会做的同时，选择不做它。</p>

<p><br/></p>

<p>因此，与其说选择影响了结果，</p>

<p>不如说，眼界影响了选择。</p>

<p><br/></p>

<p>上文提到，那些貌似普适性的抽象层给我们带来了麻烦，</p>

<p>如果不带来任何价值，我们就应该去掉它，</p>

<p>容忍它以普适性的身份混杂在具体应用中。</p>

<p><br/></p>

<p>能看到选择，却选择保持原样，</p>

<p>不仅需要卓越的眼光，还需要不凡的魄力，</p>

<p>心中追求完美，但是眼中要能容忍不完美，这才是关键。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>我们都学过设计模式，想过优化自己的设计，</p>

<p>于是就容易走入极端，</p>

<p>我们变得无法容忍拙劣的设计了。</p>

<p><br/></p>

<p>我们总想去调整它，去完善它，</p>

<p>可是却无意中增加了设计的精密程度。</p>

<p>为了不暴露这些复杂度，于是我们学会了掩饰它，隐藏它。</p>

<p><br/></p>

<p>可是，仅仅这样并不够，</p>

<p>我们细心的打磨零件，想让它在任何一台机器上都能被使用，</p>

<p>最终也只能用在这里。</p>

<p><br/></p>

<p>因此，好的办法是，我们看到这样的零件存在，</p>

<p>但是却不总是想着孤立它，战胜强迫症。</p>

<p>我们看到了背后优雅的数学，却不总是提及它，</p>

<p>大智若愚不如虚怀若谷。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[决策的秘密]]></title>
    <link href="https://thzt.github.io/blog/2016/09/12/the-secrets-of-decision-making/"/>
    <updated>2016-09-12T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/09/12/the-secrets-of-decision-making</id>
    <content type="html"><![CDATA[<p>当我们无法选择的时候，原因并不在我们自身，</p>

<p>在于客观上还不具备能够进行选择的条件。</p>

<p><br/></p>

<p>可悲的是，人们习惯性的把这种状况理解为内心的纠结，</p>

<p>反而忽视了决策形成条件的推动和促成。</p>

<p><br/></p>

<h2><strong>未来是朦胧的</strong></h2>

<p>我们所做的事情，虽然业界有很多方案可选，</p>

<p>但是我们实际上并不知道最终方案长什么样。</p>

<p><br/></p>

<p>我们自己也不知道最终能否实现，只能通过感觉，</p>

<p>我们更无法确定什么才是『最终方案』，连问题都在变化。</p>

<p><br/></p>

<p>因此，到底应该如何选型呢？</p>

<p>经验就一定是正确的吗？</p>

<p>选择的利弊应该通过什么来衡量呢？</p>

<p><br/></p>

<h2><strong>现状是瞬息万变的</strong></h2>

<p>软件领域中，</p>

<p>仅仅根据现状找到解决方案是不可行的，</p>

<p>因为世界不会等我们的方案实现之后再去变化。</p>

<p><br/></p>

<p>等代码写完，一切都变了，</p>

<p>到时候我们又要怪罪需求变更了。</p>

<p><br/></p>

<p>那么，软件应该怎样设计呢？</p>

<p>那些看起来优雅的设计，真的能发挥作用吗？</p>

<p>不好的设计，在长远看来真的就不合理吗？</p>

<p><br/></p>

<h2><strong>带着遗憾向前</strong></h2>

<p>其实，最难的事情就是直面自己的无能为力，</p>

<p>如果无法做出决策，那就先承认它。</p>

<p>只有承认了，在此基础上才能找到新的思路。</p>

<p><br/></p>

<p>而那些好的决策，并不是当场做出来的，</p>

<p>而是向前走得足够远，再绕回来修正的。</p>

<p>一个总是能有正确判断的人，并不是因为头脑灵活，</p>

<p>而是因为努力掌握更多的信息，拥有全局观点。</p>

<p><br/></p>

<p>因此，如果现在无法决定，就说明无论如何决定都是不可衡量的，</p>

<p>这个时候，就需要大胆尝试一个，带着遗憾去探索，</p>

<p>不要冥思苦想，原地打转。</p>

<p><br/></p>

<p>努力的目的，就是为了验证我们的选择。</p>

<p><br/></p>

<h2><strong>从现状看趋势</strong></h2>

<p>世界无时无刻不在变化，现状只是这种变化的某个快照，</p>

<p>因此，拥有动态发展的观点，能通过历史和现状看到趋势，才是重要的，</p>

<p>只有沿着趋势生长，软件才能活下来。</p>

<p><br/></p>

<p>不好的设计，违背发展趋势，与问题渐行渐远，</p>

<p>优雅的设计，和问题共生共荣。</p>

<p><br/></p>

<p>要看清趋势，并不是一件容易的事情，</p>

<p>这需要要理清所有相关责任人的想法，</p>

<p>因为，软件是人来做的，也是要用来解决人的问题的。</p>

<p><br/></p>

<p>沟通能力，并不是指把一件事情说清楚的能力，</p>

<p>而是主动了解信息，挖掘可能性，让事情向前发展，</p>

<p>打破僵局，促成一件事情的能力。</p>

<p><br/></p>

<h2><strong>快速试错</strong></h2>

<p>一件事耽搁的越久，成本就越大，</p>

<p>再退回去重新选择，几乎就不太可能了。</p>

<p>在经济学和商业决策制定过程中，会用到沉没成本，</p>

<p>指的是已经付出且不可收回的成本。</p>

<p><br/></p>

<p>因此，我们需要的是快速试错的能力，</p>

<p>考虑的太周全，就什么也得不到，错过很多机会，</p>

<p>犹豫不前不如快速失败。</p>

<p><br/></p>

<p>前进一步再退回来，重新选择，</p>

<p>再前进再退回来。</p>

<p>我们会获得额外的信息，得到直接的经验。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>当出现选择困难的时候，勉强进行选择，才是危险的，</p>

<p>此时此刻，我们应该去尝试，并证明某个选择不可行。</p>

<p><br/></p>

<p>如果永远无法证明呢？</p>

<p>那就相信命运。</p>

<p><br/></p>

<p>有些事情不是人力所能及，</p>

<p>每个人都有完成工作的方式，</p>

<p>很难说哪种方式更好。</p>

<p><br/></p>

<p>最难的事情就是直面自己的无能为力，</p>

<p>遗憾是生活的必需品。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[如何应对需求变更]]></title>
    <link href="https://thzt.github.io/blog/2016/06/02/requirement-change/"/>
    <updated>2016-06-02T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/06/02/requirement-change</id>
    <content type="html"><![CDATA[<h2><strong>对需求的误解</strong></h2>

<p>同学们经常提及的需求变更，其实变更的并不是需求，而是需求的实现方案。</p>

<p>首先，我们要对需求和方案进行区分。</p>

<p>需求包括以下几个方面，需求背景，需求目的，需求范围，需求的详细规格，以及错误处理方式。</p>

<p>UI/UE/UX，前端，后端，共同实现了需求，是同一个解决方案的不同侧面。</p>

<p><br/></p>

<p>因此从广义上来讲，开发者之间的内部沟通，不属于需求变更范畴。</p>

<p>软件的大部分问题，存在于开发者之间的沟通上面，而不是开发者对需求的理解上面。</p>

<p>只有理解了什么是需求，才能衡量出需求是否变更了。</p>

<p><br/></p>

<blockquote><p>在软件工程中，需求分析指的是在建立一个新的或改变一个现存的电脑系统时描写新系统的目的、范围、定义和功能时所要做的所有的工作。</p></blockquote>

<p><br/></p>

<h2><strong>从方法到目的</strong></h2>

<p>实现一个目的有多种方法，如何看到这些方法的共性呢？</p>

<p>最快的方式就是找到这些方法要解决的问题。</p>

<p>软件是以解决问题为目的的，不能解决问题的软件没有任何作用。</p>

<p><br/></p>

<p>这要分两方面来说，</p>

<p>其一，当产品经理发起需求变更时，我们要积极配合。因为，需求变更的主要原因在于当前软件不能解决某些问题。</p>

<p>不配合，那么做出的软件就没有用，我们的工作就没有价值。</p>

<p><br/></p>

<p>其二，我们要知道当前软件要解决的问题是什么，才能灵活的改变策略。</p>

<p>甚至可以利用工程师的领域特长，找到更合适的解决方案。</p>

<p><br/></p>

<h2><strong>变更与管控</strong></h2>

<p>我们不怕变化，怕的是对变化失去控制。</p>

<p>当产品经理发起需求变更时，我们要重新安排未完成任务的优先级，这是需要与产品经理沟通的。</p>

<p>因为，变更是需要成本的，意味着原计划要做的某些事情不能做完了，我们得让他们知道。</p>

<p><br/></p>

<p>我们自己首先得有一个任务列表。</p>

<p>然后以优先级的方式管理待办事项。</p>

<p><br/></p>

<h2><strong>知识共享</strong></h2>

<p>不同的人，对需求的理解不同。</p>

<p>每个人都会按照自己的方式去实现想法。</p>

<p>如何设计一个策略，怎样实现这个设计，大相径庭。</p>

<p><br/></p>

<p>因此，我们要预先做一些知识的分享。</p>

<p>在设计阶段排除问题，会比在实现阶段排除问题，成本低很多。</p>

<p>我们不妨谈一谈，我计划怎样解决这个问题，我打算怎样实现。</p>

<p>因为，很有可能，这个计划就是错的。</p>

<p><br/></p>

<h2><strong>主动去沟通</strong></h2>

<p>如果我想改某个文件，担心其他人也在改，以后合并起来麻烦，怎么办？</p>

<p>去问他/她。</p>

<p>某位同学的代码我看不懂，不敢改怎么办？</p>

<p>去问他/她。</p>

<p>产品经理对需求的描述不清楚，我理解不了怎么办？</p>

<p>去问他/她。</p>

<p>交互稿中文案可能有错误，逻辑矛盾，怎么办？</p>

<p>去问他/她。</p>

<p>测试提了一个缺陷，可是我不知道在说什么，也不知道在哪个场景中会出现，怎么办？</p>

<p>去问他/她。</p>

<p><br/></p>

<p>&ldquo;问"，这个简单的动作，会节省大量的时间。</p>

<p>如果不想打断别人的工作，可以用一些非即时沟通工具。</p>

<p>或者走到他旁边，让他注意到你时，你再发问。</p>

<p><br/></p>

<p>提问，并不愚蠢，不问才蠢。</p>

<p>要相信大部分工程师都是喜欢被问的。</p>

<p><br/></p>

<h2><strong>让设计灵活响应变更</strong></h2>

<p>好的设计，在变更中灵活响应。</p>

<p>这实际上是对设计提出了更高的要求，不止是实现功能那么简单了。</p>

<p><br/></p>

<p>因为现实世界是发展中的，业务场景也在与时俱进。</p>

<p>因此，需求本身不可能是不变的。</p>

<p>软件是一个解决动态问题的方案。</p>

<p><br/></p>

<p>程序设计是用来解决发展中问题的。</p>

<p>我们要看到问题的发展趋势，结合整个过程进行设计。</p>

<p>给未来留下余地，不局限于当前状态进行设计。</p>

<p><br/></p>

<p>需求你怎么改都行，因为你不得不改，我也不得不照做，不然软件本身就没用了。</p>

<p>但是我的设计保障我修改的成本最低。</p>

<p><br/></p>

<h2><strong>原谅别人的失误</strong></h2>

<p>人非圣贤孰能无过。</p>

<p>我们会因为手误打错代码，也会因为大脑一时短路犯逻辑错误。</p>

<p>那么，产品经理同样也会对需求理解和描述产生偏差。</p>

<p>我们不能要求别人做到完美。</p>

<p><br/></p>

<p>一方面，我们要原谅他们，但要让他们知道大家的代价。</p>

<p>另一方面，我们要听思想，不要听描述。抓住中心思想，忽略细节。</p>

<p><br/></p>

<p>严于律己，宽以待人。</p>

<h2><strong>结语</strong></h2>

<p>大部分软件从业者，没有软件工程相关的培训，也没有阅读过相关书籍，</p>

<p>是依靠自己的感觉来做软件的。</p>

<p><br/></p>

<p>结果会沿用一些不恰当的类比来理解软件，</p>

<p>也会逐渐形成小作坊式的软件开发过程。</p>

<p>当团队规模扩大时，问题就会越来越严重。</p>

<p><br/></p>

<p>不过，没关系，这有什么。</p>

<p>痛了才会想办法去解决，也无需过度设计。</p>

<p>只是现在我们是否该学一些软件工程的知识了呢？</p>

<p><br/></p>

<p><strong>参考：</strong></p>

<p><a href="https://book.douban.com/subject/1007738/">快速软件开发</a></p>

<p><a href="https://book.douban.com/subject/1140457/">敏捷软件开发 : 原则、模式与实践</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[让事情去发生]]></title>
    <link href="https://thzt.github.io/blog/2016/05/29/let-things-happen/"/>
    <updated>2016-05-29T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/05/29/let-things-happen</id>
    <content type="html"><![CDATA[<p>经验增长，并不完全是一件好事，</p>

<p>它也许会阻止本来可能发生的事情。</p>

<p><br/></p>

<p>我们凭着经验来进行判断，</p>

<p>除非遇到完全相同的初始条件，</p>

<p>否则，这样的判断和随意猜测并没有什么不同。</p>

<p><br/></p>

<p>我们踩到的坑多了，走路都战战兢兢，</p>

<p>一年被蛇咬，十年怕井绳。</p>

<p><br/></p>

<p>如何打破经验主义的误区呢？</p>

<p>那就是，让事情去发生。</p>

<p><br/></p>

<p>现实世界中的事情都是发展中的，</p>

<p>我们得有胆量让事情去发展，</p>

<p>然后掌控它的发展过程。</p>

<p><br/></p>

<h2><strong>把责任交出去</strong></h2>

<p>篮球是一项团体运动，</p>

<p>在打篮球时，我们用的最多的是传接球。</p>

<p><br/></p>

<p>可是，新手组织后卫往往无法理解，</p>

<p>球传出去以后，自己都无法掌控它了，</p>

<p>怎样组织这次进攻呢？</p>

<p><br/></p>

<p>这类似于其他团队合作中的责任，</p>

<p>不敢把责任交出去，</p>

<p>担心别人做不好。</p>

<p><br/></p>

<p>这样就无法达到默契的配合。</p>

<p><br/></p>

<p>高手组织后卫怎样理解这件事情呢？</p>

<p>他首先会观察比赛的发展态势，</p>

<p>然后通过运球去影响这个态势的走向，</p>

<p>随后，把球顺着态势传出去。</p>

<p><br/></p>

<p>这样的话，其他人的行为就会被态势所牵引。</p>

<p>比赛仍然在掌控中。</p>

<p><br/></p>

<p>所以，难能可贵的是，</p>

<p>让比赛进行，把球传出去。</p>

<p><br/></p>

<h2><strong>最佳实践</strong></h2>

<p>软件项目中，有前人总结的无数最佳实践，</p>

<p>不遵循它们，会犯很多前人已经犯过的错误。</p>

<p><br/></p>

<p>然而，完全遵循它们，</p>

<p>又会抹杀掉未来的某些可能性。</p>

<p><br/></p>

<p>每种方案都有适得其所的用处，</p>

<p>没有在任何情况下都不适用的方案，</p>

<p>不用它，其实很多人是因为没有真正掌握它。</p>

<p><br/></p>

<p>很多方案是发展而来的，</p>

<p>到了那个境地，解决方案是显而易见的，</p>

<p>现在不用费尽心思，假定到时候很糟。</p>

<p><br/></p>

<p>最佳实践的作用，应该是为了选择方向，</p>

<p>强行预测未来的细节，会担惊受怕，畏首畏尾。</p>

<p><br/></p>

<p>你有胆量让不那么好的事情发生吗？</p>

<p>其实，不那么好与不那么坏，并没有什么区别。</p>

<p><br/></p>

<h2><strong>如何培养人</strong></h2>

<p>世界上最困难的就是把一件你很拿手的工作交给别人，</p>

<p>再眼睁睁看着他把事情搞砸，</p>

<p>而你却还能心平气和不发一言，</p>

<p>那是培养人。</p>

<p>世界上最容易的就是把一件你很拿手的工作交给别人，</p>

<p>再手把手地教他把事情做对，</p>

<p>不给他犯错机会，</p>

<p>那不是培养人，而是锻炼你自己。</p>

<p>——《有一种培养叫放手》</p>

<p><br/></p>

<p>并不是每件事情按计划发生就是好的，</p>

<p>不同的发展轨迹，人们从中的收获也不同。</p>

<p><br/></p>

<p>不让坏事情去发生，就不会身临其境，</p>

<p>没有把事情搞砸过，就不会反思过程。</p>

<h2><strong>人与事情的发展</strong></h2>

<p>事情的发展，总是会涉及到很多人，</p>

<p>因此，个人的作用其实并不那么重要。</p>

<p><br/></p>

<p>让事情去发展，才能观察态势，</p>

<p>才能改变它，才能影响它。</p>

<p><br/></p>

<p>不要把自己看得那么重要，</p>

<p>包括自己在内，大家都是顺势而为，</p>

<p>不改变态势，结果早就被决定了，</p>

<p>有你没你都一样。</p>

<p><br/></p>

<p>所以，要想赢得比赛，</p>

<p>就得做那个能影响比赛走势的人。</p>

<p><br/></p>

<p>不然的话，</p>

<p>胜败已定，预测的再准又有什么用？</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>Let things happen, let them win.</p>

<p>这不仅仅是一种洒脱的态度，</p>

<p>更多的是为了影响事情的整个发展过程。</p>

<p><br/></p>

<p>如果说，新手从犯错，到学会提前意识到错误，是一个进步，</p>

<p>那么老手从丰富的经验，到违反经验的大胆尝试，更是一个进步。</p>

<p><br/></p>

<p>新手，通常把方案静态的理解为当前场景的解，</p>

<p>而高手，更能看到事情的发展过程，</p>

<p>以及采取某个方案，会对事情发展产生什么影响。</p>

<p><br/></p>

<p>让事情发生吧，我来做观众。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[面向痛点的应变之道]]></title>
    <link href="https://thzt.github.io/blog/2016/05/16/pain-oriented-design/"/>
    <updated>2016-05-16T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/05/16/pain-oriented-design</id>
    <content type="html"><![CDATA[<p>上学写论文时，流传着这么一句话，</p>

<p>『大家虽然不知道鬼的样子，却都在画鬼。』</p>

<p>当时，觉得好有道理啊，我们提出了各种理论模型，却不知道世界到底是什么样子。</p>

<p><br/></p>

<p>没想到后来进入了软件行业，也会遇到同样的问题。</p>

<p><br/></p>

<p>我们很多项目，发起人其实并不知道要做成什么，</p>

<p>只是想做这个，想做那个，</p>

<p>似乎把想做的功能都做完，项目就成了。</p>

<p><br/></p>

<p>我们假想存在某个问题，甚至都没有去调查，</p>

<p>我们觉得别人一定会来用，甚至都没想着去接受反馈，</p>

<p>我们自以为现存方案的问题很多，甚至都没用过它。</p>

<p><br/></p>

<p>这就是在『<strong>画鬼</strong>』，</p>

<p>是一群人憋着实在想做些什么的时候的宏观表现。</p>

<p><br/></p>

<p>那么，我们积极向上的心态，不对吗，</p>

<p>我们想造福社会，推动进步，不好吗？</p>

<p><br/></p>

<p>当然好，只不过要坚持一些设计原则。</p>

<p><br/></p>

<h2><strong>痛点</strong></h2>

<p>学过软件工程之后，我们知道，进行需求分析时，我们得先确定需求的背景和目的。</p>

<p>为什么要做这件事，是什么引起的，<strong>动机</strong>是什么。</p>

<p>只有确定了问题，才能有的放矢。</p>

<p>这是对新项目而言。</p>

<p><br/></p>

<p>而对于实际的项目，几乎都是以现有的解决方案为起点的，</p>

<p>我们还要问，当前方案的<strong>痛点</strong>是什么，哪里做的不够好，</p>

<p>这些问题的优先级怎么安排，怎样逐步解决它。</p>

<p><br/></p>

<p>通过分析痛点，我们才能找到<strong>立项的原因</strong>。</p>

<p>不是我们想做什么，而是我们不得不解决它。</p>

<p>没有迫不得已的形势，事情就不会往前发展。</p>

<p><br/></p>

<p>我们不要急着去解决问题，</p>

<p>而是先要确定，<strong>到底要解决什么问题</strong>。</p>

<p><br/></p>

<h2><strong>应变之道</strong></h2>

<p>应变，是可以锻炼的。</p>

<p><br/></p>

<p>看到每一个方案时，不妨考虑下，它们是<strong>怎样被设计出来的</strong>。</p>

<p>这样才能积累经验，在遇到困难的时候，找到切实可用的办法。</p>

<p><br/></p>

<p>每一个解决方案，都是为它的目的服务的，</p>

<p>人们做了哪些折衷和让步，又是以何种程度达到目的的。</p>

<p><br/></p>

<p>我们要学的，不是会用哪些招数，</p>

<p>而是，<strong>学会这些招数的创造方法</strong>。</p>

<p><br/></p>

<p>由此，繁杂的方案就不会迷惑我们了，</p>

<p>像工匠能看到工具的问题一样，我们会看到<strong>方案的缺陷</strong>，和它们引起的新问题。</p>

<p><br/></p>

<p>无招胜有招。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>不能确定待解决的问题。</p>

<p>给定一个问题，想不出适用的解决方案。</p>

<p><br/></p>

<p>这是两个难点。</p>

<p>我们会假想一个问题，结果做完了以后才发现白费心思。</p>

<p>我们会用流行的解决方案，结果发现越走越远。</p>

<p><br/></p>

<p>经验多了，熟练掌握各种框架类库之后，这两个能力并不会相应提高。</p>

<p>我们需要刻意的训练，才能学会『面向痛点的应变之道』。</p>

<p><br/></p>

<p>Love of bustle is not industry. ——Seneca</p>
]]></content>
  </entry>
  
</feed>
