<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Haskell | 何幻]]></title>
  <link href="https://thzt.github.io/blog/categories/haskell/atom.xml" rel="self"/>
  <link href="https://thzt.github.io/"/>
  <updated>2016-08-24T14:21:17+08:00</updated>
  <id>https://thzt.github.io/</id>
  <author>
    <name><![CDATA[thzt]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Hask范畴上的Monad]]></title>
    <link href="https://thzt.github.io/blog/2016/01/11/monad-in-hask-category/"/>
    <updated>2016-01-11T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/01/11/monad-in-hask-category</id>
    <content type="html"><![CDATA[<p>范畴论是一个迷人的领域，</p>

<p>它是一门研究<strong>数学结构</strong>以及<strong>结构之间关系</strong>的理论。</p>

<p><br/></p>

<p>不知道我们学群论时，</p>

<p>是否感觉到了群同态与集合间映射的相似性。</p>

<p>学拓扑学时，</p>

<p>是否感觉到了连续映射与微分流形间光滑映射的相似性。</p>

<p><br/></p>

<p>范畴论统一了这些相似结构。</p>

<p>然而，这还要从抽象代数说起。</p>

<p><br/></p>

<h2>幺半群（monoid）</h2>

<p>在抽象代数中，<strong>幺半群</strong>是这样定义的。</p>

<p><br/></p>

<p>集合S和S上满足结合律的封闭二元运算"•"，</p>

<p>所形成的代数结构称为<strong>半群</strong>，记为(S, •)，简记为S</p>

<p><br/></p>

<p>设S是半群，元素e∈S，称为半群S的<strong>幺元素</strong>，</p>

<p>如果对于每一个x∈S，有xe=ex=x</p>

<p><br/></p>

<p>如果半群S有幺元素e，则它是唯一的。</p>

<p>含有幺元素的半群称为<strong>幺半群</strong>。</p>

<p><br/></p>

<p>注：</p>

<p>半群G如果有幺元素，且每个元素均可逆，</p>

<p>则称G为<strong>群</strong></p>

<p><br/></p>

<h2>图示法（diagram）</h2>

<p>一个幺半群M，可以描述为一个集合M，和两个函数</p>

<p>µ : M × M -> M</p>

<p>η : 1 -> M</p>

<p><br/></p>

<p>其中，1 = {0}是只有一个元素的集合。</p>

<p><br/></p>

<pre>           1 × µ<br>M × M × M -------&gt; M × M<br>    |                |<br>    | µ × 1          | µ<br>    |                |<br>    v                v<br>  M × M   -------&gt;   M<br>             µ</pre>




<pre>        η × 1          1 × η<br>1 × M -------&gt; M × M &lt; ------- M × 1<br>  |              |               |<br>  | α            | µ             | β<br>  |              |               |<br>  v              v               v<br>  M      =       M        =      M</pre>


<p><br/></p>

<p>用元素来表示图表，可以写为，</p>

<p><br/></p>

<pre>&lt;x,y,z&gt; |-------&gt;    &lt;x,yz&gt;<br>   -                   -<br>   |                   |<br>   |                   |<br>   v                   v<br>&lt;xy,z&gt;  |-------&gt; (xy)z=x(yz)</pre>




<pre>&lt;0,x&gt; |-------&gt; &lt;e,x&gt;    &lt;x,e&gt; &lt;-------| &lt;x,0&gt;<br>  -               -        -               -<br>  |               |        |               |<br>  |               |        |               |<br>  v               v        v               v<br>  x       =      ex       xe       =       x</pre>


<p><br/></p>

<p>可以看出，(xy)z=x(yz)表示了群乘法的结合律，</p>

<p>x=ex,xe=x表示了幺元e，因此图表展示了幺半群的结构。</p>

<p><br/></p>

<h2>范畴（category）</h2>

<p>一个<strong>范畴</strong>C由一系列<strong>对象</strong>（object）和<strong>箭头</strong>（arrow）组成。</p>

<p>对于每一个箭头f，有两个对象与之关联，</p>

<p>称为箭头f的定义域（domain）和值域（codomain）。</p>

<p>并且，满足以下几条规则，</p>

<p>（1）对于每一个对象a，存在恒等箭头（identity arrow），i:a->a</p>

<p>（2）箭头满足结合律，对于任意的箭头f,g,h有(f•g)•h=f•(g•h)</p>

<p>（3）箭头的集合在箭头组合运算下是封闭的</p>

<p><br/></p>

<p>注：</p>

<p>f•g表示g和f的组合运算，它也是一个箭头，其中g的值域是f的定义域</p>

<p><br/></p>

<p>例：</p>

<p>所有的集合，以集合作为对象，集合间的映射作为箭头，构成了一个范畴，</p>

<p>所有的群，以群作为对象，群同态作为箭头，构成了一个范畴，</p>

<p>所有的拓扑空间，以拓扑空间作为对象，拓扑空间之间的连续映射为箭头，构成了一个范畴，</p>

<p>所有的微分流形，以微分流形作为对象，流形间的光滑映射为箭头，构成了一个范畴，</p>

<p>Haskell中，以类型作为对象（类型是值的集合），函数作为箭头，构成了一个范畴（<strong>Hask范畴</strong>）。</p>

<p><br/></p>

<h2>函子（functor）</h2>

<p>如果把范畴看做对象，则函子可以看做箭头。</p>

<p><br/></p>

<p>一个<strong>函子</strong>F是范畴C到范畴D的箭头，F:C -> D，</p>

<p>它满足以下条件，</p>

<p>F把C中的对象c映射为D中的对象F c，把C中的箭头f映射为D中的箭头F f。</p>

<p>且满足分配律，F (f•g)=(F f)•(F g)</p>

<p><br/></p>

<p>注：</p>

<p>等式左边的"•"表示C中的箭头组合运算，</p>

<p>等式右边的"•"表示D中的箭头组合运算。</p>

<p><br/></p>

<p>范畴C到自身的函子，称为<strong>自函子</strong>（endofunctor）。</p>

<p><br/></p>

<p>Hask范畴的自函子把Haskell中的类型a映射为另一个类型f a，</p>

<p>把类型a到类型b的函数，映射为类型f a到类型f b的函数。</p>

<p><br/></p>

<p>class Functor f where</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmap :: (a -> b) -> f a -> f b</p>

<p><br/></p>

<p>class Functor f => Applicative f where</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pure :: a -> f a</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;*>) :: f (a -> b) -> f a -> f b</p>

<p><br/></p>

<p>我们看到，pure和fmap放在一起，</p>

<p>构成了一个Hask范畴的自函子。</p>

<p><br/></p>

<h2>自然变换（natural transformation）</h2>

<p>如果把函子看做对象，则自然变换可以看做箭头。</p>

<p><br/></p>

<p>若F和G是范畴C到D的函子，则<strong>自然变换</strong>τ是一个箭头，τ: F -> G，</p>

<p>它满足以下条件，</p>

<p><br/></p>

<pre>     f<br>a -------&gt; b</pre>




<pre>      F f<br>F a -------&gt; F b<br>|            |<br>| τ a        | τ b<br>|            |<br>v            v<br>G a -------&gt; G b<br>      G f</pre>


<p><br/></p>

<p>注：</p>

<p>F a是D中与a对应的对象，F b是D中与b对应的对象，F f是D中与f对应的箭头</p>

<p><br/></p>

<h2>函子范畴（functor category）</h2>

<p>以范畴C到D的函子为对象，以函子间的自然变换为箭头，</p>

<p>构成了一个范畴，称为<strong>函子范畴</strong>。</p>

<p><br/></p>

<p>易知，自然变换可以进行组合运算，</p>

<p>设µ a : F a -> G a，η a : G a -> H a</p>

<p>则可以定义一个新的自然变换(η • µ) a = F a -> H a</p>

<p>可证自然变换的组合运算满足结合律。</p>

<p><br/></p>

<p>注：</p>

<p>函子范畴的对象，不是一个集合，</p>

<p>函子范畴的箭头，也不是映射。</p>

<p><br/></p>

<h2>Monad</h2>

<p>范畴C上的monad，是一个<strong>三元组</strong>(F,µ,η)，其中</p>

<p>F是范畴C上的自函子，</p>

<p>µ是F<sup>2</sup>到F的自然变换，µ:F<sup>2</sup>->F，</p>

<p>η是单位自函子I到F的自然变换，η:I->F</p>

<p><br/></p>

<p>且满足以下条件</p>

<p><br/></p>

<pre>           F • µ<br>F • F • F -------&gt; F • F<br>    |                |<br>    | µ • F          | µ<br>    |                |<br>    v                v<br>  F • F   -------&gt;   F<br>             µ</pre>




<pre>        η • F          F • η<br>I • F -------&gt; F • F &lt; ------- F • I<br>                 |                <br>  ||             | µ            ||<br>                 |               <br>                 v                <br>  F      =       F        =      F</pre>


<p><br/></p>

<p>在Haskell中可以这样表示：</p>

<p><br/></p>

<p>{- 自函子F，作用在对象上时 -}</p>

<p>fObj :: (Applicative f) => a -> f a</p>

<p>fObj = pure</p>

<p><br/></p>

<p>{- 自函子F，作用在箭头上时 -}</p>

<p>fArr :: (Applicative f) => (a -> b) -> (f a -> f b)</p>

<p>fArr = fmap</p>

<p><br/></p>

<p>{- 自函子F<sup>2</sup> -}</p>

<p><br/></p>

<p>f2Obj :: (Applicative f) => a -> f (f a)</p>

<p>f2Obj = fObj . fObj</p>

<p><br/></p>

<p>f2Arr :: (Applicative f) => (a -> b) -> (f (f a) -> f (f b))</p>

<p>f2Arr :: fArr . fArr</p>

<p><br/></p>

<p>{- 单位自函子，作用到对象上时 -}</p>

<p>iObj :: a -> a</p>

<p>iObj = id</p>

<p><br/></p>

<p>{- 单位自函子，作用到箭头上时 -}</p>

<p>iArr :: (a -> b) -> (a -> b)</p>

<p>iArr = id</p>

<p><br/></p>

<p>{- 自然变换µ:F<sup>2</sup>->F，（µ a:F<sup>2</sup> a->F a） -}</p>

<p>µ :: (Applicative f) => a -> f (f a) -> f a</p>

<p><br/></p>

<p>{- 自然变换η:I->F，（η a:I a->F a） -}</p>

<p>η :: (Applicative f) => a -> a -> (f a)</p>

<p><br/></p>

<h2>自函子范畴上的幺半群</h2>

<p>以范畴C上的自函子为对象，自然变换为箭头，</p>

<p>构成的函子范畴，称为<strong>自函子范畴</strong>。</p>

<p><br/></p>

<p>对比Monad定义中的自函子F与幺半群中的集合M，</p>

<p><br/></p>

<p><strong>结合律</strong>：</p>

<pre>           1 × µ<br>M × M × M -------&gt; M × M<br>    |                |<br>    | µ × 1          | µ<br>    |                |<br>    v                v<br>  M × M   -------&gt;   M<br>             µ</pre>




<pre>           F • µ<br>F • F • F -------&gt; F • F<br>    |                |<br>    | µ • F          | µ<br>    |                |<br>    v                v<br>  F • F   -------&gt;   F<br>             µ</pre>


<p><strong>幺元</strong>：</p>

<pre>        η × 1          1 × η<br>1 × M -------&gt; M × M &lt; ------- M × 1<br>  |              |               |<br>  | α            | µ             | β<br>  |              |               |<br>  v              v               v<br>  M      =       M        =      M</pre>




<pre>        η • F          F • η<br>I • F -------&gt; F • F &lt; ------- F • I<br>                 |                <br>  ||             | µ            ||<br>                 |               <br>                 v                <br>  F      =       F        =      F</pre>


<p><br/></p>

<p>可知，自函子F相当于群的集合M，自然变换µ相当于群乘法，单位自函子相当于幺元，它们构成了一个<strong>幺半群</strong>，</p>

<p>即<strong>Monad是Hask自函子范畴上的幺半群</strong>。</p>

<p><br/></p>

<p>注：</p>

<p>M × M × M表示集合M的笛卡尔积，</p>

<p>而F • F • F表示自函子F的组合。</p>

<p><br/></p>

<h2>幺半群范畴（monoidal category）</h2>

<p>幺半群在范畴论中是有了新的意义，</p>

<p>比群论中的概念更一般化。</p>

<p><br/></p>

<p>我们可以为范畴增加一个满足结合律的二元函子，</p>

<p>构成一个『范畴论意义上的』<strong>幺半群</strong>（monoid）。</p>

<p><br/></p>

<p>说一个范畴是具有幺半群结构的（monodial），</p>

<p>如果它有一个像笛卡尔积，或者直和，张量积，那样的『乘积』，</p>

<p>并且，这个『乘积』满足结合律，还有一个单位元。</p>

<p><br/></p>

<p>即，一个<strong>严格幺半群范畴</strong>（strict monoidal category）是范畴B上的一个结构&lt;B,□,e&gt;，</p>

<p>其中□是一个满足结合律的二元函子，□: B × B -> B，</p>

<p>□ (□ × 1) = □ (1 × □) : B × B × B -> B</p>

<p>而且存在对象e是二元函子□的单位元，</p>

<p>□ (e × 1) = id(B) = □ (1 × e)</p>

<p><br/></p>

<p>然后就可以在任意的幺半群范畴&lt;B,□,e&gt;中定义幺半群了。</p>

<p><br/></p>

<p>幺半群范畴B上的<strong>幺半群</strong>由三部分组成，&lt;c,µ,η&gt;，</p>

<p>其中c是B中的对象，µ : c □ c -> c，η : e -> c是范畴B中的箭头，</p>

<p>且满足以下条件</p>

<pre>               σ                  µ □ 1<br>c □ (c □ c) -------&gt; (c □ c) □ c -------&gt; c □ c<br>    |                                       |<br>    | 1 □ µ                                 | µ<br>    |                                       |<br>    v                                       v<br>  c □ c ----------------------------------&gt; c<br>                        µ</pre>




<pre>        η □ 1          1 □ η<br>e □ c -------&gt; c □ c &lt; ------- c □ e<br>  |              |               |<br>  | α            | µ             | β<br>  |              |               |<br>  v              v               v<br>  c      =       c        =      c</pre>


<p><br/></p>

<h2>结语</h2>

<p>『All told, a monad in X is just a monoid in the category of endofunctors of X,</p>

<p>with the product × replaced by composition of endofunctors</p>

<p>and unit set by the identity endofunctor.』</p>

<p><br/></p>

<p>一语成谶，很多人都是因为这句话入坑的，</p>

<p>然而理解它真的很不容易，</p>

<p>原来这个『幺半群』应该在范畴论意义上进行理解，</p>

<p>已经不是集合论基础上群论的内容了。</p>

<p><br/></p>

<p>在写这篇文章时，我甚至还没有入门，有错误在所难免，</p>

<p>但是多年坚持下来，似乎对这个问题有些眉目了，</p>

<p>于是就赶紧整理了一下，希望接下来以此为起点继续努力，勇往直前。</p>

<p><br/></p>

<p><strong>参考</strong>：</p>

<p>《<a href="http://book.douban.com/subject/4201293/">近世代数引论</a>》</p>

<p>《<a href="http://book.douban.com/subject/1823110/">Categories for the Working Mathematician 2nd</a>》</p>

<p><a href="https://medium.com/@brettwines/implementing-a-category-theoretic-hask-monad-in-haskell-7bf662f2e98b">Implementing a category-theoretic Hask-monad in Haskell</a></p>

<p><a href="http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem">A monad is just a monoid in the category of endofunctors, what&rsquo;s the problem?</a></p>

<p><a href="http://slides.com/julientournay/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-what-s-the-problem/fullscreen">A MONAD IS JUST A MONOID IN THE CATEGORY OF ENDOFUNCTORS. WHAT&rsquo;S THE PROBLEM ?</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[惰性求值]]></title>
    <link href="https://thzt.github.io/blog/2015/07/12/lazy-evaluation/"/>
    <updated>2015-07-12T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/07/12/lazy-evaluation</id>
    <content type="html"><![CDATA[<p><strong>据说</strong>Haskell是一种惰性求值的语言，</p>

<p>表达式的求值策略是按需求值，即call-by-need。</p>

<p><br/></p>

<p>但是到底什么才是按需的，</p>

<p>求值到什么程度。</p>

<p>刚开始学习的时候，总是很模糊。</p>

<p><br/></p>

<p>随着学习的深入，才慢慢了解，</p>

<p>Haskell规范中，并没有涉及惰性求值，</p>

<p>只说它是一种<strong>non-strict language</strong>，</p>

<p>求值策略取决于具体的实现。</p>

<p><br/></p>

<p>这是怎么回事呢？</p>

<p>又要从头开始了。</p>

<p><br/></p>

<h2><strong>non-strictness</strong></h2>

<p>non-strict function，是<strong>指称语义</strong>中的概念，</p>

<p>指称语义将每一段代码，与一个数学对象相对应，</p>

<p>借此来研究程序的语义。</p>

<p><br/></p>

<p>一开始我们认为，程序中的函数，</p>

<p>会有直接的数学函数与之对应。</p>

<p><br/></p>

<p>其实不然，</p>

<p>因为，程序中的很多函数，在处理某些参数的时候，</p>

<p>行为是“未定义的”，得不到有用的信息，</p>

<p>这样的数学函数称为<strong>部分函数</strong>（partial function）。</p>

<p><br/></p>

<p>这里尽量<a href="http://www.vex.net/~trebla/haskell/lazy.xhtml">不要提及“不能终止的”</a>，</p>

<p>因为指称语义并不考虑求值过程。</p>

<p><br/></p>

<p>例如：</p>

<p>partialFn :: Integer -> Integer</p>

<p>partialFn 0 = 0</p>

<p>partialFn n = test $ n + 1</p>

<p><br/></p>

<p>可以看到partial只在参数为0的时候是有意义的。</p>

<p>所以，与程序中的函数对应的，</p>

<p>就不是普通意义上的数学函数了，</p>

<p>还需要<strong>扩充定义域和值域</strong>。</p>

<p><br/></p>

<p>我们为每个集合增加一个新的值“<strong>⊥</strong>”，称为bottom，</p>

<p>用来表示“未定义”。</p>

<p>函数f(n)={0,n=0;⊥,n≠0}，就能表示partialFn了。</p>

<p><br/></p>

<p>Haskell用undefined来表示⊥，</p>

<p>undefined也确实包含在所有类型中，</p>

<p>> :t undefined</p>

<p>> undefined :: a</p>

<p><br/></p>

<p>通常情况下，</p>

<p>如果一个数学函数的参数是⊥，则结果就是⊥。</p>

<p>这样的函数称为<strong>strict function</strong>。</p>

<p><br/></p>

<p>而Haskell中函数则不同。</p>

<p>例如：</p>

<p>nonStrictFn :: Integer -> Integer</p>

<p>nonStrictFn 0 _ = 0</p>

<p><br/></p>

<p>nonStrictFn 0 undefined
> 0</p>

<p><br/></p>

<p>函数nonStrictFn在参数包含undefined的时候，</p>

<p>并没有得到undefined，而是得到了一个明确的值0，</p>

<p>它对应的数学函数是<strong>non-strict function</strong>。</p>

<p><br/></p>

<p>函数的指称语义是non-strict function，</p>

<p>这样的语言，称为non-strict language。</p>

<p><br/></p>

<h2><strong>lazy evaluation</strong></h2>

<p>求值，是<strong>操作语义</strong>中的概念。</p>

<p><strong>能实现non-strict指称语义的求值策略并不是唯一的</strong>。</p>

<p><br/></p>

<p>GHC是Haskell目前最流行的编译器，</p>

<p>它使用了<strong>惰性求值</strong>（lazy evaluation）。</p>

<p><br/></p>

<p>例如：</p>

<p>x = 1</p>

<p>y = 2</p>

<p>z = (x, y)</p>

<p><br/></p>

<p>> :sprint x</p>

<p>> x = _</p>

<p>> :sprint y</p>

<p>> y = _</p>

<p>> :sprint z</p>

<p>> y = _</p>

<p><br/></p>

<p>这里“:sprint”只是打印表达式，而不会求值它。</p>

<p>“_”用来表示“未求值的”，或称为一个“<strong>thunk</strong>”。</p>

<p><br/></p>

<p>thunk在使用的时候，<strong>并不一定被完全求值</strong>。</p>

<p>> let first = (u, _) = u</p>

<p>> first z</p>

<p>> 1</p>

<p><br/></p>

<p>> :sprint x</p>

<p>> x = 1</p>

<p>> :sprint y</p>

<p>> y = _</p>

<p>> :sprint z</p>

<p>> y = (1, _)</p>

<p><br/></p>

<p>first函数，只求值了第一个参数，</p>

<p>第二个参数，仍然是未求值的。</p>

<p><br/></p>

<p>实际上，<strong>thunk的求值是分层次的</strong>，</p>

<p>为了尽量少的求值，每一次只将表达式求值为<strong>WHNF</strong>（weak head normal form），</p>

<p>其中的子表达式，仍然是未求值的thunk。</p>

<p><br/></p>

<p>如果不能满足需要，</p>

<p>就会继续将对应的sub-thunk，再求值为WHNF。</p>

<p><br/></p>

<h2><strong>Weak head normal form</strong></h2>

<p>一个WHNF（weak head normal form），</p>

<p>是表达式求值的一种结果形式。</p>

<p><br/></p>

<p>WHNF，只将表达式求值到，</p>

<p>最外层的<strong>值构造器</strong>或者<strong>lambda抽象</strong>为止。</p>

<p><br/></p>

<p>例如：以下表达式是WHNF，</p>

<p>(1 + 1, 2 + 2)，最外层是一个值构造器，(,)</p>

<p>\x -> 2 + 2，最外层是一个lambda抽象，</p>

<p>&lsquo;h&rsquo; : (&ldquo;e&rdquo; ++ &ldquo;llo&rdquo;)，最外层是一个值构造器，(:)</p>

<p><br/></p>

<p>以下表达式不是WHNF：</p>

<p>1 + 2，最外层是加法函数调用，(+)</p>

<p>(\x -> x + 1) 2，最外层是一个匿名函数调用</p>

<p>&ldquo;he&rdquo; ++ &ldquo;llo"，最外层是列表的连接函数调用，(++)</p>

<p><br/></p>

<p>因此，</p>

<p>表达式(1 + 1, 2 + 2)会按需首先求值为(thunk1,thunk2),</p>

<p>如果还需要thunk1的值，thunk1会求值为2。</p>

<p><br/></p>

<p>例如：</p>

<p>testFn1 _ = 1</p>

<p>testFn2 (<em>, </em>) = 2</p>

<p>tettFn3 (u, _) = 3</p>

<p>这3个函数会导致表达式(1 + 1, 2 + 2)进行<strong>不同层次</strong>的求值。</p>

<p><br/></p>

<h2><strong>seq</strong></h2>

<p>为了控制求值程度，</p>

<p>GHC内置了seq函数。</p>

<p><br/></p>

<p>> :t seq</p>

<p>> seq :: a -> b -> b</p>

<p><br/></p>

<p>它表示，<strong>在结果求值为WHNF之前</strong>，</p>

<p><strong>会先将seq的第一个参数求值为WHNF</strong>。</p>

<p><br/></p>

<p>例如：</p>

<p>u = 1</p>

<p>v = (u, u)</p>

<p><br/></p>

<p>x = 1</p>

<p>y = seq x (x, x)</p>

<p><br/></p>

<p>> :sprint u</p>

<p>> u = _</p>

<p>> :sprint v</p>

<p>> v = _</p>

<p><br/></p>

<p>> :sprint x</p>

<p>> x = _</p>

<p>> :sprint y</p>

<p>> y = _</p>

<p><br/></p>

<p>我们定义一个函数，用来把参数求值WHNF，</p>

<p>> let whnf (<em>, </em>) = ()</p>

<p><br/></p>

<p>则，</p>

<p>> whnf v</p>

<p>> ()</p>

<p>> whnf y</p>

<p>> ()</p>

<p><br/></p>

<p>> :sprint u</p>

<p>> u = _</p>

<p>> :sprint v</p>

<p>> v = (<em>, </em>)</p>

<p><br/></p>

<p>> :sprint x</p>

<p>> x = 1</p>

<p>> :sprint y</p>

<p>> y = (1, 1)</p>

<p><br/></p>

<p>使用seq控制求值深度，</p>

<p>可以防止创建过多的thunk。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>当我们在REPL中输入一个表达式时，</p>

<p>实际上调用了print函数，</p>

<p>它会对表达式完全求值。</p>

<p><br/></p>

<p>因此，表达式求值的层次问题，</p>

<p><strong>是很难从REPL中看出来的</strong>。</p>

<p><br/></p>

<p>另一方面，WHNF将求值过程分成了一系列节点，</p>

<p>能清晰的刻画求值程度，</p>

<p>这可能是我们学习Haskell入门的起点吧。</p>

<p><br/></p>

<p>参考：</p>

<p><a href="">Haskell/Denotational semantics</a></p>

<p><a href="https://en.wikibooks.org/wiki/Haskell/Laziness">Haskell/Laziness</a></p>

<p><a href="http://stackoverflow.com/questions/6872898/haskell-what-is-weak-head-normal-form">Haskell: What is Weak Head Normal Form?</a></p>

<p><a href="http://book.douban.com/subject/24294415/">Parallel and Concurrent Programming in Haskell</a></p>

<p><a href="https://hackhands.com/lazy-evaluation-works-haskell/">How Lazy Evaluation Works in Haskell</a></p>

<p><a href="http://www.vex.net/~trebla/haskell/lazy.xhtml">Lazy Evaluation of Haskell</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[不动点组合子与匿名递归函数]]></title>
    <link href="https://thzt.github.io/blog/2015/06/10/fixed-point/"/>
    <updated>2015-06-10T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/06/10/fixed-point</id>
    <content type="html"><![CDATA[<p>在漫长的编程学习过程中，</p>

<p>你可能会不经意间的，</p>

<p>知道了<strong>Y组合子</strong>。</p>

<p><br/></p>

<p>它的内部结构极其诡异，</p>

<p>但是它又如此的让你魂牵梦萦，</p>

<p>让你茶饭不思，</p>

<p>为伊消得人憔悴。</p>

<p><br/></p>

<p>这时候，<strong>数学基础</strong>是很重要的，</p>

<p>概念的差距，产生了无法逾越的鸿沟。</p>

<p>我们还是认真的从头开始吧。</p>

<p><br/></p>

<h2><strong>lambda calculus</strong></h2>

<p>lambda calculus简称LC，</p>

<p>它是一个形式系统，</p>

<p>用来研究函数的组合和应用。</p>

<p><br/></p>

<p>LC的研究对象称为<strong>λ项</strong>，</p>

<p>它是这样定义的，</p>

<p>λ项 = 变量</p>

<p>λ项 = λ项 λ项</p>

<p>λ项 = λ变量.λ项</p>

<p><br/></p>

<p>例如：</p>

<p>((λy.y)(λx.(xy)))</p>

<p>(x(λx.(λx.x)))</p>

<p>都是合法的λ项。</p>

<p><br/></p>

<p>我们用小写字母x，y，z表示变量，</p>

<p>大写字母M，N，P，Q表示λ项。</p>

<p><br/></p>

<p>λ项是左结合的，</p>

<p>MNPQ ≡ (((MN)P)Q)，</p>

<p><br/></p>

<p>λx.PQ ≡ (λx.(PQ))</p>

<p>λx尽可能多的向右结合。</p>

<p><br/></p>

<p>其中，“≡”表示语法上相等。</p>

<p><br/></p>

<h2><strong>替换规则</strong></h2>

<p>[N/x]M</p>

<p>表示把M中所有的x替换成N。</p>

<p><br/></p>

<h2><strong>α转换</strong></h2>

<p>α转换说的是，</p>

<p>可以将λx.PQ中的x改为其他变量y，</p>

<p>只需要同时将PQ中的自由变量x改为y即可。</p>

<p><br/></p>

<p>α转换定义了一个等价关系，</p>

<p>称为α等价。</p>

<p><br/></p>

<p>注：</p>

<p>这里y不能和PQ中的同名变量y冲突。</p>

<p><br/></p>

<p>α转换相当于<strong>变量更名</strong>。</p>

<p><br/></p>

<h2><strong>β归约</strong></h2>

<p>β归约相当于<strong>函数调用</strong>。</p>

<p><br/></p>

<p>(λx.M)N -> [N/x]M</p>

<p>即，对(λx.M)N进行β归约，</p>

<p>相当于把M中的变量x替换成N。</p>

<p><br/></p>

<p>一个<strong>β范式</strong>（weak normal form），</p>

<p>是不能再进行β归约的λ项。</p>

<p><br/></p>

<h2><strong>Church–Rosser定理</strong></h2>

<p>如果λ项P能β归约为M，即P->M，</p>

<p>也能β归约为N，P->N，</p>

<p>则存在λ项T，满足，</p>

<p>M->T且N->T。</p>

<p><br/></p>

<p>它表示了λ项β归约的<strong>汇聚性</strong>。</p>

<p>而且，λ项在α等价的条件下，至多存在一个β范式。</p>

<p><br/></p>

<h2><strong>Combinator logic</strong></h2>

<p>Combinator logic简称为CL，</p>

<p>它是一个形式系统，</p>

<p>与lambda calculus具有同样的计算能力。</p>

<p><br/></p>

<p>CL研究了<strong>CL项</strong>的演算规则，</p>

<p>一个合法的CL项，由以下条件递归定义，</p>

<p>CL项 = 变量 | 基本组合子</p>

<p>CL项 = CL项 CL项</p>

<p><br/></p>

<p>例如：</p>

<p>((S(KS))K)</p>

<p>((S(Kx))((SY)K))</p>

<p>都是合法的CL项。</p>

<p><br/></p>

<p>我们用小写字母x，y，z表示变量，</p>

<p>大写字母X，Y，Z表示CL项。</p>

<p><br/></p>

<p>CL项是左结合的，</p>

<p>UVWX ≡ (((UV)W)X)，</p>

<p>其中，“≡”表示语法上相等。</p>

<p><br/></p>

<h2><strong>替换规则</strong></h2>

<p>[U/x]Y</p>

<p>表示把Y中所有的x替换成U。</p>

<p><br/></p>

<p>例如：</p>

<p>[(SK)/x](yxx) ≡ y(SK)(SK)</p>

<p><br/></p>

<h2><strong>弱归约（Weak reduction）</strong></h2>

<p>以下形式的CL项可以进行弱归约，</p>

<p>IX -> X</p>

<p>KXY -> X</p>

<p>SXYZ -> XZ(YZ)</p>

<p><br/></p>

<p>如果进行这些变换可以使U变成U'，</p>

<p>就称CL项U可以弱归约为U'。</p>

<p><br/></p>

<p>一个<strong>弱范式</strong>（weak normal form），</p>

<p>是不能再进行弱归约的CL项。</p>

<p><br/></p>

<h2><strong>Church–Rosser定理</strong></h2>

<p>与lambda calculus一样，</p>

<p>对于CL，也有类似的定理，</p>

<p><br/></p>

<p>如果CL项U可以弱归约为X，即U->X，</p>

<p>也可以弱归约为Y，即U->Y，</p>

<p>则存在CL项T，满足，</p>

<p>X->T且Y->T。</p>

<p><br/></p>

<p>这表示了CL项弱归约的<strong>汇聚性</strong>。</p>

<p>而且，CL项至多存在一个弱范式。</p>

<p><br/></p>

<h2><strong>CL项的抽象</strong></h2>

<p>为了和lambda演算进行对比，</p>

<p>我们定义CL项的抽象，</p>

<p>(a) [x].M ≡ KM，如果x不是M中的自由变量</p>

<p>(b) [x].x ≡ I</p>

<p>&copy; [x].Ux ≡ U，如果x不是U中的自由变量</p>

<p>(d) [x].UV ≡ S([x].U)([x].V)，如果不满足(a)或&copy;</p>

<p><br/></p>

<p>可以证明，</p>

<p>([x].M)N可以弱归约为[N/x]M。</p>

<p><br/></p>

<p>这里，我们只是用原始的CL项来定义了CL项的抽象，</p>

<p>[x]并不是CL语法的一部分，</p>

<p>而对于lambda calculus中的λ项λx.xy，</p>

<p>λx是λ项的一部分。</p>

<p><br/></p>

<h2><strong>LC和CL的相似性</strong></h2>

<p>经过以上学习，</p>

<p>我们发现，</p>

<p>LC中的<strong>α等价</strong>，对应着CL中的<strong>语法等价</strong>，</p>

<p>LC中的<strong>β归约</strong>，对应着CL中的<strong>弱归约</strong>，</p>

<p>LC中的<strong>λx</strong>，对应着CL中的<strong>[x]</strong>。</p>

<p><br/></p>

<p>我们就可以统一的，</p>

<p>用LC中的符号来说明问题了。</p>

<p><br/></p>

<h2><strong>组合子</strong></h2>

<p>LC中的<strong>组合子</strong>，</p>

<p>表示一个闭项（closed pure term），</p>

<p>它不是一个原子，也不包含自由变量。</p>

<p><br/></p>

<p>例如：</p>

<p>λxyz.x(yz)</p>

<p>λxy.x</p>

<p><br/></p>

<p>CL中的<strong>组合子</strong>，</p>

<p>只有3个，I，K，S。</p>

<p><br/></p>

<p>在LC中，可以这样表示，</p>

<p>I ≡ λx.x</p>

<p>K ≡ λxy.x</p>

<p>S ≡ λxyz.xz(yz)</p>

<p><br/></p>

<h2><strong>不动点定理</strong></h2>

<p>在LC和CL中，</p>

<p><strong>对于任意x，存在它的不动点Yx，满足，</strong></p>

<p><strong>Yx -> x(Yx)</strong></p>

<p><br/></p>

<p>其中，</p>

<p>“->”表示LC中的β归约，</p>

<p>或CL中的弱归约。</p>

<p><br/></p>

<p><strong>证明：</strong></p>

<p>取Y ≡ UU</p>

<p>U ≡ λux.x(uux)</p>

<p><br/></p>

<p>Yx -></p>

<p>UUx -></p>

<p>(λux.x(uux))Ux -></p>

<p>(λx.x(UUx))x -></p>

<p>x(UUx) -></p>

<p>x(Yx)</p>

<p><br/></p>

<h2><strong>不动点组合子</strong></h2>

<p>不动点组合子并不是唯一的，</p>

<p><br/></p>

<p>存在不止一个Y，</p>

<p>使得对于任意x，Yx -> x(Yx)。</p>

<p><br/></p>

<p>例如：</p>

<p><strong>Turing组合子</strong></p>

<p>Y ≡ UU，U ≡ λux.x(uux)</p>

<p><br/></p>

<p><strong>Curry-Ros组合子</strong></p>

<p>Y ≡ λx.VV，V ≡ λy.x(yy)</p>

<p><br/></p>

<h2><strong>不动点定理的用法</strong></h2>

<p>根据不动点定理，</p>

<p>我们能得到任意LC项或CL项的不动点，</p>

<p>所以，<strong>不动点方程总是有解的</strong>。</p>

<p><br/></p>

<p>例如：</p>

<p>给定方程，x = M，M中可能包含x，</p>

<p>我们可以将它转换成不动点方程，</p>

<p>x = (λx.M)x，</p>

<p>解为：x = Y(λx.M) = Y(λt.[t/x]M)</p>

<p>它<strong>消除了M中的x</strong>。</p>

<p><br/></p>

<p>例如：M ≡ yxz</p>

<p>x = Y(λx.M) = Y(λx.yxz) = Y(λt.ytz)，</p>

<p>等式右边就不包含自由变量x了。</p>

<p><br/></p>

<p>所以，形如x = M的方程，</p>

<p>我们可以使用Y来消除M中的x。</p>

<p><br/></p>

<p>这也表明可以不依赖于副作用，</p>

<p>用Y来定义<strong>匿名递归函数</strong>。</p>

<p><br/></p>

<h2><strong>用Y组合子解递归方程</strong></h2>

<p>Haskell中的Turing Y组合子定义如下：</p>

<p><strong>import Unsafe.Coerce</strong></p>

<p>u = \u x -> x $ u <strong>(unsafeCoerce</strong> u<strong>)</strong> x</p>

<p>y = u u</p>

<p><br/></p>

<p>斐波那契函数fib的递归定义，</p>

<p>fib = \n -> if n&lt;2 then 1 else (n*) $ fib $ n-1</p>

<p><br/></p>

<p>为了<strong>消除等式右边fib</strong>，</p>

<p>我们把它转换成不动点方程，</p>

<p>fib = (\f -> \n -> if n&lt;2 then 1 else (n*) $ f $ n-1) fib</p>

<p>用Y组合子求解，得到了一个匿名的递归函数，</p>

<p>fib = y $ <strong>\f -></strong> \n -> if n&lt;2 then 1 else (n*) $ <strong>f</strong> $ n-1</p>

<p><br/></p>

<p>验证一下运行结果，</p>

<p>fib 5</p>

<p>=> 120</p>

<p><br/></p>

<h2><strong>不动点存在性的疑问</strong></h2>

<p>方程解的性质是由方程决定的，</p>

<p><strong>解法无法改变解的性质</strong>。</p>

<p><br/></p>

<p>例如：</p>

<p>a = undefined = (\a -> undefined) a</p>

<p>解为：a = y $ \a -> undefined <strong>= undefined</strong></p>

<p><br/></p>

<p>add = \n -> add n+1</p>

<p>这个一个无限递归函数。</p>

<p>转换为不动点方程的形式，</p>

<p>add = (\f -> \n -> f n+1) add</p>

<p>解为：add = y $ (\f -> \n -> f n+1)</p>

<p>这个add<strong>仍然是</strong>一个无限递归函数。</p>

<p><br/></p>

<h2><strong>初等函数的不动点</strong></h2>

<p>另外，对于初等函数的不动点方程，</p>

<p>x = f(x)</p>

<p>程序中直接写成x = f(x)会<strong>导致无限递归</strong>，</p>

<p>因为初等函数方程给出来的是<strong>约束</strong>，</p>

<p>而不是<strong>计算过程</strong>。</p>

<p><br/></p>

<p>例如：</p>

<p>求解f(x) = 2x的不动点，</p>

<p><strong>直接写x = 2*x是一个无限的递归</strong>，并不能解出x = 0来，</p>

<p>因此，x = 2*x实际表示的是一个无限递归的计算过程。</p>

<p><br/></p>

<p>然而，<strong>仍然</strong>会存在满足这个方程的解。</p>

<p>不动点方程形式如下，</p>

<p>x = (\x -> 2*x) x</p>

<p>解为：x = y $ \x -> 2*x</p>

<p>确实可以使等式成立，</p>

<p>但它<strong>同样表示</strong>的是一个无限递归的计算过程。</p>

<p><br/></p>

<p>f(x) = 2x的不动点方程，对应的“计算过程”<strong>应该是</strong>，</p>

<p>x = 0</p>

<p>不动点方程的形式如下，</p>

<p>x = (\x -> 0) x</p>

<p>解为：x = y $ \x -> 0 <strong>= 0</strong></p>

<p><br/></p>

<p>因此，</p>

<p>初等函数的不动点，</p>

<p>与LC或CL的不动点是两个不同的场景，</p>

<p>初等函数方程是一种<strong>约束规则</strong>，</p>

<p>LC或CL的等式是一种<strong>推导规则</strong>。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>不动点问题，</p>

<p>一直是我的心结。</p>

<p>只可惜功力不够，总是想不明白。</p>

<p><br/></p>

<p>本文只是对最近学习的总结，</p>

<p>肯定有<strong>不严谨</strong>的地方，</p>

<p>只当做以后继续学习的起点吧。</p>

<p><br/></p>

<p>参考：《Lambda-Calculus and Combinators》</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Haskell的纯函数性]]></title>
    <link href="https://thzt.github.io/blog/2015/03/27/purity/"/>
    <updated>2015-03-27T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/03/27/purity</id>
    <content type="html"><![CDATA[<p>表达式是在环境中求值的。</p>

<p>如果允许表达式改变环境，</p>

<p>那么，其他表达式的求值结果，就是不可预料的。</p>

<p><br/></p>

<p>环境，是专业术语，也可称为执行环境，</p>

<p>里面保存的是，变量和值的绑定关系。</p>

<p><br/></p>

<p>Haskell是一门纯函数式语言，</p>

<p>并不是说，函数的每次求值结果都相同。</p>

<p>而是说，<strong>任何函数都不会修改它的执行环境</strong>。</p>

<p><br/></p>

<p>例如，对于从屏幕上读取字符的函数，</p>

<p>每次调用，并不一定会返回相同的值。</p>

<p>但是，执行后，它确实不会影响环境中的绑定关系。</p>

<p><br/></p>

<p>因此，输入输出操作，也是纯函数，</p>

<p>理解执行环境和现实世界的区别，是关键。</p>

<p><br/></p>

<h2><strong>IO</strong></h2>

<p>Haskell是一门静态强类型的语言。</p>

<p>任何表达式在编译前类型都是确定的。</p>

<p><br/></p>

<p>输入输出与IO a类型有关。</p>

<p>其中，IO是类型构造器，:k IO = * -> *</p>

<p>因此，IO a才是一个具体类型。</p>

<p><br/></p>

<p>IO是如何定义的呢？</p>

<p>type IO a = World -> (a, World)</p>

<p>World类型的值表示现实世界的状态。</p>

<p><br/></p>

<p>IO a类型的值是一个函数，它接受现实世界的当前状态作为参数，</p>

<p>返回一个元组，这个元组由类型a的值和对现实世界改变后的状态构成。</p>

<p><br/></p>

<p>由于，我们并不需要手动传递World类型的值作为参数来调用，</p>

<p>所以，应该<strong>把IO a类型的值理解为一个惰性求值的表达式</strong>，</p>

<p>对该表达式按需求值，得到一个a类型的值。</p>

<p><br/></p>

<p>IO a类型的表达式，称为<strong>action</strong>。</p>

<p>IO a类型的action中，惰性包含了一个a类型的值。</p>

<p><br/></p>

<p>例如：</p>

<p>getChar :: IO Char</p>

<p>求值getChar表达式，就会得到一个Char类型的值。</p>

<p><br/></p>

<p>例如：</p>

<p>IO ( )</p>

<p>其中，( )表示空元组类型，该类型只有一个值，空元组( )。</p>

<p>“( )”既可以表示类型，又可以表示值，取决于它出现的上下文。</p>

<p>另外，Haskell中习惯将空元组看做无用数据。</p>

<p><br/></p>

<p>在IO ( )中，( )是作为IO类型构造器的参数出现的，表示空元组类型，</p>

<p>所以说，IO ( )类型的action中，惰性包含了一个空元组值。</p>

<p><br/></p>

<p>例如：</p>

<p>putStrLn :: String -> IO ( )</p>

<p>putStrLn是一个函数，</p>

<p>它接受String类型的值作为参数，</p>

<p>返回一个IO ( )类型的action。</p>

<p><br/></p>

<h2><strong>do</strong></h2>

<p>main :: IO ( )</p>

<p>main = do</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;putStrLn &ldquo;Please input: &rdquo;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;inpStr &lt;- getLine</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;putStrLn $ &ldquo;Hello &rdquo; ++ inpStr</p>

<p><br/></p>

<p>以上程序定义了main函数，是一个IO ( )类型的action。</p>

<p><br/></p>

<p>do关键字，是Haskell中的一种写法，</p>

<p>用来表示顺序执行。</p>

<p><br/></p>

<p>其中，</p>

<p>putStrLn :: String -> IO ( )</p>

<p>getLine :: IO String</p>

<p><br/></p>

<p>putStrLn $ &ldquo;Hello &rdquo; ++ inpStr</p>

<p>= putStrLn ( &ldquo;Hello &rdquo; ++ inpStr )</p>

<p><br/></p>

<p>因此，</p>

<p>putStrLn &ldquo;Please input: &rdquo; :: IO ( )，在屏幕上输出字符串“Please input: ”，</p>

<p>inpStr &lt;- getLine，求值惰性表达式getLine，<strong>把action里面包含的值拿出来</strong>，绑定到inpStr上。</p>

<p>putStrLn $ &ldquo;Hello &rdquo; ++ inpStr，在屏幕上输出字符串"Hello &ldquo;与变量inpStr连接后的结果。</p>

<p><br/></p>

<p>IO操作，每次执行的效果并不相同，</p>

<p>但<strong>仍然都是纯函数</strong>，</p>

<p>在于它们不会修改执行环境中的变量绑定关系。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>很多人指出，Haskell使用了Monad将纯函数与不纯函数分离开，</p>

<p>这种说法，其实是为了解释给不熟悉的人看的。</p>

<p>事实上，<strong>Haskell中的任何函数都是纯函数</strong>。</p>

<p><br/></p>

<p>类似的，</p>

<p>Haskell语言中Bug的数量可以控制到非常少，</p>

<p>并不是因为通过Monad将IO和其他函数分离开，</p>

<p>而是因为任何函数都不能改变环境中变量的绑定关系，</p>

<p>即，函数的纯粹性。</p>

<p><br/></p>

<p>此外，Monad，Applicative和Functor这些类型类，</p>

<p>提高了语言的抽象程度，让复杂度更可控，</p>

<p>我想，这才是Bug数量少的真正原因吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[函数>>=的多态性]]></title>
    <link href="https://thzt.github.io/blog/2015/03/18/polymorphism-of-chain-function/"/>
    <updated>2015-03-18T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2015/03/18/polymorphism-of-chain-function</id>
    <content type="html"><![CDATA[<p>Haskell中一些函数可以作用在多种类型上。</p>

<p>例如：</p>

<p>ghci> length [1, 2]</p>

<p>2</p>

<p>length :: [Int] -> Int</p>

<p><br/></p>

<p>ghci> length [&ldquo;a&rdquo;, &ldquo;b&rdquo;, &ldquo;c&rdquo;]</p>

<p>3</p>

<p>length :: [String] -> Int</p>

<p><br/></p>

<p>我们看length的类型，</p>

<p>length :: [a] -> Int</p>

<p>它类型签名中，包含类型变量，类型变量可以具体化为任意类型。</p>

<p><br/></p>

<p>像这样的函数，称为多态函数。</p>

<p><br/></p>

<h2><strong>函数>>=</strong></h2>

<p>函数>>=定义在Monad类型类中，</p>

<p>class Monad m where</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(>>=) :: m a -> (a -> m b) -> m b</p>

<p><br/></p>

<p>其中，m是Monad类型类的实例类型，它的kind是<em> -> </em>，</p>

<p>:k m = * -> *</p>

<p>类型m a是一个具体类型，该类型的值称为monad value。</p>

<p><br/></p>

<p>我们看到，在m确定的情况下，>>=的类型签名中仍然包含类型变量。</p>

<p>因此，对Monad类型类的某个实例来说，</p>

<p>>>=可以操作相同m类型但是不同a类型的monad value :: m a。</p>

<p><br/></p>

<h2><strong>IO monad</strong></h2>

<p>以Monad类型类的实例IO为例，对于IO来说，IO monad value称为IO action。</p>

<p>main = do</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;putStrLn &ldquo;Please input: &rdquo;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;inpStr &lt;- getLine</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;putStrLn $ &ldquo;Hello &rdquo; ++ inpStr</p>

<p><br/></p>

<p>其中，</p>

<p>putStrLn :: String -> IO ( )</p>

<p>getLine :: IO String</p>

<p><br/></p>

<p>我们来分析一下这3个IO action的类型，</p>

<p>putStrLn &ldquo;Please input: &rdquo; :: IO ( )</p>

<p>getLine :: IO String</p>

<p>putStrLn $ &ldquo;Hello &rdquo; ++ inpStr :: IO ( )</p>

<p><br/></p>

<p>它们的具体类型都是m a，</p>

<p>m相同，m = IO。而a不同，分别是( )，String，( )。</p>

<p><br/></p>

<p>在do notation中，如果某一行我们没有使用&lt;-为monad value绑定值，</p>

<p>就相当于使用了函数>>，表示不需要这个绑定值。</p>

<p>(>>) :: x >> y = x >>= \ _ -> y</p>

<p><br/></p>

<p>这样的话，我们就可以将main函数还原成>>和>>=的串联形式了，</p>

<p>putStrLn &ldquo;Please input: &rdquo; >> getLine >>= \inpStr -> putStrLn $ &ldquo;Hello &rdquo; ++ inpStr</p>

<p>= putStrLn &ldquo;Please input: &rdquo; >>= \ _ -> getLine >>= \inpStr -> putStrLn $ &ldquo;Hello &rdquo; ++ inpStr</p>

<p>= putStrLn &ldquo;Please input: &rdquo; >>= ( \ _ -> getLine >>= ( \inpStr -> putStrLn $ &ldquo;Hello &rdquo; ++ inpStr ) )</p>

<p><br/></p>

<h2><strong>类型不同的>>=同时出现</strong></h2>

<p>对于第一个>>=，我们能推断出它的大概类型，</p>

<p>>>= :: IO ( ) -> (( ) -> IO ?) -> IO ?</p>

<p>其中“?”表示尚未确定的类型。</p>

<p><br/></p>

<p>而第二个>>=的类型，可以完全确定下来。</p>

<p>getLine >>= \inpStr -> putStrLn $ &ldquo;Hello &rdquo; ++ inpStr</p>

<p>>>= :: IO String -> (String -> IO ( )) -> IO ( )</p>

<p><br/></p>

<p>那么，第一个>>=的类型也就可以完全确定下来了，</p>

<p>>>= :: IO ( ) -> (( ) -> IO ( )) -> IO ( )</p>

<p><br/></p>

<p>由此可见，</p>

<p>第一个>>= :: IO ( ) -> (( ) -> IO ( )) -> IO ( )</p>

<p>第二个>>= :: IO String -> (String -> IO ( )) -> IO ( )</p>

<p>两个>>=的类型不同，它们同时出现了。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>do notation是>>和>>=串联形式的语法糖，IO action是 IO monad value，因此可以使用它。</p>

<p>认为do notation中每行的monad value类型必须相同，是不正确的。</p>

<p>事实上，他们的类型是m a，m是相同的，而a可以不同。</p>

<p><br/></p>

<p>相似的，Functor和Applicative类型类也定义了一些多态函数。</p>

<p><br/></p>

<p>此外，对于IO类型，《Programming in Haskell》P88说的最清楚</p>

<p>type IO a = World -> (a, World)</p>

<p><br/></p>

<p>World类型的值表示环境的当前状态。</p>

<p>World -> (a, World)类型的值是一个函数，</p>

<p>它接受环境状态作为参数，返回一个a类型的值，并影响了环境状态。</p>
]]></content>
  </entry>
  
</feed>
