<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Logic | 何幻]]></title>
  <link href="https://thzt.github.io/blog/categories/logic/atom.xml" rel="self"/>
  <link href="https://thzt.github.io/"/>
  <updated>2016-07-25T09:04:08+08:00</updated>
  <id>https://thzt.github.io/</id>
  <author>
    <name><![CDATA[thzt]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[可计算性理论名词释义]]></title>
    <link href="https://thzt.github.io/blog/2016/07/23/computability/"/>
    <updated>2016-07-23T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/07/23/computability</id>
    <content type="html"><![CDATA[<script src="https://thzt.github.io/thirdpart/jQuery/jquery-1.11.1.js"></script>


<p><link href="https://thzt.github.io/thirdpart/KaTeX/katex.min.css" rel="stylesheet"/></p>

<script src="https://thzt.github.io/thirdpart/KaTeX/katex.min.js"></script>


<script src="https://thzt.github.io/javascripts/katex.js"></script>


<h2><strong>部分数论函数</strong></h2>

<p><strong>二元关系</strong></p>

<p>集合<span data-katex="S"></span>和<span data-katex="T"></span>，</p>

<p><span data-katex="S\times T"></span>的元素<span data-katex="(a,b)"></span>称为有序对，</p>

<p><span data-katex="S\times T"></span>的子集称为从<span data-katex="S"></span>到<span data-katex="T"></span>的二元关系，</p>

<p>从<span data-katex="S"></span>到<span data-katex="S"></span>的二元关系，称为<span data-katex="S"></span>上的二元关系。</p>

<p><br/></p>

<p><strong>定义域和值域</strong></p>

<p>设<span data-katex="R"></span>是从<span data-katex="S"></span>到<span data-katex="T"></span>的二元关系，</p>

<p>则称<span data-katex="R"></span>的定义域为<span data-katex="dom\ R=\{a|\exists b\ (a,b)\in R\}"></span>，</p>

<p><span data-katex="R"></span>的值域为<span data-katex="ran\ R=\{b|\exists a\ (a,b)\in R\}"></span>。</p>

<p><br/></p>

<p><strong>象</strong></p>

<p><span data-katex="A\subseteq S"></span>，则称<span data-katex="A"></span>在<span data-katex="R"></span>下的象为，</p>

<p><span data-katex="R(A)=\{b|\exists a\ (a\in A \wedge (a,b)\in R)\}"></span>，</p>

<p>特别的，如果<span data-katex="a\in A"></span>，那么把<span data-katex="\{a\}"></span>在<span data-katex="R"></span>下的象简记为<span data-katex="a"></span>在<span data-katex="R"></span>下的象，记为<span data-katex="R(a)"></span>。</p>

<p>即，<span data-katex="R(a)=\{b|(a,b)\in R\}"></span></p>

<p><br/></p>

<p><strong>部分函数</strong></p>

<p>如果<span data-katex="f"></span>是从<span data-katex="S"></span>到<span data-katex="T"></span>的二元关系，且<span data-katex="\forall a\in S"></span>，<span data-katex="f(a)=\varnothing"></span>或<span data-katex="\{b\}"></span>，</p>

<p>则称<span data-katex="f"></span>是从<span data-katex="S"></span>到<span data-katex="T"></span>的部分函数，或<span data-katex="S"></span>上的部分函数。</p>

<p>若<span data-katex="f(a)=\{b\}"></span>，则称<span data-katex="f(a)"></span>有定义，记为<span data-katex="f(a)\downarrow"></span>，</p>

<p><span data-katex="b"></span>称为<span data-katex="f"></span>在<span data-katex="a"></span>点的函数值，记为<span data-katex="f(a)=b"></span>，</p>

<p>若<span data-katex="f(a)=\varnothing"></span>，则称<span data-katex="f(a)"></span>无定义，记为<span data-katex="f(a)\uparrow"></span>。</p>

<p><br/></p>

<p><strong>全函数</strong></p>

<p>如果<span data-katex="\forall a\in S"></span>都有<span data-katex="f(a)\downarrow"></span>，即<span data-katex="dom\ f=S"></span>，则称<span data-katex="f"></span>是<span data-katex="S"></span>上的全函数，</p>

<p>此时，可以记为<span data-katex="f:S\rightarrow T"></span>。</p>

<p><br/></p>

<p><strong><span data-katex="n"></span>元部分函数</strong></p>

<p>设<span data-katex="f"></span>是笛卡尔积<span data-katex="S_1\times S_2\times \cdots \times S_n"></span>上的部分函数，</p>

<p>则通常把<span data-katex="f((a_1,a_2,\cdots ,a_n))"></span>，简记为<span data-katex="f(a_1,a_2,\cdots ,a_n)"></span>。</p>

<p><br/></p>

<p>集合<span data-katex="S^n=S\times S\times \cdots \times S"></span>上的部分函数，称为<span data-katex="S"></span>上的<span data-katex="n"></span>元部分函数。</p>

<p>自然数集<span data-katex="N=\{0,1,2,\cdots \}"></span>，从<span data-katex="N^n"></span>到<span data-katex="N"></span>的部分函数，称为<span data-katex="n"></span>元部分数论函数。</p>

<p>下文中提到的函数，默认为数论函数。</p>

<p><br/></p>

<p><strong>字函数</strong></p>

<p>字母表是一个非空有穷集合，</p>

<p>设<span data-katex="A"></span>是一个字母表，<span data-katex="A"></span>中元素的有穷序列<span data-katex="w=(a_1,a_2,\cdots ,a_m)"></span>称为<span data-katex="A"></span>上的字符串或字，</p>

<p>简记为<span data-katex="w=a_1a_2\cdots a_m"></span>。</p>

<p><span data-katex="w"></span>中符号的个数，称为字符串的长度，记为<span data-katex="|w|"></span>。</p>

<p>我们用<span data-katex="\epsilon"></span>表示空串，它不包含任何符号，是唯一的长度为<span data-katex="0"></span>的字符串。</p>

<p><br/></p>

<p><span data-katex="A"></span>上字符串的全体，记为<span data-katex="A^*"></span>。</p>

<p>设<span data-katex="u,v\in A^*"></span>，把<span data-katex="v"></span>连接在<span data-katex="u"></span>后面得到的字符串记为<span data-katex="uv"></span>。</p>

<p><br/></p>

<p>设<span data-katex="u\in A^*"></span>，规定，<span data-katex="u^0=\epsilon"></span>，<span data-katex="u^{n+1}=u^n u\ ,n\in N"></span>，</p>

<p>当<span data-katex="n>0"></span>时，<span data-katex="u^n"></span>等于<span data-katex="n"></span>个<span data-katex="u"></span>连接在一起。</p>

<p><br/></p>

<p><span data-katex="(A^*)^n"></span>到<span data-katex="A^*"></span>的部分函数，称为<span data-katex="A"></span>上的<span data-katex="n"></span>元部分字函数。</p>

<p><br/></p>

<h2><strong>程序设计语言<span data-katex="\mathscr{S}"></span></strong></h2>

<p><strong>变量</strong></p>

<p>语言<span data-katex="\mathscr{S}"></span>使用三种变量，</p>

<p>输入变量<span data-katex="X_1,X_2,\cdots"></span>，输出变量<span data-katex="Y"></span>，中间变量<span data-katex="Z_1,Z_2,\cdots"></span>，</p>

<p>变量可以取任何自然数值<span data-katex="n\in N"></span>。</p>

<p>语言还可以使用标号<span data-katex="A_1,A_2,\cdots"></span>。</p>

<p>当下标为<span data-katex="1"></span>时，可以略去。例如，<span data-katex="X_1"></span>和<span data-katex="X"></span>表示同一个变量。</p>

<p><br/></p>

<p><strong>语句</strong></p>

<p>语言<span data-katex="\mathscr{S}"></span>有三种类型的语句，</p>

<p>（1）增量语句<span data-katex="V\leftarrow V+1"></span>，表示变量V的值加<span data-katex="1"></span></p>

<p>（2）减量语句<span data-katex="V\leftarrow V-1"></span>，若变量<span data-katex="V"></span>的当前值为<span data-katex="0"></span>，则<span data-katex="V"></span>的值保持不变，否则<span data-katex="V"></span>的值减<span data-katex="1"></span>。</p>

<p>（3）条件转移语句<span data-katex="IF\ V\neq 0\ GOTO\ L"></span>，如果变量<span data-katex="V"></span>的值不等于<span data-katex="0"></span>，则下一步执行带标号<span data-katex="L"></span>的指令，否则顺序执行下一条指令。</p>

<p><br/></p>

<p><strong>执行</strong></p>

<p>开始执行程序时，中间变量和输出变量的值都为<span data-katex="0"></span>，</p>

<p>从第一条指令开始，一条一条的顺序执行，除非遇到条件转移语句，</p>

<p>当程序没有指令可执行时，计算结束，</p>

<p>此时<span data-katex="Y"></span>的值为程序的输出值。</p>

<p><br/></p>

<p>例如，</p>

<p><span data-katex="[A]\ X\leftarrow X-1"></span></p>

<p><span data-katex="\ \ \ \ Y\leftarrow Y+1"></span></p>

<p><span data-katex="\ \ \ \ IF\ X\neq 0\ GOTO\ A"></span></p>

<p>这里<span data-katex="A"></span>是第一条指令的标号，我们可以看到，这个程序计算的函数是，</p>

<p><span data-katex="f(x)=x,\ if\ x>0"></span></p>

<p><span data-katex="f(x)=1,\ else"></span></p>

<p><br/></p>

<p><strong>状态</strong></p>

<p>设<span data-katex="\sigma"></span>是形如等式<span data-katex="V=m"></span>的有穷集合，其中<span data-katex="V"></span>是一个变量，<span data-katex="m"></span>是一个数。</p>

<p>如果，</p>

<p>（1）对于每一个变量<span data-katex="V"></span>，<span data-katex="\sigma"></span>中至多含有一个等式<span data-katex="V=m"></span></p>

<p>（2）如果在程序<span data-katex="\mathscr{P}"></span>中出现变量<span data-katex="V"></span>，则<span data-katex="\sigma"></span>中必含有等式<span data-katex="V=m"></span></p>

<p>那么，称<span data-katex="\sigma"></span>是程序<span data-katex="\mathscr{P}"></span>的一个状态。</p>

<p><br/></p>

<p>状态描述程序在执行的某一步各个变量的值，</p>

<p>我们约定，如果<span data-katex="\sigma"></span>中不含关于<span data-katex="V"></span>的等式，则变量<span data-katex="V"></span>的值自动取<span data-katex="0"></span>。</p>

<p><br/></p>

<p><strong>快相</strong></p>

<p>程序的一个快相，是一个有序对<span data-katex="(i,\sigma )"></span>，</p>

<p>表示程序的当前状态为<span data-katex="\sigma"></span>，即将执行第<span data-katex="i"></span>条指令。</p>

<p><span data-katex="1\leqslant i \leqslant q"></span>，其中，<span data-katex="q"></span>是程序的长度，</p>

<p>如果<span data-katex="i=q+1"></span>，就表示程序结束，<span data-katex="(q+1,\sigma )"></span>称为程序的终点快相。</p>

<p><br/></p>

<p>除了输入变量外，所有变量值为0的状态称为初始状态，</p>

<p>如果<span data-katex="\sigma"></span>是初始状态，则称<span data-katex="(1,\sigma )"></span>是初始快相。</p>

<p><br/></p>

<p><strong>程序的计算</strong></p>

<p>设<span data-katex="s_1,s_2,\cdots"></span>是程序<span data-katex="\mathscr{P}"></span>的一个快相序列，长度为<span data-katex="k"></span>，</p>

<p>如果，</p>

<p>（1）<span data-katex="s_1"></span>是初始快相</p>

<p>（2）对于每一个<span data-katex="i(1\leqslant i<k)"></span>，<span data-katex="s_{i+1}"></span>是<span data-katex="s_i"></span>的后继</p>

<p>（3）当<span data-katex="k<\infty"></span>时，<span data-katex="s_k"></span>是终点快相</p>

<p>则称该序列是<span data-katex="\mathscr{P}"></span>的一个计算。</p>

<p><br/></p>

<h2><strong>函数的可计算性</strong></h2>

<p><strong>程序计算的函数</strong></p>

<p>设<span data-katex="\mathscr{P}"></span>是语言<span data-katex="\mathscr{S}"></span>的一个程序，<span data-katex="n"></span>是一个正整数，</p>

<p>称函数<span data-katex="\psi (x_1,x_2,\cdots ,x_n)"></span>为程序<span data-katex="\mathscr{P}"></span>计算的<span data-katex="n"></span>元部分函数，</p>

<p>如果，s_1"></span>是初始快相，其中输入变量为<span data-katex="X_1=x_1,X_2=x_2,\cdots ,X_n=x_n"></span>，输出变量为<span data-katex="Y"></span>，</p>

<p>（1）从<span data-katex="s_1"></span>开始的计算是有穷序列<span data-katex="s_1,s_2,\cdots ,s_k"></span>，则<span data-katex="\psi (x_1,x_2,\cdots ,x_n)"></span>等于<span data-katex="Y"></span>在<span data-katex="s_k"></span>中的值</p>

<p>（2）从<span data-katex="s_1"></span>开始的计算是无穷序列<span data-katex="s_1,s_2,\cdots"></span>，则<span data-katex="\psi (x_1,x_2,\cdots ,x_n)\uparrow"></span></p>

<p><br/></p>

<p><strong>部分可计算性与可计算性</strong></p>

<p>设<span data-katex="f(x_1,x_2,\cdots ,x_n)"></span>是一个部分函数，如果存在程序<span data-katex="\mathscr{P}"></span>计算<span data-katex="f"></span>，</p>

<p>则称<span data-katex="f"></span>是部分可计算的。</p>

<p><br/></p>

<p>如果一个函数，既是部分可计算的，又是全函数，则称这个函数是可计算的。</p>

<p><br/></p>

<p><strong>谓词的可计算性</strong></p>

<p>我们可以把谓词看作取值为<span data-katex="0"></span>或<span data-katex="1"></span>的全函数，</p>

<p>并把真值等同于<span data-katex="1"></span>，假值等同于<span data-katex="0"></span>。</p>

<p><br/></p>

<p>如果谓词<span data-katex="P(x_1,x_2,\cdots ,x_n)"></span>作为一个全函数是可计算的，</p>

<p>则称该谓词是可计算的。</p>

<p><br/></p>

<h2><strong>函数的递归性</strong></h2>

<p><strong>合成运算</strong></p>

<p>设<span data-katex="f"></span>是<span data-katex="k"></span>元部分函数，<span data-katex="g_1,g_2,\cdots ,g_k"></span>是<span data-katex="k"></span>个<span data-katex="n"></span>元部分递归函数，</p>

<p><span data-katex="h(x_1,\cdots ,x_n)=f(g_1(x_1,\cdots ,x_n),\cdots ,g_k(x_1,\cdots ,x_n))"></span></p>

<p>则称<span data-katex="h"></span>是由<span data-katex="f"></span>和<span data-katex="g_1,g_2,\cdots ,g_k"></span>，经过合成运算得到的。</p>

<p><br/></p>

<p>可证，如果<span data-katex="h"></span>是由（部分）可计算函数<span data-katex="f"></span>和<span data-katex="g_1,g_2,\cdots ,g_k"></span>合成得到的，</p>

<p>则<span data-katex="h"></span>也是（部分）可计算函数。</p>

<p><br/></p>

<p><strong>原始递归运算</strong></p>

<p>设<span data-katex="g"></span>是一个<span data-katex="2"></span>元全函数，<span data-katex="k"></span>是一个常数，</p>

<p><span data-katex="h(0)=k"></span></p>

<p><span data-katex="h(t+1)=g(t,h(t))"></span></p>

<p>则称<span data-katex="h"></span>是由<span data-katex="g"></span>经过原始递归运算得到的。</p>

<p><br/></p>

<p>可证，如果<span data-katex="g"></span>是可计算的，则<span data-katex="h"></span>是可计算的。</p>

<p><br/></p>

<p>设<span data-katex="f"></span>是一个<span data-katex="n"></span>元全函数，<span data-katex="g"></span>是<span data-katex="n+2"></span>元全函数，</p>

<p><span data-katex="h(x_1,\cdots ,x_n,0)=f(x_1,\cdots ,x_n)"></span></p>

<p><span data-katex="h(x_1,\cdots ,x_n,t+1)=g(t,h(x_1,\cdots ,x_n,t),x_1,\cdots ,x_n)"></span></p>

<p>则称<span data-katex="h"></span>是由<span data-katex="f"></span>和<span data-katex="g"></span>经过原始递归运算得到的。</p>

<p><br/></p>

<p>可证，如果<span data-katex="f"></span>和<span data-katex="g"></span>都是可计算的，则<span data-katex="h"></span>是可计算的。</p>

<p><br/></p>

<p><strong>原始递归函数类</strong></p>

<p>设初始函数包括，</p>

<p>（1）零函数<span data-katex="n(x)=0"></span></p>

<p>（2）后继函数<span data-katex="s(x)=x+1"></span></p>

<p>（3）投影函数<span data-katex="u^n_i(x_1,\cdots ,x_n)=x_i"></span>，<span data-katex="i\leqslant i\leqslant n"></span></p>

<p>则，由初始函数经过有限次合成运算和原始递归运算得到的函数，称为原始递归函数。</p>

<p><br/></p>

<p>可证，由原始递归函数经过合成运算或原始递归运算，得到的函数仍为原始递归函数。</p>

<p>每一个原始递归函数都是可计算的。</p>

<p><br/></p>

<p>常用原始递归函数举例，</p>

<p>常数<span data-katex="k"></span>，<span data-katex="x"></span>，<span data-katex="x+y"></span>，<span data-katex="x\cdot y"></span>，<span data-katex="x!"></span>，<span data-katex="x^y"></span>，前驱函数<span data-katex="p(x)"></span>，<span data-katex="|x-y|"></span></p>

<p><br/></p>

<p><strong>原始递归谓词</strong></p>

<p>如果一个谓词看作取值为<span data-katex="0"></span>或<span data-katex="1"></span>的全函数是原始递归的，则称该谓词是原始递归的。</p>

<p>可证，如果<span data-katex="P"></span>和<span data-katex="Q"></span>是原始递归谓词，则<span data-katex="\neg P"></span>，<span data-katex="P\wedge Q"></span>和<span data-katex="P\vee Q"></span>也是原始递归谓词。</p>

<p><br/></p>

<p><strong>极小化运算</strong></p>

<p>设<span data-katex="P(x_1,\cdots ,x_n,t)"></span>是一个谓词，</p>

<p><span data-katex="f(x_1,\cdots ,x_n)=min\ P(x_1,\cdots ,x_n,t)"></span>，</p>

<p><span data-katex="f(x_1,\cdots ,x_n)"></span>的值，或者是使<span data-katex="P(x_1,\cdots ,x_n,t)"></span>为真的<span data-katex="t"></span>的最小值，</p>

<p>或者无定义，如果不存在<span data-katex="t"></span>使得<span data-katex="P(x_1,\cdots ,x_n,t)"></span>为真。</p>

<p>其中，<span data-katex="min"></span>为极小化运算，</p>

<p>也称部分函数<span data-katex="f"></span>，是由谓词<span data-katex="P"></span>经过极小化运算得到的。</p>

<p><br/></p>

<p>设<span data-katex="g(x_1,\cdots ,x_n,t)"></span>是一个<span data-katex="n+1"></span>元全函数，</p>

<p><span data-katex="f(x_1,\cdots ,x_n)=min\ {g(x_1,\cdots ,x_n,t)=0}"></span>，</p>

<p>则称<span data-katex="f"></span>是由函数<span data-katex="g"></span>经过极小化运算得到的。</p>

<p><br/></p>

<p><strong>递归函数类</strong></p>

<p>由初始函数经过有限次合成运算，原始递归运算和极小化运算，得到的函数称为部分递归函数，</p>

<p>部分递归的全函数称为递归函数。</p>

<p><br/></p>

<p>如果一个谓词看作取值为<span data-katex="0"></span>或<span data-katex="1"></span>的全函数是递归的，则称该谓词是递归的。</p>

<p><br/></p>

<p><strong>递归性与可计算性</strong></p>

<p>可证，部分递归函数是部分可计算函数。</p>

<p>递归函数是可计算函数，递归谓词是可计算谓词。</p>

<p><br/></p>

<p>可证，原始递归函数类是可计算函数类的真子集。</p>

<p><br/></p>

<p>因为，至少存在一个Ackermann函数<span data-katex="A(k,x)"></span>是可计算的，但不是原始递归的。</p>

<p><span data-katex="A(0,x)=x+1"></span></p>

<p><span data-katex="A(k+1,0)=A(k,1)"></span></p>

<p><span data-katex="A(K+1,x+1)=A(k,A(k+1,x))"></span></p>

<p><br/></p>

<h2><strong>集合和语言的递归性</strong></h2>

<p><strong>集合识别问题</strong></p>

<p>所谓集合识别问题，是指对于给定的集合，任给一个元素，问这个元素是否属于该集合，</p>

<p>也称为集合的成员资格问题。</p>

<p><br/></p>

<p><strong>集合特征函数</strong></p>

<p>设<span data-katex="B\subseteq N"></span>，<span data-katex="B"></span>的特征函数<span data-katex="\chi _B"></span>是一个谓词，定义为，</p>

<p><span data-katex="\chi _B\equiv x\in B,\ \forall x\in N"></span>，</p>

<p>集合<span data-katex="B"></span>可以用它的特征函数表示为，<span data-katex="B=\{x\in N|\chi _B(x)\}"></span>。</p>

<p><br/></p>

<p>如果特征函数<span data-katex="\chi _B"></span>是可计算的，则成集合<span data-katex="B"></span>是递归的。</p>

<p>如果存在部分可计算函数<span data-katex="g"></span>使得<span data-katex="B=\{x\in N|g(x)\downarrow \}"></span>，</p>

<p>则称集合<span data-katex="B"></span>是递归可枚举的。</p>

<p><br/></p>

<p>可证，如果集合<span data-katex="B"></span>和<span data-katex="C"></span>都是递归的，则集合<span data-katex="\bar{B}"></span>，<span data-katex="B\cap C"></span>和<span data-katex="B\cup C"></span>都是递归的。</p>

<p>递归集一定是递归可枚举的。</p>

<p>集合<span data-katex="B"></span>是递归的，当且仅当<span data-katex="B"></span>和<span data-katex="\bar{B}"></span>都是递归可枚举的。</p>

<p>如果集合<span data-katex="B"></span>和<span data-katex="C"></span>是递归可枚举的，则集合<span data-katex="B\cap C"></span>和<span data-katex="B\cup C"></span>也是递归可枚举的。</p>

<p><br/></p>

<p><strong>语言识别问题</strong></p>

<p>设字母表<span data-katex="A=\{s_1,s_2,\cdots ,s_n\}"></span>，<span data-katex="A^*"></span>的任何子集<span data-katex="L"></span>称为<span data-katex="A"></span>上的语言。</p>

<p><span data-katex="A^*"></span>上集合的识别问题，有称为<span data-katex="A"></span>上的语言识别问题。</p>

<p><br/></p>

<p>语言的特征函数定义为，<span data-katex="\chi _L\equiv w\in L,\ \forall w\in A^*"></span>，</p>

<p>如果语言<span data-katex="L"></span>的特征函数<span data-katex="\chi _L"></span>是可计算的，则称语言<span data-katex="L"></span>是递归的。</p>

<p>如果存在<span data-katex="A"></span>上的部分可计算函数<span data-katex="g"></span>使得，<span data-katex="L=\{w\in A^*|g(w)\downarrow \}"></span>，</p>

<p>则称语言<span data-katex="L"></span>是递归可枚举的。</p>

<p><br/></p>

<p><strong>递归可枚举集</strong></p>

<p>设<span data-katex="B\subseteq N"></span>，且<span data-katex="B"></span>是递归可枚举的，</p>

<p>则存在原始递归谓词<span data-katex="R(x,t)"></span>使得，<span data-katex="B=\{x|\exists t\ R(x,t)\}"></span></p>

<p><br/></p>

<p>设<span data-katex="B"></span>是一个非空递归可枚举集，则存在原始递归函数<span data-katex="f(x)"></span>使得，</p>

<p><span data-katex="B=\{f(x)|x\in N\}"></span></p>

<p><br/></p>

<p>集合<span data-katex="B"></span>是递归可枚举的，当且仅当存在部分可计算函数<span data-katex="f(x)"></span>，使得，</p>

<p><span data-katex="B=\{f(x)|f(x)\downarrow \}"></span></p>

<p><br/></p>

<p>总之，如果<span data-katex="B"></span>非空，则以下命题是等价的，</p>

<p>（1）<span data-katex="B"></span>是递归可枚举的，即<span data-katex="B"></span>是一个部分可计算函数的定义域，</p>

<p>（2）<span data-katex="B"></span>是第一个原始递归函数的值域，</p>

<p>（3）<span data-katex="B"></span>是一个可计算函数的值域，</p>

<p>（4）<span data-katex="B"></span>是一个部分可计算函数的值域。</p>

<p><br/></p>

<h2><strong>可判定性与半可判定性</strong></h2>

<p><span data-katex="\mathscr{S}"></span>程序设计语言，递归函数，Turing机，文法等计算模型，</p>

<p>可以证明它们是等价的，即计算相同的函数类——部分可计算函数。</p>

<p>它们可以识别相同的语言类，递归可枚举语言。</p>

<p><br/></p>

<p>如果语言<span data-katex="L"></span>是递归的，那么存在一台总停机的DTM（确定型图灵机）<span data-katex="\mathscr{M}"></span>识别<span data-katex="L"></span>，</p>

<p>任给一个字符串<span data-katex="x"></span>，<span data-katex="\mathscr{M}"></span>总能在有限步内回答<span data-katex="x\in L"></span>还是<span data-katex="x\notin L"></span>，</p>

<p>因而，我们说<span data-katex="L"></span>为可判定的。</p>

<p><br/></p>

<p>如果<span data-katex="L"></span>的递归可枚举的，情况就不同了，识别<span data-katex="L"></span>的DTM可能永不停机，</p>

<p>只有当<span data-katex="x\in L"></span>时，<span data-katex="\mathscr{M}"></span>才能保证一定能在有限步内停机并接受<span data-katex="x"></span>，</p>

<p>而当<span data-katex="x\notin L"></span>时，<span data-katex="\mathscr{M}"></span>可能永不停机，</p>

<p>在这种情况下，我们不知道是暂时没有停机，还是永不停机，</p>

<p>这时，我们说<span data-katex="L"></span>是半可判定的。</p>

<p><br/></p>

<p>因此，递归语言是可判定的，而递归可枚举语言是半可判定的，</p>

<p>同样的，直观可计算函数是可计算函数，而部分可计算函数是半可计算的，</p>

<p>可计算谓词是可判定的，它定义的集合是递归的，</p>

<p>如果谓词定义的集合是递归可枚举的，则该谓词是半可判定的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[不动点算子与完全偏序]]></title>
    <link href="https://thzt.github.io/blog/2016/06/25/complete-partial-order/"/>
    <updated>2016-06-25T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/06/25/complete-partial-order</id>
    <content type="html"><![CDATA[<script src="https://thzt.github.io/thirdpart/jQuery/jquery-1.11.1.js"></script>


<p><link href="https://thzt.github.io/thirdpart/KaTeX/katex.min.css" rel="stylesheet"/></p>

<script src="https://thzt.github.io/thirdpart/KaTeX/katex.min.js"></script>


<script src="https://thzt.github.io/javascripts/katex.js"></script>


<h2><strong>域论模型</strong></h2>

<p>类型化lambda演算，有两个常用模型。</p>

<p>其一，域论模型。其二，递归函数论模型。</p>

<p><br/></p>

<p>在众多域论模型中，</p>

<p>主要关心的是一种具有完全偏序（complete partial order）结构的域，简称CPO。</p>

<p>研究它的主要原因是，它是带有不动点算子的模型，</p>

<p>而且它还提供了一种解释递归类型表达式的方法。</p>

<p>域论方法是递归函数论模型的基础。</p>

<p><br/></p>

<h2><strong>递归</strong></h2>

<p>加入递归之后，对表达式进行归约就可能会无限的进行下去，</p>

<p>因此将出现没有范式（normal form）的表达式。</p>

<p>于是，把每个表达式指称为一个数值，这种想法就可能有问题了。</p>

<p>下面我们引入不动点算子（fixed-point operator），用来它定义递归。</p>

<p><br/></p>

<p><span data-katex="letrec~f:\sigma=M~in~N"></span></p>

<p>它表示<span data-katex="N"></span>，但是<span data-katex="N"></span>中f的值，是等式<span data-katex="f=M"></span>的解。</p>

<p>而<span data-katex="M"></span>中可能会包含<span data-katex="f"></span>。</p>

<p><span data-katex="M"></span>的类型根据等式<span data-katex="f=M"></span>也是<span data-katex="\sigma"></span>。</p>

<p><br/></p>

<p>我们将看到，<span data-katex="letrec"></span>是<span data-katex="let"></span>与不动点算子的语法糖（syntactic sugar）。</p>

<p>首先，我们先用<span data-katex="letrec"></span>定义阶乘函数，来计算<span data-katex="5!"></span>。</p>

<p><span data-katex="letrec~f:nat\rightarrow nat=\lambda y:nat.~(if~Eq?~y~0~then~1~else~y*f(y-1))~in~f~5"></span></p>

<p><br/></p>

<p>其中<span data-katex="f"></span>是下列等式的解。</p>

<p><span data-katex="f=\lambda y:nat.~if~Eq?~y~0~then~1~else~y*f(y-1)"></span></p>

<p><br/></p>

<h2><strong>不动点算子</strong></h2>

<p>从数学的角度来看，并不是所有形如<span data-katex="f:\sigma =M"></span>的等式都有解，</p>

<p>如果有多个解，也不知道选择哪个解。</p>

<p>我们先假设每个这样的等式都有解，为此我们增加一个不动点算子来得到这个解。</p>

<p><br/></p>

<p>一般的，如果<span data-katex="F:\sigma \rightarrow \sigma"></span>是某一类型到自身的函数。</p>

<p>那么<span data-katex="F"></span>的一个不动点，是使得<span data-katex="x=F(x)"></span>的值<span data-katex="x:\sigma"></span>。</p>

<p><br/></p>

<p>经过观察我们发现，阶乘函数<span data-katex="f"></span>是以下函数的<span data-katex="F"></span>的不动点，即满足<span data-katex="f=F(f)"></span>。</p>

<p><span data-katex="F=_{def}\lambda f:nat\rightarrow nat.~\lambda y:nat.~if~Eq?~y~0~then~1~else~y*f(y-1)"></span></p>

<p>其中，<span data-katex="f:nat\rightarrow nat"></span>，<span data-katex="F:(nat\rightarrow nat)\rightarrow (nat\rightarrow nat)"></span></p>

<p><br/></p>

<p>我们定义，<span data-katex="fix_\sigma :(\sigma \rightarrow \sigma )\rightarrow \sigma"></span>，是对应于每个类型<span data-katex="\sigma"></span>的不动点算子。</p>

<p>满足的如下等式公理，</p>

<p><span data-katex="fix_\sigma =\lambda f:\sigma \rightarrow \sigma .~f(fix_\sigma f)"></span></p>

<p><br/></p>

<p>可知，对任意的<span data-katex="F:\sigma \rightarrow \sigma"></span>，<span data-katex="fix_\sigma F"></span>是<span data-katex="F"></span>的不动点，即，</p>

<p><span data-katex="fix_\sigma F=F(fix_\sigma F)"></span></p>

<p><br/></p>

<p>我们就可以用<span data-katex="let"></span>和<span data-katex="fix_\sigma"></span>表示<span data-katex="letrec"></span>了。</p>

<p><span data-katex="letrec~f:\sigma =M~in~N=_{def}let~f:\sigma =(fix_\sigma \lambda f:\sigma .~M)~in~N"></span></p>

<p><br/></p>

<h2><strong>归约</strong></h2>

<p>我们以阶乘函数为例，来说明带有不动点算子的表达式是如何归约的。</p>

<p>为了行文方便，我们省略<span data-katex="fix_{nat\rightarrow nat}"></span>的下标，直接记为<span data-katex="fix"></span>。</p>

<p>定义阶乘函数<span data-katex="fact=_{def}fix~F"></span>，其中，</p>

<p><span data-katex="F=_{def}\lambda f:nat\rightarrow nat.~\lambda y:nat.~if~Eq?~y~0~then~1~else~y*f(y-1)"></span></p>

<p><br/></p>

<p>我们来计算<span data-katex="fact~n"></span>。</p>

<p><span data-katex="fact~n=(fix~F)~n"></span></p>

<p><span data-katex="=((\lambda f:nat\rightarrow nat.~f(fix~f))~F)~n"></span></p>

<p><span data-katex="=(F~(fix~F))~n"></span></p>

<p><span data-katex="=((\lambda f:nat\rightarrow nat.~\lambda y:nat.~if~Eq?~y~0~then~1~else~y*f(y-1))~(fix~F))~n"></span></p>

<p><span data-katex="=(if~Eq?~n~0~then~1~else~n*(fix~F))~(n-1)"></span></p>

<p><br/></p>

<h2><strong>无法终止的运算</strong></h2>

<p>由于递归允许我们写出没有范式的表达式，</p>

<p>所以我们相应的必须给这样的表达式赋予含义。</p>

<p><br/></p>

<p>例如，</p>

<p><span data-katex="letrec~f:nat\rightarrow nat=\lambda x:nat.~f(x+1)~in~f~3"></span></p>

<p>尽管该表达式的类型是<span data-katex="nat"></span>，但是我们无法把它简化为一个数值。</p>

<p>所以该表达式的含义就不是一个自然数了。</p>

<p><br/></p>

<p>一方面，认为该表达式的类型是<span data-katex="nat"></span>是合理的，它是类型规则的推导结论。</p>

<p>另一方面，如果我们说该表达式的值是『未定义的』，</p>

<p>那么<span data-katex="f"></span>的语义就变成了部分函数（partial function）。</p>

<p><br/></p>

<p>我们不如给自然数集附加一个值<span data-katex="\perp _{nat}"></span>，</p>

<p>用来表示类型<span data-katex="nat"></span>上无法终止的运算（nonterminating computation）。</p>

<p>这给了我们一个把部分函数看成完全函数（total function）的方法。</p>

<p><br/></p>

<h2><strong>CPO</strong></h2>

<p><strong>偏序</strong></p>

<p>一个偏序（partial order）<span data-katex="\left \langle D,\leqslant  \right \rangle"></span>是一个集合<span data-katex="D"></span>，以及集合上的一个关系（relation）<span data-katex="\leqslant"></span>，</p>

<p>这个关系具有自反性，反对称性，和传递性。</p>

<p><br/></p>

<p>若对于任意<span data-katex="d\in D"></span>有<span data-katex="d\leqslant d"></span>，则称<span data-katex="\leqslant"></span>具有自反性（reflexive）。</p>

<p>若<span data-katex="a\leqslant b"></span>且<span data-katex="b\leqslant a"></span>有<span data-katex="a=b"></span>，则称<span data-katex="\leqslant"></span>具有反对称性（anti-symmetric）。</p>

<p>若<span data-katex="a\leqslant b"></span>且<span data-katex="b\leqslant c"></span>有<span data-katex="a\leqslant c"></span>，则称<span data-katex="\leqslant"></span>具有传递性（transitive）。</p>

<p><br/></p>

<p><strong>上界与最小上界</strong></p>

<p>如果<span data-katex="\left \langle D,\leqslant  \right \rangle"></span>是一个偏序，则子集<span data-katex="S\subseteq D"></span>的上界（upper bound），</p>

<p>是<span data-katex="D"></span>中的一个元素<span data-katex="x\in D"></span>，使得对于任意的<span data-katex="y\in S"></span>有<span data-katex="y\leqslant x"></span>。</p>

<p>最小上界（least upper bound）是那个<span data-katex="\leqslant"></span>任何其它上界的元素。</p>

<p><br/></p>

<p><strong>有向集</strong></p>

<p>如果<span data-katex="\left \langle D,\leqslant  \right \rangle"></span>是一个偏序，称子集<span data-katex="S\subseteq D"></span>是有向的（directed），</p>

<p>如果<span data-katex="S"></span>的每一个有限子集<span data-katex="S_0\subseteq S"></span>在<span data-katex="S"></span>中都有上界。</p>

<p>有向集（directed set）的一个性质是，所有有向集都非空。</p>

<p><br/></p>

<p><strong>完全偏序</strong></p>

<p>完全偏序（complete partial order）简称CPO，它是一个偏序<span data-katex="\left \langle D,\leqslant  \right \rangle"></span>，</p>

<p>且每一个有向子集<span data-katex="S\subseteq D"></span>都有最小上界，我们把这个最小上界记为<span data-katex="\bigvee S"></span>。</p>

<p>可证，任何一个有限的偏序，都是完全偏序。</p>

<p><br/></p>

<p>一个不是CPO的例子是自然数集，自然数集<span data-katex="N"></span>本身是有向的，但没有最小上界。</p>

<p>如果我们加入一个比其他自然数都大的元素<span data-katex="\infty"></span>，我们就得到了一个CPO。</p>

<p><br/></p>

<h2><strong>CPO的提升</strong></h2>

<p><strong>有奇点的CPO</strong></p>

<p>如果<span data-katex="\mathscr{D}=\left \langle D,\leqslant  \right \rangle"></span>是一个有最小元（least element）的偏序，</p>

<p>则称为<span data-katex="\mathscr{D}"></span>是有奇点（pointed）的，我们用<span data-katex="\perp _D"></span>表示<span data-katex="D"></span>的最小元。</p>

<p><br/></p>

<p><strong>提升集</strong></p>

<p>对于任意的集合<span data-katex="A"></span>，我们构建一个CPO，<span data-katex="A_\perp =\left \langle A\cup \{\perp \} ,\leqslant  \right \rangle"></span>，</p>

<p>其中，<span data-katex="x\leqslant y"></span>当且仅当<span data-katex="x=\perp"></span>或<span data-katex="x=y"></span>。</p>

<p>我们称<span data-katex="A_\perp"></span>为<span data-katex="A"></span>的提升集（lifted set）。</p>

<p><br/></p>

<p>用这个方法，我们可以提升任何一个CPO，<span data-katex="\mathscr{D}=\left \langle D,\leqslant _D  \right \rangle"></span>，</p>

<p>得到<span data-katex="\mathscr{D}_\perp =\left \langle D\cup \{\perp \},\leqslant \right \rangle"></span>，</p>

<p>其中<span data-katex="\perp"></span>与<span data-katex="D"></span>中的任何元素都不等，新的序关系<span data-katex="x\leqslant y"></span>当且仅当<span data-katex="x=\perp"></span>或<span data-katex="x\leqslant _D y"></span>。</p>

<p><br/></p>

<p>可证，如果<span data-katex="\mathscr{D}"></span>是一个CPO，则<span data-katex="\mathscr{D}_\perp"></span>是一个有奇点的CPO。</p>

<p><br/></p>

<h2><strong>连续函数</strong></h2>

<p><strong>单调函数</strong></p>

<p>设<span data-katex="\mathscr{D}=\left \langle D,\leqslant _D \right \rangle"></span>和<span data-katex="\mathscr{E}=\left \langle E,\leqslant _E \right \rangle"></span>是CPO，</p>

<p><span data-katex="f:D\rightarrow E"></span>是集合<span data-katex="D"></span>到<span data-katex="E"></span>的一个函数，我们说<span data-katex="f"></span>是单调的（monotonic），</p>

<p>如果<span data-katex="a\leqslant b"></span>就有<span data-katex="f(a)\leqslant f(b)"></span>。</p>

<p><br/></p>

<p><strong>连续函数</strong></p>

<p>一个单调函数<span data-katex="f"></span>是连续的（continuous），如果对于任意有向子集<span data-katex="S\subseteq D"></span>，有<span data-katex="f(\bigvee S)=\bigvee f(S)"></span>。</p>

<p><br/></p>

<p><strong>提升函数</strong></p>

<p>我们定义<span data-katex="f:D\rightarrow E"></span>对应的提升函数（lifted function）为<span data-katex="f_\perp =(D\cup\{ \perp \})\rightarrow (E\cup\{ \perp \})"></span>。</p>

<p>其中，如果<span data-katex="a\in D"></span>，则<span data-katex="f_\perp (a)=f(a)"></span>，否则<span data-katex="f_\perp (a)=\perp"></span>。</p>

<p><br/></p>

<p><strong>函数集构成CPO</strong></p>

<p>假设<span data-katex="\mathscr{D}=\left \langle D,\leqslant _D \right \rangle"></span>和<span data-katex="\mathscr{E}=\left \langle E,\leqslant _E \right \rangle"></span>是CPO，</p>

<p>对于连续函数<span data-katex="f,g:D\rightarrow E"></span>，我们称<span data-katex="f\leqslant_{D\rightarrow E} g"></span>，如果对于任意<span data-katex="d\in D"></span>，都有<span data-katex="f(d)\leqslant _E g(d)"></span>。</p>

<p>于是，所有这些连续函数构成了一个CPO，记为<span data-katex="\mathscr{D}\rightarrow \mathscr{E}=\left \langle D\rightarrow E,\leqslant _{D\rightarrow E} \right \rangle"></span>。</p>

<p><br/></p>

<h2><strong>最小不动点</strong></h2>

<p>我们称<span data-katex="a"></span>是<span data-katex="f"></span>的最小不动点（least fixed point），</p>

<p>如果<span data-katex="a=f(a)"></span>且对于任意的<span data-katex="b=f(b)"></span>，我们有<span data-katex="a\leqslant b"></span>。</p>

<p><br/></p>

<p>如果<span data-katex="\mathscr{D}"></span>是一个有奇点的CPO，且<span data-katex="f:D\rightarrow D"></span>是连续的，则<span data-katex="f"></span>有最小不动点，</p>

<p><span data-katex="fix_D f=\bigvee \{ f^n(\perp )~|~n\geqslant 0 \}"></span>，</p>

<p>且<span data-katex="fix_D"></span>是连续的。</p>

<p><br/></p>

<p>例如，设<span data-katex="\mathscr{D}=\left \langle D,\leqslant _D \right \rangle"></span>是有奇点的CPO，则恒等函数<span data-katex="id:D\rightarrow D"></span>的最小不动点是<span data-katex="\perp _D"></span>。</p>

<p><span data-katex="fix_D~id=\bigvee \{ id^n(\perp _D)~|~n\geqslant 0 \}=\bigvee \{ \perp _D \}=\perp _D"></span></p>

<h2><strong>结语</strong></h2>

<p>初等数学中，某些函数是没有不动点的。</p>

<p>那么在什么情况下，形如<span data-katex="f:\sigma =M"></span>的表达式有解呢？</p>

<p>定义了递归之后，对类型化lambda演算的模型产生了什么影响呢？</p>

<p><br/></p>

<p>这是一直以来我心中是一个问题。</p>

<p>诚然，类型化lambda演算有不同的解释方式，但以上域论模型通俗易懂，</p>

<p>也算是告一段落吧，以后的路还长着呢。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[代数数据类型的语法和语义]]></title>
    <link href="https://thzt.github.io/blog/2016/06/08/algebraic-data-type/"/>
    <updated>2016-06-08T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/06/08/algebraic-data-type</id>
    <content type="html"><![CDATA[<script src="https://thzt.github.io/thirdpart/jQuery/jquery-1.11.1.js"></script>


<p><link href="https://thzt.github.io/thirdpart/KaTeX/katex.min.css" rel="stylesheet"/></p>

<script src="https://thzt.github.io/thirdpart/KaTeX/katex.min.js"></script>


<script src="https://thzt.github.io/javascripts/katex.js"></script>


<h3><strong>代数数据类型</strong></h3>

<p>一个代数数据类型，由值的一些集合，以及这些集合之间的一些函数构成。</p>

<p>这些函数都是一阶函数，不能以其他函数作为参数。</p>

<p><br/></p>

<h3><strong>泛代数</strong></h3>

<p>泛代数（universal algebra）也称为等式逻辑（equational logic），</p>

<p>是用于研究代数数据类型的一个数学框架。</p>

<p><br/></p>

<p>在泛代数中，代数数据类型的语法由代数项（algebraic term）描述，公理语义用项之间的等式集（a set of equations）描述，</p>

<p>而指称语义对应于一个<span data-katex="\Sigma"></span>代数，操作语义通过给等式设定方向来表示。</p>

<hr />

<h2><strong>代数数据类型的语法</strong></h2>

<h3><strong>代数项和签名</strong></h3>

<p>一个代数项（algebraic term）由符号和类型来定义，</p>

<p>这些信息放在一起称为代数项的签名（signature）。</p>

<p><br/></p>

<p>构成代数项的基本类型称为sort。</p>

<p><br/></p>

<p>一个签名<span data-katex="\Sigma=\left \langle S,F \right \rangle"></span>，由以下几个部分构成，</p>

<p>（1）以sort为元素构成的集合</p>

<p>（2）sort上函数符号的集合<span data-katex="F=\left \{ f:s_1\times \cdots \times s_k\rightarrow s \right \}"></span></p>

<p>其中，<span data-katex="s_1,\cdots ,s_k,s\in S"></span>，<span data-katex="f"></span>称为类型化的函数符号，</p>

<p>每个函数符号的类型是唯一的。</p>

<p><br/></p>

<p>例如，自然数表达式的签名是<span data-katex="\Sigma_N=\left \langle S,F \right \rangle"></span>，</p>

<p>其中<span data-katex="S=\left \{ nat \right \}"></span>，只包含一个sort，</p>

<p><span data-katex="F"></span>给出以下几个函数符号，</p>

<p><span data-katex="0:nat"></span>，<span data-katex="1:nat"></span>，<span data-katex="+:nat\times nat\rightarrow nat"></span>，<span data-katex="*:nat\times nat\rightarrow nat"></span>。</p>

<p>习惯上为了节省空间，通常把签名写成一个表格形式，</p>

<p><span data-katex="sorts:nat"></span></p>

<p><span data-katex="fctns:0,1:nat"></span></p>

<p><span data-katex="+,*:nat\times nat\rightarrow nat"></span></p>

<p><br/></p>

<h3><strong>变量的指派</strong></h3>

<p>一个指派（sort assignment），是如下一个有限集合，用来指定变量的类型，</p>

<p><span data-katex="\Gamma=\left \{ x_1:s_1,\cdots ,x_k:s_k \right \}"></span></p>

<p>不能为同一个变量指派不同的sort。</p>

<p><br/></p>

<h3><strong>合法代数项的集合</strong></h3>

<p>基于签名<span data-katex="\Sigma"></span>和指派<span data-katex="\Gamma"></span>，可以定义一个sort为<span data-katex="s"></span>的代数项的集合<span data-katex="Terms^s\left ( \Sigma,\Gamma \right )"></span>，</p>

<p>它满足以下几个条件，</p>

<p>（1）如果<span data-katex="x:s\in \Gamma"></span>则<span data-katex="x\in Terms^s\left ( \Sigma,\Gamma \right )"></span></p>

<p>（2）如果<span data-katex="f:s_1\times \cdots \times s_k\rightarrow s"></span>且<span data-katex="M_i\in Terms^{s_i}\left ( \Sigma,\Gamma \right )"></span>，</p>

<p><span data-katex="i=1,\cdots ,n"></span>，则<span data-katex="fM_1\cdots M_k\in Terms^s\left ( \Sigma,\Gamma \right )"></span></p>

<hr />

<h2><strong>代数数据类型的指称语义</strong></h2>

<h3><strong><span data-katex="\Sigma"></span>代数</strong></h3>

<p><span data-katex="\Sigma"></span>代数是一种数学结构，它为代数项提供了含义或指称语义。</p>

<p><br/></p>

<p>一个<span data-katex="\Sigma"></span>代数，包含了一个或多个集合，称为载体（carrier），</p>

<p>以及一些特征元素，和载体上的一些一阶函数，</p>

<p><span data-katex="f:A_1\times \cdots \times A_k \rightarrow A"></span></p>

<p><br/></p>

<p>例如，<span data-katex="\Sigma"></span>代数<span data-katex="\mathscr{N}=\left \langle N,0,1,+,* \right \rangle"></span></p>

<p>具有载体<span data-katex="N"></span>，它是自然数集，</p>

<p>具有特征元素，<span data-katex="0,1\in N"></span>，</p>

<p>以及函数，<span data-katex="+,*:N \times N \rightarrow N"></span>。</p>

<p>其中，特征元素可以看成零元函数。</p>

<p><br/></p>

<p>带有多个载体的例子是<span data-katex="\Sigma"></span>代数<span data-katex="\mathscr{A}_{pcf}=\left \langle N,B,0,1,\cdots ,+,true,false,Eq?,\cdots ,\right \rangle"></span></p>

<p>其中<span data-katex="N"></span>是自然数集，<span data-katex="B"></span>是布尔值集，</p>

<p><span data-katex="0,1,\cdots"></span>是自然数，<span data-katex="+"></span>是加法函数。</p>

<p><br/></p>

<h3><strong>代数项的解释</strong></h3>

<p>我们说<span data-katex="\mathscr{A}=\left \langle \left \{ A^s \right \}_{s\in S}, \mathscr{I} \right \rangle"></span>是与所有合法代数项<span data-katex="\left \{ Terms^s\left ( \Sigma,\Gamma \right ) \right \}_{s\in S}"></span>对应的<span data-katex="\Sigma"></span>代数，</p>

<p>指的是如下对应关系成立，</p>

<p>（1）每一个sort，<span data-katex="s\in S"></span>，恰好对应一个载体<span data-katex="A^s"></span></p>

<p>（2）每一个函数符号<span data-katex="f:s_1\times \cdots \times s_k\rightarrow s"></span>，恰好对应一个函数<span data-katex="\mathscr{I}(f):A^{s_1}\times \cdots \times A^{s_k}\rightarrow A^s"></span></p>

<p>习惯上把<span data-katex="\mathscr{I}(f)"></span>写成<span data-katex="f^{\mathscr{A}}"></span>。</p>

<p><br/></p>

<h3><strong>含变量代数项的解释</strong></h3>

<p><span data-katex="\Sigma"></span>代数<span data-katex="\mathscr{A}"></span>的环境<span data-katex="\eta"></span>，是把变量映射到<span data-katex="\mathscr{A}"></span>的各载体中元素的一个映射。</p>

<p><span data-katex="\eta :\mathscr{V} \rightarrow\cup _sA^s"></span></p>

<p>需要环境的原因是，对于含变量<span data-katex="x"></span>的项<span data-katex="M"></span>，叙述<span data-katex="M"></span>的含义必须先给<span data-katex="x"></span>指定一个确定的值。</p>

<p>如果对于每个<span data-katex="x:s\in \Gamma"></span>，都有<span data-katex="\eta (x)\in A^s"></span>，就说环境<span data-katex="\eta"></span>满足指派<span data-katex="\Gamma"></span>。</p>

<p><br/></p>

<p>假定<span data-katex="\Sigma"></span>代数<span data-katex="\mathscr{A}"></span>的一个环境<span data-katex="\eta"></span>满足指派<span data-katex="\Gamma"></span>，</p>

<p>则可以把环境<span data-katex="\eta"></span>下的任何项<span data-katex="M\in Terms\left ( \Sigma ,\Gamma \right )"></span>的含义<span data-katex="\mathscr{A}[[M]]\eta"></span>定义如下，</p>

<p>（1）<span data-katex="\mathscr{A}[[M]]\eta =\eta (x)"></span></p>

<p>（2）<span data-katex="\mathscr{A}[[fM_1\cdots M_k]]\eta =f^{\mathscr{A}}(\mathscr{A}[[M_1]]\eta ,\cdots ,\mathscr{A}[[M_k]]\eta )"></span></p>

<p><br/></p>

<p>若<span data-katex="\Sigma"></span>代数<span data-katex="\mathscr{A}"></span>在上下文中是明确的，通常省略<span data-katex="\mathscr{A}"></span>而直接写<span data-katex="[[M]]\eta"></span>，</p>

<p>若<span data-katex="M"></span>中没有变量，则<span data-katex="\mathscr{A}[[M]]\eta"></span>不依赖于<span data-katex="\eta"></span>，可以写为<span data-katex="\mathscr{A}[[M]]"></span>。</p>

<hr />

<h2><strong>语法和语义的关系</strong></h2>

<h3><strong>可靠性与完备性</strong></h3>

<p>代数数据类型的公理语义是由代数项之间的等式集给出的，签名和等式集合称代数规范（algebraic specification）。</p>

<p>一个代数规范，或者可以使用等式证明系统推导出代数项之间的其他等式，或者可以检验代数项对应的<span data-katex="\Sigma"></span>代数是否满足这些等式的要求。</p>

<p><br/></p>

<p>代数项对应的<span data-katex="\Sigma"></span>代数并不是唯一的。</p>

<p>从一个代数规范推导得到的等式，在该规范对应的任何<span data-katex="\Sigma"></span>代数中都成立，就称该代数证明系统是可靠的（sound）。</p>

<p>一个代数规范对应的任何<span data-katex="\Sigma"></span>代数中都成立的等式，在该规范中都可证，就称该代数证明系统是完备的（complete）。</p>

<p><br/></p>

<h3><strong>等式的可满足性</strong></h3>

<p>等式（equation）是一个公式<span data-katex="M=N[\Gamma ]"></span>，其中<span data-katex="M,N\in Terms^s\left ( \Sigma ,\Gamma \right )"></span>，<span data-katex="s\in S"></span>。</p>

<p>如果环境<span data-katex="\eta"></span>满足指派<span data-katex="\Gamma"></span>，且<span data-katex="[[M]]\eta =[[N]]\eta"></span>，</p>

<p>就说<span data-katex="\Sigma"></span>代数<span data-katex="\mathscr{A}"></span>在环境<span data-katex="\eta"></span>下满足<span data-katex="M=N[\Gamma ]"></span>，记为</p>

<p><span data-katex="\mathscr{A},\eta \models M=N[\Gamma]"></span></p>

<p><br/></p>

<p>对于含变量的项，我们更感兴趣的是一个等式是否在变量所有可能的取值情况下都成立，</p>

<p>而不是在一个特别的环境中成立。</p>

<p>如果对于满足<span data-katex="\Gamma"></span>的任何一个环境<span data-katex="\eta"></span>都有<span data-katex="\mathscr{A},\eta \models M=N[\Gamma]"></span>，</p>

<p>就可以说，<span data-katex="\Sigma"></span>代数<span data-katex="\mathscr{A}"></span>满足等式<span data-katex="M=N[\Gamma ]"></span>，记为</p>

<p><span data-katex="\mathscr{A} \models M=N[\Gamma]"></span></p>

<p><br/></p>

<p>可满足性也可以扩展到等式集和代数集，</p>

<p>设<span data-katex="E"></span>是一个等式集，如果<span data-katex="\mathscr{A}"></span>满足所有等式，就说<span data-katex="\mathscr{A}"></span>满足<span data-katex="E"></span>。</p>

<p>类似的，若<span data-katex="C"></span>是一类<span data-katex="\Sigma"></span>代数，且对每个<span data-katex="\mathscr{A}\in C"></span>都有<span data-katex="\mathscr{A}\models M=N[\Gamma ]"></span>，则<span data-katex="C\models M=N[\Gamma ]"></span></p>

<p><br/></p>

<p>若任何一个<span data-katex="\Sigma"></span>代数都满足代数项之间的等式<span data-katex="M=N[\Gamma ]"></span>，就说该等式是永真的（valid），写为<span data-katex="\models M=N[\Gamma ]"></span>。</p>

<p>例如，<span data-katex="x=x[x:s]"></span>就是永真的。</p>

<p><br/></p>

<p>若<span data-katex="\mathscr{A}"></span>满足签名<span data-katex="\Sigma=\left \langle S,F \right \rangle"></span>上的所有等式，就说<span data-katex="\Sigma"></span>代数是平凡的（trivial）。</p>

<p><br/></p>

<h3><strong>语义蕴含（semantic implication）</strong></h3>

<p>若满足等式集<span data-katex="E"></span>的每一个<span data-katex="\Sigma"></span>代数<span data-katex="\mathscr{A}"></span>都满足等式<span data-katex="M=N[\Gamma ]"></span>，</p>

<p>则称签名<span data-katex="\Sigma"></span>上的等式集<span data-katex="E"></span>在语义上蕴含等式<span data-katex="M=N[\Gamma ]"></span>，记为，</p>

<p><span data-katex="E\models M=N[\Gamma ]"></span></p>

<p><br/></p>

<p>有了签名<span data-katex="\Sigma"></span>和等式集<span data-katex="E"></span>，我们定义代数规范<span data-katex="Spec=\left \langle \Sigma,E \right \rangle"></span>，</p>

<p>则满足代数规范的，在所有<span data-katex="\Sigma"></span>代数中都成立的等式，就是那些由等式集<span data-katex="E"></span>语义蕴含的等式。</p>

<p><br/></p>

<h3><strong>语义理论</strong></h3>

<p>如果等式集<span data-katex="E"></span>在语义蕴含下封闭（closed），则把它称为一个理论（theory）。</p>

<p>更准确的说，如果<span data-katex="E\models M=N[\Gamma ]"></span>，则<span data-katex="M=N[\Gamma ]\in E"></span>，那么等式集<span data-katex="E"></span>就称为一个语义理论（semantic theory）。</p>

<p>一个<span data-katex="\Sigma"></span>代数<span data-katex="\mathscr{A}"></span>的理论<span data-katex="Th(\mathscr{A})"></span>，就是在<span data-katex="\mathscr{A}"></span>中成立的所有等式的集合。</p>

<p>可以证明一个<span data-katex="\Sigma"></span>代数的理论是一个语义理论。</p>

<p><br/></p>

<h3><strong>形式证明</strong></h3>

<p>一个证明系统的推导规则如下，<span data-katex="\frac{antecedent}{consequent}"></span>，</p>

<p>使得从前件（antecedent）的任何实例出发，通过使用该证明系统的公理和其他规则，</p>

<p>可以推导出后件（consequent）的相应实例。</p>

<p><br/></p>

<p>例如：<span data-katex="\frac{M=N[\Gamma ],N=P[\Gamma ],P=Q[\Gamma ]}{M=Q[\Gamma ]}"></span></p>

<p><br/></p>

<p>若证明了一条规则是可推导的，则能够把它当做系统的一条证明规则来使用。</p>

<p>如果某条规则没有前件，则称它是证明系统的一条公理（axiom）。</p>

<p><br/></p>

<p>我们说等式<span data-katex="M=N[\Gamma ]"></span>是可证的（provable），记为<span data-katex="E\vdash M=N[\Gamma ]"></span></p>

<p>如果从<span data-katex="E"></span>到<span data-katex="M=N[\Gamma ]"></span>存在一个等式序列，</p>

<p>使得每个等式或者是公理（axiom），或者是<span data-katex="E"></span>中的等式，</p>

<p>或者是从序列中之前出现的一个或多个等式经一步推导得到的结果。</p>

<p><br/></p>

<h3><strong>语法理论</strong></h3>

<p>若在可证性下等式集<span data-katex="E"></span>是封闭的，则称<span data-katex="E"></span>是一个语法理论（syntactic theory）。</p>

<p>换句话说，如果<span data-katex="E\vdash M=N[\Gamma ]"></span>，则<span data-katex="M=N[\Gamma ]\in E"></span>，那么等式集<span data-katex="E"></span>就称为一个语法理论。</p>

<p><span data-katex="E"></span>的语法理论<span data-katex="Th(E)"></span>就是从<span data-katex="E"></span>可证的所有等式的集合。</p>

<p><br/></p>

<h3><strong>等式证明系统的性质</strong></h3>

<p>可靠性（soundness）：若<span data-katex="E\vdash M=N[\Gamma ]"></span>，则<span data-katex="E\models M=N[\Gamma ]"></span></p>

<p>演绎完备性（deductive completeness）：若<span data-katex="E\models M=N[\Gamma ]"></span>，则<span data-katex="E\vdash M=N[\Gamma ]"></span></p>

<hr />

<h2><strong>结语</strong></h2>

<p>《<a href="https://book.douban.com/subject/1761918/">Foundations for Programming Languages</a>》是一本好书，</p>

<p>可是中文的翻译《<a href="https://book.douban.com/subject/1944729/">程序设计语言理论基础</a>》简直是晦涩难懂，</p>

<p>把sort翻译为『类子』，把signature翻译为『基调』，容易让人误以为和同调代数有什么联系。</p>

<p>原版书拿到后，看起来轻松了不少，这里只是对第三章部分内容做了个小结，以便卸下包袱轻装上阵。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[类型理论之拙见]]></title>
    <link href="https://thzt.github.io/blog/2016/05/19/type-theory-in-my-eye/"/>
    <updated>2016-05-19T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/05/19/type-theory-in-my-eye</id>
    <content type="html"><![CDATA[<p>类型系统，是指一种根据所计算出值的种类，对词语进行分类，</p>

<p>从而证明某程序行为不会发生的，</p>

<p>可行语法手段。——《TAPL》</p>

<p><br/></p>

<p>可见类型系统是形式方法的一种，</p>

<p>也是一种证明方法。</p>

<p><br/></p>

<p>当我们把自己写好的程序提交给别人时，</p>

<p>如果别人质疑『你怎么证明它是对的』，</p>

<p>是不好回答的。</p>

<p><br/></p>

<p>因为通过测试用例来检测程序行为，</p>

<p>本身就是在进行不完全归纳，</p>

<p>我们只能断定验证过的事情是正确，</p>

<p>却不能断定一般性质。</p>

<p><br/></p>

<p>类型理论与数学，逻辑学，计算机科学相关，</p>

<p>甚至渗透到了其他学科之中。</p>

<p><br/></p>

<p>类型系统是程序语言之上的一套逻辑系统，</p>

<p>可以对程序进行推理，来断定某些性质。</p>

<p>不同的逻辑系统，『诱导』出了不同的类型系统。</p>

<p><br/></p>

<p>形式系统有个特点，那就是稍微改变一点约束条件，</p>

<p>就会得到一系列好玩的附加特性，</p>

<p>有大量丰富的逻辑系统可以玩。</p>

<p>例如，直觉主义逻辑，模态逻辑，时态逻辑，等等。</p>

<p><br/></p>

<p>可是，仅从代码进行静态分析，来断定程序运行时的所有行为，是不可判定的。</p>

<p>因此只能保证well typed的程序没有某类错误，</p>

<p>每个类型系统有各自要阻止的行为。</p>

<p><br/></p>

<p>类型系统种类繁多，支持各种好玩的特性，</p>

<p>例如，支持Polymorphism的类型系统，某类型可以由其他类型参数化，</p>

<p>支持Dependent type的系统，类型可以由值来决定，</p>

<p>子类型允许我们适当放宽类型要求，</p>

<p>递归类型，存在类型，全称类型。</p>

<p><br/></p>

<p>1934年，Curry意识到简单类型化lambda演算中的类型，与直觉主义逻辑之间的关系，</p>

<p>后面的研究发现，人们把这种对应关系推广为了Curry-Howard-Lambek Correspondance，</p>

<p>它将程序语言的类型，逻辑系统中的命题，和指称语义笛卡尔闭范畴，联系起来了。</p>

<p>一个合法项的存在，就证明了对应它类型的一个命题为真，程序即构造出来的证明。</p>

<p><br/></p>

<p>类型理论的实用内容还有很多，</p>

<p>Gradual typing的动静结合，例如flow，</p>

<p>以及Rust和Linear typeing的应用，</p>

<p>另外还有，Hindley–Milner类型推导算法。</p>

<p><br/></p>

<p>类型系统有一些性质可以衡量，</p>

<p>例如，type soundness，type safety，</p>

<p>以及检查类型的方式，static check，dynamic check，</p>

<p>包括某些语言是explicitly typed，而某些是implicitly typed，</p>

<p>某些语言是被stronger checked，有些则是weaker checked。</p>

<p><br/></p>

<p>现在是学习时间了。</p>

<p><br/></p>

<p>参考：</p>

<p><a href="https://wiki.haskell.org/Curry-Howard-Lambek_correspondence">Curry-Howard-Lambek correspondence</a></p>

<p><a href="https://book.douban.com/subject/1318672/">类型和程序设计语言</a></p>

<p><a href="http://lucacardelli.name/papers/typesystems.pdf">Type System - Luca Cardelli</a></p>

<p><a href="https://book.douban.com/subject/1944729/">程序设计语言理论基础</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[形式证明与逻辑推理]]></title>
    <link href="https://thzt.github.io/blog/2016/03/01/proof-and-deduction/"/>
    <updated>2016-03-01T00:00:00+08:00</updated>
    <id>https://thzt.github.io/blog/2016/03/01/proof-and-deduction</id>
    <content type="html"><![CDATA[<script src="https://thzt.github.io/thirdpart/jQuery/jquery-1.11.1.js"></script>


<p><link href="https://thzt.github.io/thirdpart/KaTeX/katex.min.css" rel="stylesheet"/></p>

<script src="https://thzt.github.io/thirdpart/KaTeX/katex.min.js"></script>


<script src="https://thzt.github.io/javascripts/katex.js"></script>


<p>小时候，我就对侦探非常着迷，</p>

<p>买了很多介绍破案的漫画书，故事书，小说。</p>

<p><br/></p>

<p>什么《大宇神秘惊奇系列》啊，</p>

<p>《名侦探柯南》啊，</p>

<p>《福尔摩斯探案全集》啊，等等。</p>

<p><br/></p>

<p>可是，对于<strong>什么是推理</strong>，</p>

<p>以及怎样进行推理，</p>

<p>并没有清晰系统的认识。</p>

<p><br/></p>

<p>学生时代，从平面几何开始，</p>

<p>我们就知道了证明题。</p>

<p>经过一步一步的推导，</p>

<p>最后证明结论成立。</p>

<p><br/></p>

<p>可是，对于<strong>什么是证明</strong>，</p>

<p>并没有人能说出精确的定义。</p>

<p><br/></p>

<p>这一切，难道真是只是个谜吗？</p>

<p>是人类的未知领域吗？</p>

<p><br/></p>

<p>其实不然。</p>

<p><strong>逻辑学</strong>就是研究推理和证明的学科，</p>

<p>研究思维的形式，规律和方法。</p>

<p><br/></p>

<p>其中，数理逻辑是逻辑学与数学的交叉学科，</p>

<p>用数学的方法研究逻辑，</p>

<p>我想，答案应该在这里吧。</p>

<p><br/></p>

<h2><strong>大局观</strong></h2>

<p>数理逻辑虽然博大精深，</p>

<p>但是研究方法却非常简洁优美。</p>

<p><br/></p>

<p>给定一套逻辑系统，</p>

<p>分别从两个侧面来描述这个系统的性质。</p>

<p>语法层面，语义层面。</p>

<p><br/></p>

<p><strong>语法</strong>，指的是构成这个逻辑系统的符号规则，</p>

<p>由公理和定理的推导规则组成，</p>

<p>让我们可以从一串合法的符号得到另一串合法符号，</p>

<p>称之为<strong>形式证明</strong>。</p>

<p><br/></p>

<p><strong>语义</strong>，指的是用什么样的数学对象可以解释这些符号，</p>

<p>由论域和解释函数组成，我们得到的是一些代数结构，</p>

<p>而且，从已知符号串的语义性质得到了其他符号串的性质，</p>

<p>称之为<strong>逻辑推理</strong>。</p>

<p><br/></p>

<p>学校中的数理逻辑教科书，介绍了<strong>命题演算</strong>和<strong>一阶谓词演算</strong>这两个典型的逻辑系统。</p>

<p>它们各自的语义解释，恰好描述了日常生活中推理问题。</p>

<p><br/></p>

<p>总之，数理逻辑，用一套符号，对生活中常见的逻辑问题，进行了数学建模，</p>

<p>研究它，希望得到与证明和推理相关的更多性质和结论。</p>

<p><br/></p>

<h2><strong>形式证明</strong></h2>

<p>为了说明问题，而又不引入过多的逻辑学概念，</p>

<p>我们从命题逻辑开始。</p>

<p><br/></p>

<p>命题逻辑的形式化演算系统大体上可分为两种类型，</p>

<p>一是<strong>希尔伯特式</strong>的公理化演算系统，</p>

<p>二是<strong>甘岑(Gentzen)式</strong>的自然推理系统。</p>

<p><br/></p>

<p>这两个系统各有所长，</p>

<p>前者更能体现公理化的思想，但其推理过程比较繁琐，</p>

<p>后者形式推理比较自然，但是规则较多。</p>

<p><br/></p>

<p>下面只说<strong>命题演算的自然推理系统</strong>。</p>

<p><br/></p>

<p><strong>语法：</strong></p>

<p>（1）可数个命题符号：<span data-katex="p_1,p_2,\cdots"></span></p>

<p>（2）5个联接词符号：<span data-katex="\neg,\lor,\land,\to,\leftrightarrow"></span></p>

<p>（3）2个辅助符号：<span data-katex="),("></span></p>

<p><br/></p>

<p><strong>公式：（BNF）</strong></p>

<p><span data-katex="\alpha::=p|(\neg\alpha)|(\alpha_1\lor\alpha_2)|(\alpha_1\land\alpha_2)|(\alpha_1\to\alpha_2)|(\alpha_1\leftrightarrow\alpha_2)"></span></p>

<p><br/></p>

<p><strong>推导规则：</strong></p>

<p>（1）<span data-katex=""></span>包含律：<span data-katex="\frac{\alpha\in\Gamma}{\Gamma\vdash\alpha}"></span></p>

<p>（2）<span data-katex="\neg"></span>消去律：<span data-katex="\frac{\Gamma,\neg\alpha\vdash\beta;\Gamma,\neg\alpha\vdash\neg\beta}{\Gamma\vdash\alpha}"></span></p>

<p>（3）<span data-katex="\to"></span>消去律：<span data-katex="\frac{\Gamma\vdash(\alpha\to\beta);\Gamma\to\alpha}{\Gamma\vdash\beta}"></span></p>

<p>（4）<span data-katex="\to"></span>引入律：<span data-katex="\frac{\Gamma,\alpha\vdash\beta}{\Gamma\vdash\alpha\to\beta}"></span></p>

<p>（5）<span data-katex="\lor"></span>消去律：<span data-katex="\frac{\Gamma,\alpha\vdash\gamma;\Gamma,\beta\vdash\gamma}{\Gamma,\alpha\lor\beta\vdash\gamma}"></span></p>

<p>（6）<span data-katex="\lor"></span>引入律：<span data-katex="\frac{\Gamma\vdash\alpha}{\Gamma\vdash\alpha\lor\beta;\Gamma\vdash\beta\lor\alpha}"></span></p>

<p>（7）<span data-katex="\land"></span>消去律：<span data-katex="\frac{\Gamma\vdash\alpha\land\beta}{\Gamma\vdash\alpha;\Gamma\vdash\beta}"></span></p>

<p>（8）<span data-katex="\land"></span>引入律：<span data-katex="\frac{\Gamma\vdash\alpha;\Gamma\vdash\beta}{\Gamma\vdash\alpha\land\beta}"></span></p>

<p>（9）<span data-katex="\leftrightarrow"></span>消去律：<span data-katex="\frac{\Gamma\vdash\alpha\leftrightarrow\beta;\Gamma\vdash\alpha}{\Gamma\vdash\beta}"></span>，<span data-katex="\frac{\Gamma\vdash\alpha\leftrightarrow\beta;\Gamma\vdash\beta}{\Gamma\vdash\alpha}"></span></p>

<p>（10）<span data-katex="\leftrightarrow"></span>引入律：<span data-katex="\frac{\Gamma,\alpha\vdash\beta;\Gamma,\beta\vdash\alpha}{\Gamma\vdash\alpha\leftrightarrow\beta}"></span></p>

<p><br/></p>

<p><strong>例子：</strong></p>

<p>使用这些推理规则，我们就可以从一些合法的符号串，</p>

<p>推导出另一些合法的符号串了。</p>

<p><br/></p>

<p>（1）<span data-katex="\alpha\to\beta,\beta\to\gamma,\alpha\vdash\alpha\to\beta"></span>：<span data-katex=""></span>包含律</p>

<p>（2）<span data-katex="\alpha\to\beta,\beta\to\gamma,\alpha\vdash\alpha"></span>：<span data-katex=""></span>包含律</p>

<p>（3）<span data-katex="\alpha\to\beta,\beta\to\gamma,\alpha\vdash\beta"></span>：<span data-katex="\to"></span>消去律，式（1），式（2）</p>

<p>（4）<span data-katex="\alpha\to\beta,\beta\to\gamma,\alpha\vdash\beta\to\alpha"></span>：<span data-katex=""></span>包含律</p>

<p>（5）<span data-katex="\alpha\to\beta,\beta\to\gamma,\alpha\vdash\gamma"></span>：<span data-katex="\to"></span>消去律，式（3），式（4）</p>

<p>（6）<span data-katex="\alpha\to\beta,\beta\to\gamma,\alpha\vdash\alpha\to\gamma"></span>：<span data-katex="\to"></span>引入律，式（5）</p>

<p><br/></p>

<p>有了这些以后，我们就可以定义什么是一个<strong>证明</strong>了。</p>

<p><strong>证明序列：</strong></p>

<p>若有限序列，<span data-katex="\Gamma_1\vdash\alpha_1,\Gamma_2\vdash\alpha_2,\cdots ,\Gamma_n\vdash\alpha_n"></span>满足，</p>

<p>（1）<span data-katex="\Gamma_1,\Gamma_2,\cdots ,\Gamma_n"></span>为有限公式集</p>

<p>（2）<span data-katex="\alpha_1,\alpha_2,\cdots ,\alpha_n"></span>为公式</p>

<p>（3）每个<span data-katex="\Gamma_i\vdash\alpha_i(1\leq i\leq n)"></span>都是它之前若干个<span data-katex="\Gamma_j\vdash\alpha_j(1\leq j<i\leq n)"></span>应用某条推导规则得到的</p>

<p><br/></p>

<p>则称这个有限序列为<span data-katex="\Gamma_n\vdash\alpha_n"></span>的一个<strong>（形式）证明序列</strong>。</p>

<p>此时，也称<span data-katex="\alpha_n"></span>可由<span data-katex="\Gamma_n"></span><strong>（形式）证明</strong>，</p>

<p>记为<span data-katex="\Gamma_n\vdash_N\alpha_n"></span>，其中<span data-katex="N"></span>表示自然推理系统。</p>

<p><br/></p>

<h2><strong>逻辑推理</strong></h2>

<p>上文提到的是命题演算的自然推理系统，</p>

<p>这是一个形式系统，我们介绍了它的语法和推导规则，</p>

<p>根据这些推导规则，可以从一些合法的符号串推导出另一些，</p>

<p>在这个基础上，我们定义了什么叫做（形式）证明。</p>

<p><br/></p>

<p>如何<strong>解释</strong>这些符号呢？</p>

<p>它们有什么含义呢？</p>

<p><br/></p>

<p>我们给每一个合法的<strong>公式</strong>指定一个<strong>逻辑命题</strong>，作为这个公式的解释。</p>

<p>为每一个<strong>联接词符号</strong>指定一个<strong>真值函数</strong>，作为这个联接词符号的解释。</p>

<p><br/></p>

<p><strong>命题：</strong></p>

<p>命题是可以判断真假值的句子。</p>

<p><br/></p>

<p><strong>真值函数：</strong></p>

<p><span data-katex="\{0,1\}"></span>上的<span data-katex="n"></span>元函数，<span data-katex="f:\{0,1\}^n\to\{0,1\}"></span></p>

<p>称为一个<span data-katex="n"></span>元真值函数。</p>

<p><br/></p>

<p>我们将每个联接词与一个真值函数一一对应起来，</p>

<p>那么，复合命题的真假值就可以通过子命题的真假值计算出来了。</p>

<p><br/></p>

<p><strong>指派：</strong></p>

<p>设<span data-katex="\alpha"></span>为一个命题，<span data-katex="\alpha"></span>中出现的所有命题变元构成了一个序列<span data-katex="p_1,p_2,\cdots ,p_n"></span>，</p>

<p>对该序列指定的任一真假值序列<span data-katex="t_1,t_2,\cdots ,t_n"></span>称为<span data-katex="\alpha"></span>关于<span data-katex="p_1,p_2,\cdots ,p_n"></span>的一个<strong>指派</strong>，</p>

<p>其中<span data-katex="t_i=0,1"></span>。</p>

<p><br/></p>

<p><strong>真值表：</strong></p>

<p>命题在所有可能的指派下，所取值列成的表，称为真值表。</p>

<p><br/></p>

<p><strong>永真式：</strong></p>

<p>如果命题关于其中出现命题变元的所有指派均为真，则称该命题是一个永真式。</p>

<p><br/></p>

<p>有了这些以后，我们就可以定义<strong>推理</strong>了。</p>

<p>设<span data-katex="\alpha_1,\alpha_2,\cdots ,\alpha_n,\beta"></span>都是命题，</p>

<p>称<strong>推理『<span data-katex="\alpha_1,\alpha_2,\cdots ,\alpha_n"></span>推出<span data-katex="\beta"></span>』是有效的</strong>，</p>

<p>如果对<span data-katex="\alpha_1,\alpha_2,\cdots ,\alpha_n,\beta"></span>中出现的命题变元的任一指派，</p>

<p>若<span data-katex="\alpha_1,\alpha_2,\cdots ,\alpha_n"></span>都为真，则<span data-katex="\beta"></span>也为真，</p>

<p>记为<span data-katex="\alpha_1,\alpha_2,\cdots ,\alpha_n\models\beta"></span></p>

<p>否则，称推理『<span data-katex="\alpha_1,\alpha_2,\cdots ,\alpha_n"></span>推出<span data-katex="\beta"></span>』是无效的。</p>

<p><br/></p>

<p><strong>例子：</strong></p>

<p><span data-katex="\alpha\to\beta,\alpha\models\beta"></span></p>

<p><span data-katex="\alpha\lor\beta,\neg\alpha\models\beta"></span></p>

<p><br/></p>

<h2><strong>证明与推理之间的关系</strong></h2>

<p>命题演算的自然推理系统，有很多性质，其中，</p>

<p><br/></p>

<p><strong>可靠性</strong></p>

<p><span data-katex="\Gamma\vdash\alpha\Rightarrow\Gamma\models\alpha"></span></p>

<p><br/></p>

<p><strong>完备性</strong></p>

<p><span data-katex="\Gamma\models\alpha\Rightarrow\Gamma\vdash\alpha"></span></p>

<p><br/></p>

<p>它们表明，如果一个公式可以被证明，那么它所对应命题的推理就是有效的，</p>

<p>如果某些命题的推理是有效的，那么它就可以被证明。</p>

<p><br/></p>

<p>然而，形式化系统这种研究方法，并不是完美无缺的。</p>

<p><strong>哥德尔不完全性定理</strong></p>

<p>如果<span data-katex="\Gamma"></span>是一个有穷并包含初等算术<span data-katex="\Pi"></span>的形式理论，那么<span data-katex="\Gamma"></span>是一个不完全的形式理论。</p>

<p><br/></p>

<p><strong>哥德尔协调性定理</strong></p>

<p>如果形式理论<span data-katex="\Gamma"></span>包含初等算术<span data-katex="\Pi"></span>，那么<span data-katex="\Pi"></span>的协调性不能在<span data-katex="\Gamma"></span>中被证明。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>证明和推理也是可以研究的，</p>

<p>并且，一直以来都是人们的感兴趣的研究对象。</p>

<p><br/></p>

<p>逻辑学对自动定理证明，程序设计语言中的类型系统，</p>

<p>协议验证，软硬件的安全等领域，</p>

<p>有很重要的理论价值。</p>

<p><br/></p>

<p>以命题逻辑和一阶谓词逻辑为基础，</p>

<p>人们构造出了各式各样种类繁多的逻辑系统，</p>

<p>包括模态逻辑，直觉主义逻辑，时序逻辑，动态逻辑，</p>

<p>多值逻辑，模糊逻辑，非单调逻辑，λ演算，组合逻辑等等。</p>

<p><br/></p>

<p>现代逻辑学已经应用到了越来越多的学科之中。</p>
]]></content>
  </entry>
  
</feed>
