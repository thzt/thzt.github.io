
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>不动点算子与完全偏序 - 何幻</title>
  <meta name="author" content="thzt">

  
  <meta name="description" content="域论模型 类型化lambda演算，有两个常用模型。 其一，域论模型。其二，递归函数论模型。 在众多域论模型中， 主要关心的是一种具有完全偏序（complete partial order）结构的域，简称CPO。 研究它的主要原因是，它是带有不动点算子的模型， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="https://thzt.github.io/blog/2016/06/25/complete-partial-order/" />
  <link type="favicon" rel="shortcut icon" href="/favicon.ico" />
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css" />
  <link href="/atom.xml" rel="alternate" title="何幻" type="application/atom+xml" />
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.aspnetcdn.com/ajax/jQuery/jquery-1.9.1.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">何幻</a></h1>
  
    <h2>Programming is about ideas, languages are just a way to express them.</h2>
  
</hgroup>


<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "//hm.baidu.com/hm.js?33605c59a8749f3e0404d9f438b66667";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>
</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<ul class="main-navigation">
	<li><a href="/">Newest</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">不动点算子与完全偏序</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-06-25T00:00:00+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><script src="/thirdpart/jQuery/jquery-1.11.1.js"></script>


<p><link href="/thirdpart/KaTeX/katex.min.css" rel="stylesheet"/></p>

<script src="/thirdpart/KaTeX/katex.min.js"></script>


<script src="/javascripts/katex.js"></script>


<h2><strong>域论模型</strong></h2>

<p>类型化lambda演算，有两个常用模型。</p>

<p>其一，域论模型。其二，递归函数论模型。</p>

<p><br/></p>

<p>在众多域论模型中，</p>

<p>主要关心的是一种具有完全偏序（complete partial order）结构的域，简称CPO。</p>

<p>研究它的主要原因是，它是带有不动点算子的模型，</p>

<p>而且它还提供了一种解释递归类型表达式的方法。</p>

<p>域论方法是递归函数论模型的基础。</p>

<p><br/></p>

<h2><strong>递归</strong></h2>

<p>加入递归之后，对表达式进行归约就可能会无限的进行下去，</p>

<p>因此将出现没有范式（normal form）的表达式。</p>

<p>于是，把每个表达式指称为一个数值，这种想法就可能有问题了。</p>

<p>下面我们引入不动点算子（fixed-point operator），用来它定义递归。</p>

<p><br/></p>

<p><span data-katex="letrec~f:\sigma=M~in~N"></span></p>

<p>它表示<span data-katex="N"></span>，但是<span data-katex="N"></span>中f的值，是等式<span data-katex="f=M"></span>的解。</p>

<p>而<span data-katex="M"></span>中可能会包含<span data-katex="f"></span>。</p>

<p><span data-katex="M"></span>的类型根据等式<span data-katex="f=M"></span>也是<span data-katex="\sigma"></span>。</p>

<p><br/></p>

<p>我们将看到，<span data-katex="letrec"></span>是<span data-katex="let"></span>与不动点算子的语法糖（syntactic sugar）。</p>

<p>首先，我们先用<span data-katex="letrec"></span>定义阶乘函数，来计算<span data-katex="5!"></span>。</p>

<p><span data-katex="letrec~f:nat\rightarrow nat=\lambda y:nat.~(if~Eq?~y~0~then~1~else~y*f(y-1))~in~f~5"></span></p>

<p><br/></p>

<p>其中<span data-katex="f"></span>是下列等式的解。</p>

<p><span data-katex="f=\lambda y:nat.~if~Eq?~y~0~then~1~else~y*f(y-1)"></span></p>

<p><br/></p>

<h2><strong>不动点算子</strong></h2>

<p>从数学的角度来看，并不是所有形如<span data-katex="f:\sigma =M"></span>的等式都有解，</p>

<p>如果有多个解，也不知道选择哪个解。</p>

<p>我们先假设每个这样的等式都有解，为此我们增加一个不动点算子来得到这个解。</p>

<p><br/></p>

<p>一般的，如果<span data-katex="F:\sigma \rightarrow \sigma"></span>是某一类型到自身的函数。</p>

<p>那么<span data-katex="F"></span>的一个不动点，是使得<span data-katex="x=F(x)"></span>的值<span data-katex="x:\sigma"></span>。</p>

<p><br/></p>

<p>经过观察我们发现，阶乘函数<span data-katex="f"></span>是以下函数的<span data-katex="F"></span>的不动点，即满足<span data-katex="f=F(f)"></span>。</p>

<p><span data-katex="F=_{def}\lambda f:nat\rightarrow nat.~\lambda y:nat.~if~Eq?~y~0~then~1~else~y*f(y-1)"></span></p>

<p>其中，<span data-katex="f:nat\rightarrow nat"></span>，<span data-katex="F:(nat\rightarrow nat)\rightarrow (nat\rightarrow nat)"></span></p>

<p><br/></p>

<p>我们定义，<span data-katex="fix_\sigma :(\sigma \rightarrow \sigma )\rightarrow \sigma"></span>，是对应于每个类型<span data-katex="\sigma"></span>的不动点算子。</p>

<p>满足的如下等式公理，</p>

<p><span data-katex="fix_\sigma =\lambda f:\sigma \rightarrow \sigma .~f(fix_\sigma f)"></span></p>

<p><br/></p>

<p>可知，对任意的<span data-katex="F:\sigma \rightarrow \sigma"></span>，<span data-katex="fix_\sigma F"></span>是<span data-katex="F"></span>的不动点，即，</p>

<p><span data-katex="fix_\sigma F=F(fix_\sigma F)"></span></p>

<p><br/></p>

<p>我们就可以用<span data-katex="let"></span>和<span data-katex="fix_\sigma"></span>表示<span data-katex="letrec"></span>了。</p>

<p><span data-katex="letrec~f:\sigma =M~in~N=_{def}let~f:\sigma =(fix_\sigma \lambda f:\sigma .~M)~in~N"></span></p>

<p><br/></p>

<h2><strong>归约</strong></h2>

<p>我们以阶乘函数为例，来说明带有不动点算子的表达式是如何归约的。</p>

<p>为了行文方便，我们省略<span data-katex="fix_{nat\rightarrow nat}"></span>的下标，直接记为<span data-katex="fix"></span>。</p>

<p>定义阶乘函数<span data-katex="fact=_{def}fix~F"></span>，其中，</p>

<p><span data-katex="F=_{def}\lambda f:nat\rightarrow nat.~\lambda y:nat.~if~Eq?~y~0~then~1~else~y*f(y-1)"></span></p>

<p><br/></p>

<p>我们来计算<span data-katex="fact~n"></span>。</p>

<p><span data-katex="fact~n=(fix~F)~n"></span></p>

<p><span data-katex="=((\lambda f:nat\rightarrow nat.~f(fix~f))~F)~n"></span></p>

<p><span data-katex="=(F~(fix~F))~n"></span></p>

<p><span data-katex="=((\lambda f:nat\rightarrow nat.~\lambda y:nat.~if~Eq?~y~0~then~1~else~y*f(y-1))~(fix~F))~n"></span></p>

<p><span data-katex="=(if~Eq?~n~0~then~1~else~n*(fix~F))~(n-1)"></span></p>

<p><br/></p>

<h2><strong>无法终止的运算</strong></h2>

<p>由于递归允许我们写出没有范式的表达式，</p>

<p>所以我们相应的必须给这样的表达式赋予含义。</p>

<p><br/></p>

<p>例如，</p>

<p><span data-katex="letrec~f:nat\rightarrow nat=\lambda x:nat.~f(x+1)~in~f~3"></span></p>

<p>尽管该表达式的类型是<span data-katex="nat"></span>，但是我们无法把它简化为一个数值。</p>

<p>所以该表达式的含义就不是一个自然数了。</p>

<p><br/></p>

<p>一方面，认为该表达式的类型是<span data-katex="nat"></span>是合理的，它是类型规则的推导结论。</p>

<p>另一方面，如果我们说该表达式的值是『未定义的』，</p>

<p>那么<span data-katex="f"></span>的语义就变成了部分函数（partial function）。</p>

<p><br/></p>

<p>我们不如给自然数集附加一个值<span data-katex="\perp _{nat}"></span>，</p>

<p>用来表示类型<span data-katex="nat"></span>上无法终止的运算（nonterminating computation）。</p>

<p>这给了我们一个把部分函数看成完全函数（total function）的方法。</p>

<p><br/></p>

<h2><strong>CPO</strong></h2>

<p><strong>偏序</strong></p>

<p>一个偏序（partial order）<span data-katex="\left \langle D,\leqslant  \right \rangle"></span>是一个集合<span data-katex="D"></span>，以及集合上的一个关系（relation）<span data-katex="\leqslant"></span>，</p>

<p>这个关系具有自反性，反对称性，和传递性。</p>

<p><br/></p>

<p>若对于任意<span data-katex="d\in D"></span>有<span data-katex="d\leqslant d"></span>，则称<span data-katex="\leqslant"></span>具有自反性（reflexive）。</p>

<p>若<span data-katex="a\leqslant b"></span>且<span data-katex="b\leqslant a"></span>有<span data-katex="a=b"></span>，则称<span data-katex="\leqslant"></span>具有反对称性（anti-symmetric）。</p>

<p>若<span data-katex="a\leqslant b"></span>且<span data-katex="b\leqslant c"></span>有<span data-katex="a\leqslant c"></span>，则称<span data-katex="\leqslant"></span>具有传递性（transitive）。</p>

<p><br/></p>

<p><strong>上界与最小上界</strong></p>

<p>如果<span data-katex="\left \langle D,\leqslant  \right \rangle"></span>是一个偏序，则子集<span data-katex="S\subseteq D"></span>的上界（upper bound），</p>

<p>是<span data-katex="D"></span>中的一个元素<span data-katex="x\in D"></span>，使得对于任意的<span data-katex="y\in S"></span>有<span data-katex="y\leqslant x"></span>。</p>

<p>最小上界（least upper bound）是那个<span data-katex="\leqslant"></span>任何其它上界的元素。</p>

<p><br/></p>

<p><strong>有向集</strong></p>

<p>如果<span data-katex="\left \langle D,\leqslant  \right \rangle"></span>是一个偏序，称子集<span data-katex="S\subseteq D"></span>是有向的（directed），</p>

<p>如果<span data-katex="S"></span>的每一个有限子集<span data-katex="S_0\subseteq S"></span>在<span data-katex="S"></span>中都有上界。</p>

<p>有向集（directed set）的一个性质是，所有有向集都非空。</p>

<p><br/></p>

<p><strong>完全偏序</strong></p>

<p>完全偏序（complete partial order）简称CPO，它是一个偏序<span data-katex="\left \langle D,\leqslant  \right \rangle"></span>，</p>

<p>且每一个有向子集<span data-katex="S\subseteq D"></span>都有最小上界，我们把这个最小上界记为<span data-katex="\bigvee S"></span>。</p>

<p>可证，任何一个有限的偏序，都是完全偏序。</p>

<p><br/></p>

<p>一个不是CPO的例子是自然数集，自然数集<span data-katex="N"></span>本身是有向的，但没有最小上界。</p>

<p>如果我们加入一个比其他自然数都大的元素<span data-katex="\infty"></span>，我们就得到了一个CPO。</p>

<p><br/></p>

<h2><strong>CPO的提升</strong></h2>

<p><strong>有奇点的CPO</strong></p>

<p>如果<span data-katex="\mathscr{D}=\left \langle D,\leqslant  \right \rangle"></span>是一个有最小元（least element）的偏序，</p>

<p>则称为<span data-katex="\mathscr{D}"></span>是有奇点（pointed）的，我们用<span data-katex="\perp _D"></span>表示<span data-katex="D"></span>的最小元。</p>

<p><br/></p>

<p><strong>提升集</strong></p>

<p>对于任意的集合<span data-katex="A"></span>，我们构建一个CPO，<span data-katex="A_\perp =\left \langle A\cup \{\perp \} ,\leqslant  \right \rangle"></span>，</p>

<p>其中，<span data-katex="x\leqslant y"></span>当且仅当<span data-katex="x=\perp"></span>或<span data-katex="x=y"></span>。</p>

<p>我们称<span data-katex="A_\perp"></span>为<span data-katex="A"></span>的提升集（lifted set）。</p>

<p><br/></p>

<p>用这个方法，我们可以提升任何一个CPO，<span data-katex="\mathscr{D}=\left \langle D,\leqslant _D  \right \rangle"></span>，</p>

<p>得到<span data-katex="\mathscr{D}_\perp =\left \langle D\cup \{\perp \},\leqslant \right \rangle"></span>，</p>

<p>其中<span data-katex="\perp"></span>与<span data-katex="D"></span>中的任何元素都不等，新的序关系<span data-katex="x\leqslant y"></span>当且仅当<span data-katex="x=\perp"></span>或<span data-katex="x\leqslant _D y"></span>。</p>

<p><br/></p>

<p>可证，如果<span data-katex="\mathscr{D}"></span>是一个CPO，则<span data-katex="\mathscr{D}_\perp"></span>是一个有奇点的CPO。</p>

<p><br/></p>

<h2><strong>连续函数</strong></h2>

<p><strong>单调函数</strong></p>

<p>设<span data-katex="\mathscr{D}=\left \langle D,\leqslant _D \right \rangle"></span>和<span data-katex="\mathscr{E}=\left \langle E,\leqslant _E \right \rangle"></span>是CPO，</p>

<p><span data-katex="f:D\rightarrow E"></span>是集合<span data-katex="D"></span>到<span data-katex="E"></span>的一个函数，我们说<span data-katex="f"></span>是单调的（monotonic），</p>

<p>如果<span data-katex="a\leqslant b"></span>就有<span data-katex="f(a)\leqslant f(b)"></span>。</p>

<p><br/></p>

<p><strong>连续函数</strong></p>

<p>一个单调函数<span data-katex="f"></span>是连续的（continuous），如果对于任意有向子集<span data-katex="S\subseteq D"></span>，有<span data-katex="f(\bigvee S)=\bigvee f(S)"></span>。</p>

<p><br/></p>

<p><strong>提升函数</strong></p>

<p>我们定义<span data-katex="f:D\rightarrow E"></span>对应的提升函数（lifted function）为<span data-katex="f_\perp =(D\cup\{ \perp \})\rightarrow (E\cup\{ \perp \})"></span>。</p>

<p>其中，如果<span data-katex="a\in D"></span>，则<span data-katex="f_\perp (a)=f(a)"></span>，否则<span data-katex="f_\perp (a)=\perp"></span>。</p>

<p><br/></p>

<p><strong>函数集构成CPO</strong></p>

<p>假设<span data-katex="\mathscr{D}=\left \langle D,\leqslant _D \right \rangle"></span>和<span data-katex="\mathscr{E}=\left \langle E,\leqslant _E \right \rangle"></span>是CPO，</p>

<p>对于连续函数<span data-katex="f,g:D\rightarrow E"></span>，我们称<span data-katex="f\leqslant_{D\rightarrow E} g"></span>，如果对于任意<span data-katex="d\in D"></span>，都有<span data-katex="f(d)\leqslant _E g(d)"></span>。</p>

<p>于是，所有这些连续函数构成了一个CPO，记为<span data-katex="\mathscr{D}\rightarrow \mathscr{E}=\left \langle D\rightarrow E,\leqslant _{D\rightarrow E} \right \rangle"></span>。</p>

<p><br/></p>

<h2><strong>最小不动点</strong></h2>

<p>我们称<span data-katex="a"></span>是<span data-katex="f"></span>的最小不动点（least fixed point），</p>

<p>如果<span data-katex="a=f(a)"></span>且对于任意的<span data-katex="b=f(b)"></span>，我们有<span data-katex="a\leqslant b"></span>。</p>

<p><br/></p>

<p>如果<span data-katex="\mathscr{D}"></span>是一个有奇点的CPO，且<span data-katex="f:D\rightarrow D"></span>是连续的，则<span data-katex="f"></span>有最小不动点，</p>

<p><span data-katex="fix_D f=\bigvee \{ f^n(\perp )~|~n\geqslant 0 \}"></span>，</p>

<p>且<span data-katex="fix_D"></span>是连续的。</p>

<p><br/></p>

<p>例如，设<span data-katex="\mathscr{D}=\left \langle D,\leqslant _D \right \rangle"></span>是有奇点的CPO，则恒等函数<span data-katex="id:D\rightarrow D"></span>的最小不动点是<span data-katex="\perp _D"></span>。</p>

<p><span data-katex="fix_D~id=\bigvee \{ id^n(\perp _D)~|~n\geqslant 0 \}=\bigvee \{ \perp _D \}=\perp _D"></span></p>

<h2><strong>结语</strong></h2>

<p>初等数学中，某些函数是没有不动点的。</p>

<p>那么在什么情况下，形如<span data-katex="f:\sigma =M"></span>的表达式有解呢？</p>

<p>定义了递归之后，对类型化lambda演算的模型产生了什么影响呢？</p>

<p><br/></p>

<p>这是一直以来我心中是一个问题。</p>

<p>诚然，类型化lambda演算有不同的解释方式，但以上域论模型通俗易懂，</p>

<p>也算是告一段落吧，以后的路还长着呢。</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">thzt</span></span>

      




<time class='entry-date' datetime='2016-06-25T00:00:00+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>12:00 am</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/math/'>math</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2016/06/08/algebraic-data-type/" title="Previous Post: 代数数据类型的语法和语义">&laquo; 代数数据类型的语法和语义</a>
      
      
        <a class="basic-alignment right" href="/blog/2016/07/01/the-way-to-express/" title="Next Post: 重在表达">重在表达 &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
	<h1>Categories</h1>
	<ul id="categories">
		<li class='category'><a href='/blog/categories/design/'>design (13)</a></li>
<li class='category'><a href='/blog/categories/haskell/'>haskell (6)</a></li>
<li class='category'><a href='/blog/categories/lisp/'>lisp (17)</a></li>
<li class='category'><a href='/blog/categories/logic/'>logic (4)</a></li>
<li class='category'><a href='/blog/categories/math/'>math (5)</a></li>
<li class='category'><a href='/blog/categories/mind/'>mind (37)</a></li>
<li class='category'><a href='/blog/categories/software/'>software (12)</a></li>

	</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/09/07/the-bias-of-the-author/">为什么作者无法不持有偏见</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/09/03/weakness/">性格的弱点</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/24/believed-in-the-absence-of-evidence/">相信不证自明</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/18/imagination/">思路和想象力</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/13/about-topology/">拓扑学拾趣</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/05/professional-programmer/">专业程序猿的修炼指南</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/02/cohomology-group/">懵逼的上同调群</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/07/23/computability/">可计算性理论名词释义</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/07/18/overcome-the-limitation/">挑战极限</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/07/01/the-way-to-express/">重在表达</a>
      </li>
    
  </ul>
</section>

<section>
	<h1>GitHub Repos</h1>
	
	
    <ul>
        <li><a href="https://github.com/thzt">@thzt</a> on GitHub</li>
    </ul>
	
	
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - thzt -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
