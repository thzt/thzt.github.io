
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Scheme元编程 - 何幻</title>
  <meta name="author" content="thzt">

  
  <meta name="description" content="很多语言都已经支持了元编程，那么Lisp就丧失优势了吗？并没有。因为，S表达式仍然是表达同相性的巧妙选择。">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="https://thzt.github.io/blog/2015/09/21/define-syntax/" />
  <link type="favicon" rel="shortcut icon" href="/favicon.ico" />
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css" />
  <link href="/atom.xml" rel="alternate" title="何幻" type="application/atom+xml" />
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.aspnetcdn.com/ajax/jQuery/jquery-1.9.1.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">何幻</a></h1>
  
    <h2>Programming is about ideas, languages are just a way to express them.</h2>
  
</hgroup>


<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "//hm.baidu.com/hm.js?33605c59a8749f3e0404d9f438b66667";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>
</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<ul class="main-navigation">
	<li><a href="/">Newest</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Scheme元编程</h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-09-21T00:00:00+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>21</span><span class='date-suffix'>st</span>, <span class='date-year'>2015</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


<div class="entry-content"><p><a href="https://en.wikipedia.org/wiki/Homoiconicity">同相性</a>，指的是，</p>

<p>程序和程序所操作的数据采用了统一编码。</p>

<p><br/></p>

<p>Lisp语言使用了S表达式，</p>

<p>例如，(fn x)</p>

<p>既可以看做是程序，用参数x调用函数fn，</p>

<p>也可以看做是数据，由符号fn和符号x构成的列表。</p>

<p><br/></p>

<p><strong>同相性使得我们，可以像处理数据一样处理代码。</strong></p>

<p>做一些代码转换之类的工作，十分简单。</p>

<p><br/></p>

<p>例如，</p>

<p>当遇到(fn x)时，</p>

<p>我们可以让它先转换成，</p>

<p>(begin</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(display x)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(gn x))</p>

<p>然后再执行。</p>

<p><br/></p>

<p>甚至也可以用来定义变量，</p>

<p>(define-with-display (f a)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(g a))</p>

<p><br/></p>

<p>转换成，</p>

<p>(define (f a)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(display a)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(g a))</p>

<p><br/></p>

<p>这种代码层面的转换称为“宏”(macro)。</p>

<p><br/></p>

<h2><strong>定义一个宏</strong></h2>

<p>Scheme是Lisp的一个简洁方言，</p>

<p>它使用define-syntax来定义宏。</p>

<p><br/></p>

<p>本质上，宏是一个特殊的标识符，</p>

<p>它关联了转换器函数。</p>

<p><br/></p>

<p>表达式的求值过程，分为了3个阶段，</p>

<p>读取期，宏展开期，运行期。</p>

<p><br/></p>

<p>在遇到宏调用的时候，</p>

<p>Scheme会先调用与之关联的转换器，进行代码转换，(宏展开期)</p>

<p><strong>然后再求值结果表达式</strong>。(运行期)</p>

<p><br/></p>

<p>在解释器中，宏展开和表达式求值可能是交替进行的，</p>

<p>而在编译器中，他们是两个独立的阶段。</p>

<p><br/></p>

<p>(define-syntax or</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules ()</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_) #f]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_ e) e]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_ e1 e2 e3 &hellip;)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (let ([t e1]) (if t t (or e2 e3 &hellip;)))]))</p>

<p><br/></p>

<p>以上代码定义了一个宏，or，</p>

<p>它用来对(or &hellip;)表达式进行变换。</p>

<p><br/></p>

<p>(or)转换成了#f</p>

<p>(or a)转换成了a</p>

<p>(or a b)转换成了(let ([t a]) (if t t (or b)))</p>

<p><br/></p>

<p>我们看到，</p>

<p>宏展开是支持递归调用的。</p>

<p><br/></p>

<h2><strong>模式匹配</strong></h2>

<p>syntax-rules使用了模式匹配来定义转换器，</p>

<p>它的每一条语句给定了形如“[模式 模板]”的转换规则，</p>

<p>如果模式匹配成功了，</p>

<p>就按着模板的方式进行转换。</p>

<p><br/></p>

<p>[(_ e) e]</p>

<p><br/></p>

<p>其中，</p>

<p>模式是(_ e)，</p>

<p>模板是e，</p>

<p>“_”表示通配符。</p>

<p><br/></p>

<p>这个模式匹配了(or e)，</p>

<p>转换结果为e，</p>

<p>即它能把(or a)转换成a。</p>

<p><br/></p>

<p>我们再来看(_ e1 e2 e3 &hellip;)，</p>

<p>其中的省略号“&hellip;”，</p>

<p><strong>并不是为了演示方便故意省略了。</strong></p>

<p><br/></p>

<p>“&hellip;”是一个标识符，是模式匹配的一部分，</p>

<p>它用来代表“和前面一样的匹配”。</p>

<p>模板中也出现了“&hellip;”，</p>

<p>它会根据模式中“&hellip;”来进行填充。</p>

<p><br/></p>

<p>Scheme中使用的模式匹配，是一个庞大的主题，</p>

<p>甚至<strong>模式匹配已经构成了一门新的语言，</strong></p>

<p>TSPL4中进行了详细的解释，<a href="http://www.scheme.com/tspl4/syntax.html#./syntax:h2">Syntax-Rules Transformers</a></p>

<p><br/></p>

<h2><strong>转换器函数</strong></h2>

<p>另外一种定义宏的方式是，</p>

<p>显式的指定宏展开器函数。</p>

<p><br/></p>

<p>(define-syntax r</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(lambda (x)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display x)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(display &ldquo;\n&rdquo;)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#t))</p>

<p><br/></p>

<p>我们用lambda定义了一个匿名函数，</p>

<p>并让它与宏标识符r相关联。</p>

<p><br/></p>

<p>我们直接在REPL中看看r是什么，</p>

<p><br/></p>

<p>#&lt;syntax r&gt;</p>

<p>#t</p>

<p><br/></p>

<p>第一行是(display x)副作用，</p>

<p>可见x的值是#&lt;syntax r&gt;，称为<strong>语法对象</strong>(syntax object)。</p>

<p><br/></p>

<p>然后r被转换成#t，</p>

<p>第二行是REPL中打印了#t的值。</p>

<p><br/></p>

<p>为了处理转换器中匹配到的语法对象，</p>

<p>Scheme语言提供了syntax-case特殊形式。</p>

<p><br/></p>

<p>(define-syntax or</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(lambda (x)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case x ()</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_) #&lsquo;#f]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_ e) #&lsquo;e]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_ e1 e2 e3 &hellip;)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&lsquo;(let ([t e1]) (if t t (or e2 e3 &hellip;)))])))</p>

<p><br/></p>

<p>它使用了与syntax-rules相同的模式匹配规则，</p>

<p>不同的是，我们还需要<strong>显式构造模板中的语法对象</strong>。</p>

<p><br/></p>

<p>对于宏调用(or a b)来说，x的值是#&lt;syntax (or a b)&gt;，</p>

<p><strong>syntax-case会先求值x，然后解开语法对象的封装</strong>，得到(or a b)，</p>

<p>再进行模式匹配。</p>

<p><br/></p>

<h2><strong>语法对象</strong></h2>

<p>语法对象，包装了标识符的作用域信息。</p>

<p><br/></p>

<p>我们知道Scheme的宏是卫生的(hygienic)，</p>

<p><strong>宏展开后的标识符还处在其来源处的词法作用域中，</strong></p>

<p>为了达成这个目的，作用域信息就要被保存起来。</p>

<p><br/></p>

<p>Scheme的不同实现有不同的做法，</p>

<p><a href="http://www.scheme.com/download/">Petite Chez Scheme</a>使用了<strong>语法对象</strong>进行封装。</p>

<p><br/></p>

<p>语法对象由syntax特殊形式创建，(syntax e)</p>

<p>#&lsquo;e是它的简写，</p>

<p>在程序的读取阶段会被展开为(syntax e)。</p>

<p><br/></p>

<p>前文我们说，</p>

<p>“模式匹配构成了一门新的语言”，并不为过，</p>

<p>因为#&lsquo;有很多规则(<strong>坑</strong>)需要我们了解。</p>

<p><br/></p>

<p>（1）出现在“模式”中的变量，称为模式变量(pattern variable)，</p>

<p><strong>模式变量的值是它匹配的值</strong>。</p>

<p>例如：(_ a b)匹配(or x y)，a和b就是模式变量，a的值是x，b的值是y</p>

<p><br/></p>

<p>（2）#&lsquo;e的值是一个语法对象，<strong>e可以是模式变量也可以不是</strong>。</p>

<p>如果e是模式变量，则值为#&lt;syntax e匹配的值&gt;，</p>

<p>如果e不是模式变量，则值为#&lt;syntax e&gt;。</p>

<p><br/></p>

<p>（3）“模板”中的模式变量，必须出现在#&lsquo;或者#&rsquo;(&hellip;)中，<strong>不能裸写</strong>。</p>

<p><a href="http://www.scheme.com/tspl4/syntax.html#./syntax:h3">Pattern variables, however, can be referenced only within syntax expressions</a></p>

<p><br/></p>

<p>（4）<strong>#&lsquo;(a b)不是一个语法对象，而是由语法对象构成的列表</strong>，(#'a #'b)</p>

<p>例如：[(_ a) #&lsquo;(a b)]，结果是(#&lt;syntax a匹配的值&gt; #&lt;syntax b&gt;)</p>

<p>注意到b不是模式变量。</p>

<p><br/></p>

<p>（5）多层#&lsquo;，读取器会先将每一层展开成(syntax &hellip;)再求值。</p>

<p>例如：#&lsquo;#'a实际上是(syntax (syntax a))，</p>

<p>求值为(#&lt;syntax syntax&gt; (#&lt;syntax syntax&gt; #&lt;syntax a匹配的值&gt;))。</p>

<p>注意到syntax不是模式变量。</p>

<p><br/></p>

<h2><strong>可以定义宏的宏</strong></h2>

<p>syntax-rules是用来定义宏的，</p>

<p>然而，它也是一个宏，它最终被展开为syntax-case。</p>

<p><br/></p>

<p>(define-syntax syntax-rules</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(lambda (x)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case x ()</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_ (i &hellip;) ((keyword . pattern) template) &hellip;)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&lsquo;(lambda (x)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (syntax-case x (i &hellip;)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [(_ . pattern) #&lsquo;template] &hellip;))])))</p>

<p><br/></p>

<p>syntax-rules的目的，</p>

<p>是为了避免显式的书写lambda和#&lsquo;。</p>

<p><br/></p>

<p>像这种生成syntax-case的宏还有很多，</p>

<p>例如，with-syntax。</p>

<p><br/></p>

<p>(define-syntax with-syntax</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(lambda (x)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(syntax-case x ()</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_ ((p e) &hellip;) b1 b2 &hellip;)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&lsquo;(syntax-case (list e &hellip;) ()</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [(p &hellip;) (let () b1 b2 &hellip;)])])))</p>

<p><br/></p>

<p>with-syntax的目的，</p>

<p>是把匹配条件写在一起，</p>

<p>最后输出到一个模板中。</p>

<p><br/></p>

<p>从这里我们可以看到，</p>

<p>syntax-case第一个参数的值，</p>

<p>可以是语法对象的列表。</p>

<p><br/></p>

<p>syntax-case会对列表中的语法对象，</p>

<p>解除#&lt;syntax &hellip;&gt;的封装，</p>

<p>然后再进行模式匹配。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>Lisp的宏非常强大，</p>

<p>很多人只是听说过，</p>

<p>没有切身使用过，</p>

<p>隐约觉得宏可以解决任何问题。</p>

<p><br/></p>

<p>其实不然，</p>

<p><strong>Lisp宏只是做了一些代码的变换，</strong></p>

<p><strong>简化了已完成功能的描述方式。</strong></p>

<p><br/></p>

<p>本文对Scheme宏的定义和使用做了简单介绍，</p>

<p>希望能揭开它的神秘面纱。</p>
</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">thzt</span></span>

      




<time class='entry-date' datetime='2015-09-21T00:00:00+08:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>21</span><span class='date-suffix'>st</span>, <span class='date-year'>2015</span></span> <span class='time'>12:00 am</span></time>
      

<span class="categories">
  
    <a class='category' href='/blog/categories/lisp/'>lisp</a>
  
</span>


    </p>
    
      <div class="sharing">
  
  
  
</div>

    
    <p class="meta">
      
        <a class="basic-alignment left" href="/blog/2015/09/11/reuse-oriented-programming/" title="Previous Post: 消除重复与可复用相距多远">&laquo; 消除重复与可复用相距多远</a>
      
      
        <a class="basic-alignment right" href="/blog/2015/10/12/different-premise/" title="Next Post: 不同的前提">不同的前提 &raquo;</a>
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
	<h1>Categories</h1>
	<ul id="categories">
		<li class='category'><a href='/blog/categories/design/'>design (15)</a></li>
<li class='category'><a href='/blog/categories/haskell/'>haskell (6)</a></li>
<li class='category'><a href='/blog/categories/lisp/'>lisp (17)</a></li>
<li class='category'><a href='/blog/categories/logic/'>logic (4)</a></li>
<li class='category'><a href='/blog/categories/math/'>math (5)</a></li>
<li class='category'><a href='/blog/categories/mind/'>mind (37)</a></li>
<li class='category'><a href='/blog/categories/software/'>software (12)</a></li>

	</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/09/21/abstraction/">抽象与现实</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/09/12/the-secrets-of-decision-making/">决策的秘密</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/09/07/the-bias-of-the-author/">为什么作者无法不持有偏见</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/09/03/weakness/">性格的弱点</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/24/believed-in-the-absence-of-evidence/">相信不证自明</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/18/imagination/">思路和想象力</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/13/about-topology/">拓扑学拾趣</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/05/professional-programmer/">专业程序猿的修炼指南</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/02/cohomology-group/">懵逼的上同调群</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/07/23/computability/">可计算性理论名词释义</a>
      </li>
    
  </ul>
</section>

<section>
	<h1>GitHub Repos</h1>
	
	
    <ul>
        <li><a href="https://github.com/thzt">@thzt</a> on GitHub</li>
    </ul>
	
	
</section>





  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - thzt -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
