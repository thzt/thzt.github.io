
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>何幻</title>
  <meta name="author" content="thzt">

  
  <meta name="description" content="宏（macro）是Lisp语言进行元编程的手段， 它分为两种，读取宏（read macro）和编译宏（compilation macro）。 可以用来编写读取期和编译期运行的代码。 宏，事实上进行了代码的转换。 每一个宏都与一个转换器（transformer）相关联。 代码转换后， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="https://thzt.github.io/posts/51/" />
  <link type="favicon" rel="shortcut icon" href="/favicon.ico" />
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css" />
  <link href="/atom.xml" rel="alternate" title="何幻" type="application/atom+xml" />
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.aspnetcdn.com/ajax/jQuery/jquery-1.9.1.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.useso.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.useso.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">何幻</a></h1>
  
    <h2>Programming is about ideas, languages are just a way to express them.</h2>
  
</hgroup>


<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "//hm.baidu.com/hm.js?33605c59a8749f3e0404d9f438b66667";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>
</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<ul class="main-navigation">
	<li><a href="/">Newest</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/03/22/hygienic-macro/">简介卫生宏</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-03-22T00:00:00+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>22</span><span class='date-suffix'>nd</span>, <span class='date-year'>2015</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>宏（macro）是Lisp语言进行元编程的手段，</p>

<p>它分为两种，读取宏（read macro）和编译宏（compilation macro）。</p>

<p>可以用来编写读取期和编译期运行的代码。</p>

<p><br/></p>

<p>宏，事实上进行了代码的转换。</p>

<p>每一个宏都与一个转换器（transformer）相关联。</p>

<p>代码转换后，会替换到原来的位置。</p>

<p>这个过程，称为宏展开（expansion）。</p>

<p><br/></p>

<p>区分读取期，编译期和运行期，是很重要的。</p>

<p>这是3个独立的阶段，</p>

<p>尤其在运行期，不存在任何未展开的宏。</p>

<p><br/></p>

<p>我们使用“a -> b”来表示，表达式a展开为b。</p>

<p>而使用“a => b”表示，表达式a的值为b。</p>

<p><br/></p>

<p>例子：</p>

<p>&lsquo;a -> (quote a)，其中“'”是一个读取宏。</p>

<p>读取宏可以将任意表达式转换为S表达式。</p>

<p><br/></p>

<p>很多常见的表达式调用，其实是编译宏。</p>

<p>(and test1 test2) -> (if test1 test2 #f)</p>

<p>编译宏可以将一个S表达式转换为另一个S表达式。</p>

<p><br/></p>

<p>我们通常说的宏，指的是编译宏。</p>

<p>Scheme语言暂时不支持自定义的读取宏。</p>

<p><br/></p>

<h2><strong>定义一个宏</strong></h2>

<p>Scheme语言中使用define-syntax来定义宏，</p>

<p>定义一个宏，有时也称为绑定一个关键字（keyword binding）。</p>

<p>宏展开的结果，最终都转换成了一些Scheme语言内置的表达式。</p>

<p><br/></p>

<p>例如：宏and是这样的定义的，</p>

<p>(define-syntax and</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(syntax-rules ()</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(and) #t]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(and test) test]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(and test1 test2 &hellip;)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(if test1</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(and test2 &hellip;)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#f)]))</p>

<p><br/></p>

<p>其中，(syntax-rules &hellip;)的值是一个转换器。</p>

<p>define-syntax将关键字and和这个转换器相关联。</p>

<p><br/></p>

<p>Scheme语言中有很多表达式可以返回转换器，</p>

<p>而syntax-rules是最常用的一个。</p>

<p>它内置了一个模板语言（pattern language）</p>

<p><br/></p>

<p>syntax-rules后面紧跟的一个括号，里面可以设置辅助关键字。</p>

<p>至于辅助关键字，可以参考Scheme语言手册了解使用情况。</p>

<p><br/></p>

<p>后续的每一个表达式，都具有“[模式，模板]”这样的结构。</p>

<p>对于[(and) #t]来说，</p>

<p>模式 = (and)</p>

<p>模板 = #t</p>

<p><br/></p>

<p>模式和模板中的“&hellip;”是syntax-rules模板语言的一部分。</p>

<p>具体用法，也可以参考Scheme语言手册。</p>

<p><br/></p>

<p>如果宏调用匹配了某个模式，就会按照相应模板展开。</p>

<p>下面3个宏调用，展开结果如下：</p>

<p>(and) -> #t</p>

<p>(and x) -> x</p>

<p>(and x y) -> (if x (and y) #f) -> (if x y #f)</p>

<p><br/></p>

<p>宏是可以递归展开的，一直到结果表达式中不再含有宏为止。</p>

<p><br/></p>

<p>模式中的第一个元素，因为肯定是宏的名字，</p>

<p>所以也可以替换成通配符“_”，</p>

<p>[(_) #t]</p>

<p>[(_ test) test]</p>

<p><br/></p>

<h2><strong>卫生宏</strong></h2>

<p>Scheme是第一个支持卫生宏（hygienic macro）的Lisp方言。</p>

<p>也是第一个支持卫生宏的编程语言。</p>

<p><br/></p>

<p>“卫生”这个词表示，宏展开后，不会污染原来的词法作用域。</p>

<p>我们还是举例来说明吧，最后，我们再总结规律。</p>

<p><br/></p>

<p>例1：宏展开后，原表达式处于新的词法环境中。</p>

<p>(let-syntax [(insert-binding (syntax-rules ()</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(_ x) (let [(a 1)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+ x a))]))]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(let [(a 2)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(insert-binding (+ a 3))))</p>

<p>=> 6</p>

<p><br/></p>

<p>其中，let-syntax用来绑定局部关键字。</p>

<p>就像let可用来绑定局部变量一样。</p>

<p><br/></p>

<p>在let-syntax表达式内部，我们定义了宏insert-binding。</p>

<p>它绑定到syntax-rules求值后得到的转换器上。</p>

<p><br/></p>

<p>根据定义，我们知道(insert-binding x) -> (let [(a 1)] (+ x a))</p>

<p>原表达式x，处于含有新的绑定a => 1的词法环境中。</p>

<p><br/></p>

<p>如果原表达式x中含有a，就出现问题了。</p>

<p>我们的例子就是这种情况。</p>

<p><br/></p>

<p>(let [(a 2)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(insert-binding (+ a 3)))</p>

<p>-></p>

<p>(let [(a 2)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(let [(a 1)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+ (+ a 3) a)))</p>

<p>=> 5</p>

<p><br/></p>

<p>结果出错了。</p>

<p>从(+ a 3)所在的原始词法环境来看，</p>

<p>(let [(a 2)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(insert-binding (+ a 3)))</p>

<p>(+ a 3)中a的值，应该是2才对。</p>

<p>宏展开污染了原始的词法环境。</p>

<p><br/></p>

<p>这是不“卫生”的。</p>

<p>Scheme通过给绑定的值改名字来实现卫生宏。</p>

<p><br/></p>

<p>宏展开(insert-binding x) -> (let [(a 1)] (+ x a))</p>

<p>改成了(insert-binding x) -> (let [(:g0001 1)] (+ x :g0001))</p>

<p>其中，:g0001是语言实现生成的唯一名字，不会与任何已有的名字冲突。</p>

<p><br/></p>

<p>(let [(a 2)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(insert-binding (+ a 3)))</p>

<p>-></p>

<p>(let [(a 2)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(let [(:g0001 1)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+ (+ a 3) :g0001)))</p>

<p>=> 6</p>

<p><br/></p>

<p>这样就得到了正确的结果。</p>

<p><br/></p>

<p>例2：宏展开后，引入了不在原来词法作用域中的标识符。</p>

<p>(let [(a 1)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(let-syntax [(insert-free (syntax-rules ()</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[(_ x) (+ x a)]))]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let [(a 2)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(insert-free (+ a 3)))))</p>

<p>=> 6</p>

<p><br/></p>

<p>同样根据定义，我们知道(insert-free x) -> (+ x a)</p>

<p><br/></p>

<p>所以，</p>

<p>(let [(a 2)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(insert-free (+ a 3)))</p>

<p>-></p>

<p>(let [(a 2)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(+ (+ a 3) a))</p>

<p>=> 7</p>

<p><br/></p>

<p>结果又出错了。</p>

<p>哪里出现问题了？</p>

<p><br/></p>

<p>宏定义的模式/模板[(_ x) (+ x a)]))]中的a，应该是第一行的绑定，(let [(a 1)]</p>

<p>而展开式(let [(a 2)] (+ (+ a 3) a))覆盖了外层对a的绑定。</p>

<p><br/></p>

<p>因此，宏展开式的行为，将取决于展开后的环境，</p>

<p>展开到不同的环境中，行为是不同的。</p>

<p>失去了宏调用的“引用透明性”。</p>

<p><br/></p>

<p>Scheme是怎么解决的呢？</p>

<p>语言规范指出，宏展开式中的自由标识符，处于宏定义时的词法作用域中。</p>

<p>即，宏展开式(+ x a)中，a具有宏定义环境中的值a => 1，(insert-free x) -> (+ x 1)</p>

<p><br/></p>

<p>(let [(a 2)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(insert-free (+ a 3)))</p>

<p>-></p>

<p>(let [(a 2)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(+ (+ a 3) 1))</p>

<p>=> 6</p>

<p><br/></p>

<h2><strong>规律总结</strong></h2>

<p>我们遇到了一个问题。</p>

<p>我们知道，“+”在Scheme中表示加法函数，</p>

<p>它和a地位相同，也是一个变量，只不过它的值是一个函数。</p>

<p><br/></p>

<p>那么，以上两个例子中，变量+的值分别来自哪个词法作用域呢？</p>

<p><br/></p>

<p>例1中，</p>

<p>(let [(a 2)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(insert-binding (+ a 3)))</p>

<p>-></p>

<p>(let [(a 2)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(let [(:g0001 1)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(+ (+ a 3) :g0001)))</p>

<p><br/></p>

<p>经过分析，我们知道了，</p>

<p>(+ (+ a 3) :g0001)))中第一个+来自宏定义处的词法作用域，</p>

<p>第二个+来自宏替换处的词法作用域。</p>

<p><br/></p>

<p>例2中，</p>

<p>(let [(a 2)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(insert-free (+ a 3)))</p>

<p>-></p>

<p>(let [(a 2)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(+ (+ a 3) 1))</p>

<p><br/></p>

<p>同样经过分析，我们知道了，</p>

<p>(+ (+ a 3) 1))中第一个+来自宏定义处的词法作用域，</p>

<p>第二个+来自宏替换处的词法作用域。</p>

<p><br/></p>

<p>因此，</p>

<p>我们找到了一个规律，这也是卫生宏的目的所在。即，</p>

<p><strong>宏展开式中的所有标识符，仍处于其来源处的词法作用域中。</strong></p>

<p><br/></p>

<p>我们试着分析一下这两个例子。</p>

<p>例1展开式，</p>

<p>(let [(a 2)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>(let [(:g0001 1)]</strong></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>(+</strong> (+ a 3) <strong>:g0001))</strong>)</p>

<p>粗体来源于宏定义处，普通字体来源于宏替换处。</p>

<p>展开后，它们仍然处于各自来源处的词法作用域中。</p>

<p><br/></p>

<p>例2展开式，</p>

<p>(let [(a 2)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;<strong>(+</strong> (+ a 3) <strong>1)</strong>)</p>

<p>上述规则同样满足。</p>

<p><br/></p>

<p>宏展开式中的标识符，虽然来源不同，但互不污染。</p>

<p>这就达到卫生宏的目的了。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>在Lisp编程中，宏展开后造成了非预期的污染，是经常出现问题的地方。</p>

<p>Common Lisp目前并不支持卫生宏，</p>

<p>但是可以实现自己的宏定义，用自己的宏来定义宏，达到简洁可控的目的。</p>

<p><br/></p>

<p>当然，卫生宏也造成了表达能力的损失，</p>

<p>在特殊情况下，可以使用syntax-case以及datum->syntax来弥补。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/52">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/50">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
	<h1>Categories</h1>
	<ul id="categories">
		<li class='category'><a href='/blog/categories/design/'>design (9)</a></li>
<li class='category'><a href='/blog/categories/haskell/'>haskell (6)</a></li>
<li class='category'><a href='/blog/categories/lisp/'>lisp (17)</a></li>
<li class='category'><a href='/blog/categories/logic/'>logic (4)</a></li>
<li class='category'><a href='/blog/categories/mind/'>mind (25)</a></li>
<li class='category'><a href='/blog/categories/software/'>software (12)</a></li>

	</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/03/11/tools/">论工具</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/03/08/forward-looking-engineer/">软件工程师的前瞻性</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/03/06/game-theory-in-team-building/">团队建设中的博弈论</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/03/01/proof-and-deduction/">形式证明与逻辑推理</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/29/computer-science/">真实在哪里</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/26/less-is-more/">多做不如少做，不做不如去做</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/21/the-rhythm-of-the-development/">软件开发的节奏</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/18/the-fourth-level/">第四重境界</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/11/monad-in-hask-category/">Hask范畴上的Monad</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/22/grow-up-positively/">积极成长</a>
      </li>
    
  </ul>
</section>

<section>
	<h1>GitHub Repos</h1>
	
	
    <ul>
        <li><a href="https://github.com/thzt">@thzt</a> on GitHub</li>
    </ul>
	
	
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - thzt -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
