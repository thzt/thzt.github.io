
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>何幻</title>
  <meta name="author" content="thzt">

  
  <meta name="description" content="范畴论是一个迷人的领域， 它是一门研究数学结构以及结构之间关系的理论。 不知道我们学群论时， 是否感觉到了群同态与集合间映射的相似性。 学拓扑学时， 是否感觉到了连续映射与微分流形间光滑映射的相似性。 范畴论统一了这些相似结构。 然而，这还要从抽象代数说起。 幺半群（monoid） 在抽象代数中， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="https://thzt.github.io/posts/24/" />
  <link type="favicon" rel="shortcut icon" href="/favicon.ico" />
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css" />
  <link href="/atom.xml" rel="alternate" title="何幻" type="application/atom+xml" />
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.aspnetcdn.com/ajax/jQuery/jquery-1.9.1.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.useso.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.useso.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">何幻</a></h1>
  
    <h2>Programming is about ideas, languages are just a way to express them.</h2>
  
</hgroup>


<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "//hm.baidu.com/hm.js?33605c59a8749f3e0404d9f438b66667";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>
</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<ul class="main-navigation">
	<li><a href="/">Newest</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2016/01/11/monad-in-hask-category/">Hask范畴上的Monad</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2016-01-11T00:00:00+08:00'><span class='date'><span class='date-month'>Jan</span> <span class='date-day'>11</span><span class='date-suffix'>th</span>, <span class='date-year'>2016</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>范畴论是一个迷人的领域，</p>

<p>它是一门研究<strong>数学结构</strong>以及<strong>结构之间关系</strong>的理论。</p>

<p><br/></p>

<p>不知道我们学群论时，</p>

<p>是否感觉到了群同态与集合间映射的相似性。</p>

<p>学拓扑学时，</p>

<p>是否感觉到了连续映射与微分流形间光滑映射的相似性。</p>

<p><br/></p>

<p>范畴论统一了这些相似结构。</p>

<p>然而，这还要从抽象代数说起。</p>

<p><br/></p>

<h2>幺半群（monoid）</h2>

<p>在抽象代数中，<strong>幺半群</strong>是这样定义的。</p>

<p><br/></p>

<p>集合S和S上满足结合律的封闭二元运算"•"，</p>

<p>所形成的代数结构称为<strong>半群</strong>，记为(S, •)，简记为S</p>

<p><br/></p>

<p>设S是半群，元素e∈S，称为半群S的<strong>幺元素</strong>，</p>

<p>如果对于每一个x∈S，有xe=ex=x</p>

<p><br/></p>

<p>如果半群S有幺元素e，则它是唯一的。</p>

<p>含有幺元素的半群称为<strong>幺半群</strong>。</p>

<p><br/></p>

<p>注：</p>

<p>半群G如果有幺元素，且每个元素均可逆，</p>

<p>则称G为<strong>群</strong></p>

<p><br/></p>

<h2>图示法（diagram）</h2>

<p>一个幺半群M，可以描述为一个集合M，和两个函数</p>

<p>µ : M × M -> M</p>

<p>η : 1 -> M</p>

<p><br/></p>

<p>其中，1 = {0}是只有一个元素的集合。</p>

<p><br/></p>

<pre>           1 × µ<br>M × M × M -------&gt; M × M<br>    |                |<br>    | µ × 1          | µ<br>    |                |<br>    v                v<br>  M × M   -------&gt;   M<br>             µ</pre>




<pre>        η × 1          1 × η<br>1 × M -------&gt; M × M &lt; ------- M × 1<br>  |              |               |<br>  | α            | µ             | β<br>  |              |               |<br>  v              v               v<br>  M      =       M        =      M</pre>


<p><br/></p>

<p>用元素来表示图表，可以写为，</p>

<p><br/></p>

<pre>&lt;x,y,z&gt; |-------&gt;    &lt;x,yz&gt;<br>   -                   -<br>   |                   |<br>   |                   |<br>   v                   v<br>&lt;xy,z&gt;  |-------&gt; (xy)z=x(yz)</pre>




<pre>&lt;0,x&gt; |-------&gt; &lt;e,x&gt;    &lt;x,e&gt; &lt;-------| &lt;x,0&gt;<br>  -               -        -               -<br>  |               |        |               |<br>  |               |        |               |<br>  v               v        v               v<br>  x       =      ex       xe       =       x</pre>


<p><br/></p>

<p>可以看出，(xy)z=x(yz)表示了群乘法的结合律，</p>

<p>x=ex,xe=x表示了幺元e，因此图表展示了幺半群的结构。</p>

<p><br/></p>

<h2>范畴（category）</h2>

<p>一个<strong>范畴</strong>C由一系列<strong>对象</strong>（object）和<strong>箭头</strong>（arrow）组成。</p>

<p>对于每一个箭头f，有两个对象与之关联，</p>

<p>称为箭头f的定义域（domain）和值域（codomain）。</p>

<p>并且，满足以下几条规则，</p>

<p>（1）对于每一个对象a，存在恒等箭头（identity arrow），i:a->a</p>

<p>（2）箭头满足结合律，对于任意的箭头f,g,h有(f•g)•h=f•(g•h)</p>

<p>（3）箭头的集合在箭头组合运算下是封闭的</p>

<p><br/></p>

<p>注：</p>

<p>f•g表示g和f的组合运算，它也是一个箭头，其中g的值域是f的定义域</p>

<p><br/></p>

<p>例：</p>

<p>所有的集合，以集合作为对象，集合间的映射作为箭头，构成了一个范畴，</p>

<p>所有的群，以群作为对象，群同态作为箭头，构成了一个范畴，</p>

<p>所有的拓扑空间，以拓扑空间作为对象，拓扑空间之间的连续映射为箭头，构成了一个范畴，</p>

<p>所有的微分流形，以微分流形作为对象，流形间的光滑映射为箭头，构成了一个范畴，</p>

<p>Haskell中，以类型作为对象（类型是值的集合），函数作为箭头，构成了一个范畴（<strong>Hask范畴</strong>）。</p>

<p><br/></p>

<h2>函子（functor）</h2>

<p>如果把范畴看做对象，则函子可以看做箭头。</p>

<p><br/></p>

<p>一个<strong>函子</strong>F是范畴C到范畴D的箭头，F:C -> D，</p>

<p>它满足以下条件，</p>

<p>F把C中的对象c映射为D中的对象F c，把C中的箭头f映射为D中的箭头F f。</p>

<p>且满足分配律，F (f•g)=(F f)•(F g)</p>

<p><br/></p>

<p>注：</p>

<p>等式左边的"•"表示C中的箭头组合运算，</p>

<p>等式右边的"•"表示D中的箭头组合运算。</p>

<p><br/></p>

<p>范畴C到自身的函子，称为<strong>自函子</strong>（endofunctor）。</p>

<p><br/></p>

<p>Hask范畴的自函子把Haskell中的类型a映射为另一个类型f a，</p>

<p>把类型a到类型b的函数，映射为类型f a到类型f b的函数。</p>

<p><br/></p>

<p>class Functor f where</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmap :: (a -> b) -> f a -> f b</p>

<p><br/></p>

<p>class Functor f => Applicative f where</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pure :: a -> f a</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(&lt;*>) :: f (a -> b) -> f a -> f b</p>

<p><br/></p>

<p>我们看到，pure和fmap放在一起，</p>

<p>构成了一个Hask范畴的自函子。</p>

<p><br/></p>

<h2>自然变换（natural transformation）</h2>

<p>如果把函子看做对象，则自然变换可以看做箭头。</p>

<p><br/></p>

<p>若F和G是范畴C到D的函子，则<strong>自然变换</strong>τ是一个箭头，τ: F -> G，</p>

<p>它满足以下条件，</p>

<p><br/></p>

<pre>     f<br>a -------&gt; b</pre>




<pre>      F f<br>F a -------&gt; F b<br>|            |<br>| τ a        | τ b<br>|            |<br>v            v<br>G a -------&gt; G b<br>      G f</pre>


<p><br/></p>

<p>注：</p>

<p>F a是D中与a对应的对象，F b是D中与b对应的对象，F f是D中与f对应的箭头</p>

<p><br/></p>

<h2>函子范畴（functor category）</h2>

<p>以范畴C到D的函子为对象，以函子间的自然变换为箭头，</p>

<p>构成了一个范畴，称为<strong>函子范畴</strong>。</p>

<p><br/></p>

<p>易知，自然变换可以进行组合运算，</p>

<p>设µ a : F a -> G a，η a : G a -> H a</p>

<p>则可以定义一个新的自然变换(η • µ) a = F a -> H a</p>

<p>可证自然变换的组合运算满足结合律。</p>

<p><br/></p>

<p>注：</p>

<p>函子范畴的对象，不是一个集合，</p>

<p>函子范畴的箭头，也不是映射。</p>

<p><br/></p>

<h2>Monad</h2>

<p>范畴C上的monad，是一个<strong>三元组</strong>(F,µ,η)，其中</p>

<p>F是范畴C上的自函子，</p>

<p>µ是F<sup>2</sup>到F的自然变换，µ:F<sup>2</sup>->F，</p>

<p>η是单位自函子I到F的自然变换，η:I->F</p>

<p><br/></p>

<p>且满足以下条件</p>

<p><br/></p>

<pre>           F • µ<br>F • F • F -------&gt; F • F<br>    |                |<br>    | µ • F          | µ<br>    |                |<br>    v                v<br>  F • F   -------&gt;   F<br>             µ</pre>




<pre>        η • F          F • η<br>I • F -------&gt; F • F &lt; ------- F • I<br>                 |                <br>  ||             | µ            ||<br>                 |               <br>                 v                <br>  F      =       F        =      F</pre>


<p><br/></p>

<p>在Haskell中可以这样表示：</p>

<p><br/></p>

<p>{- 自函子F，作用在对象上时 -}</p>

<p>fObj :: (Applicative f) => a -> f a</p>

<p>fObj = pure</p>

<p><br/></p>

<p>{- 自函子F，作用在箭头上时 -}</p>

<p>fArr :: (Applicative f) => (a -> b) -> (f a -> f b)</p>

<p>fArr = fmap</p>

<p><br/></p>

<p>{- 自函子F<sup>2</sup> -}</p>

<p><br/></p>

<p>f2Obj :: (Applicative f) => a -> f (f a)</p>

<p>f2Obj = fObj . fObj</p>

<p><br/></p>

<p>f2Arr :: (Applicative f) => (a -> b) -> (f (f a) -> f (f b))</p>

<p>f2Arr :: fArr . fArr</p>

<p><br/></p>

<p>{- 单位自函子，作用到对象上时 -}</p>

<p>iObj :: a -> a</p>

<p>iObj = id</p>

<p><br/></p>

<p>{- 单位自函子，作用到箭头上时 -}</p>

<p>iArr :: (a -> b) -> (a -> b)</p>

<p>iArr = id</p>

<p><br/></p>

<p>{- 自然变换µ:F<sup>2</sup>->F，（µ a:F<sup>2</sup> a->F a） -}</p>

<p>µ :: (Applicative f) => a -> f (f a) -> f a</p>

<p><br/></p>

<p>{- 自然变换η:I->F，（η a:I a->F a） -}</p>

<p>η :: (Applicative f) => a -> a -> (f a)</p>

<p><br/></p>

<h2>自函子范畴上的幺半群</h2>

<p>以范畴C上的自函子为对象，自然变换为箭头，</p>

<p>构成的函子范畴，称为<strong>自函子范畴</strong>。</p>

<p><br/></p>

<p>对比Monad定义中的自函子F与幺半群中的集合M，</p>

<p><br/></p>

<p><strong>结合律</strong>：</p>

<pre>           1 × µ<br>M × M × M -------&gt; M × M<br>    |                |<br>    | µ × 1          | µ<br>    |                |<br>    v                v<br>  M × M   -------&gt;   M<br>             µ</pre>




<pre>           F • µ<br>F • F • F -------&gt; F • F<br>    |                |<br>    | µ • F          | µ<br>    |                |<br>    v                v<br>  F • F   -------&gt;   F<br>             µ</pre>


<p><strong>幺元</strong>：</p>

<pre>        η × 1          1 × η<br>1 × M -------&gt; M × M &lt; ------- M × 1<br>  |              |               |<br>  | α            | µ             | β<br>  |              |               |<br>  v              v               v<br>  M      =       M        =      M</pre>




<pre>        η • F          F • η<br>I • F -------&gt; F • F &lt; ------- F • I<br>                 |                <br>  ||             | µ            ||<br>                 |               <br>                 v                <br>  F      =       F        =      F</pre>


<p><br/></p>

<p>可知，自函子F相当于群的集合M，自然变换µ相当于群乘法，单位自函子相当于幺元，它们构成了一个<strong>幺半群</strong>，</p>

<p>即<strong>Monad是Hask自函子范畴上的幺半群</strong>。</p>

<p><br/></p>

<p>注：</p>

<p>M × M × M表示集合M的笛卡尔积，</p>

<p>而F • F • F表示自函子F的组合。</p>

<p><br/></p>

<h2>幺半群范畴（monoidal category）</h2>

<p>幺半群在范畴论中是有了新的意义，</p>

<p>比群论中的概念更一般化。</p>

<p><br/></p>

<p>我们可以为范畴增加一个满足结合律的二元函子，</p>

<p>构成一个『范畴论意义上的』<strong>幺半群</strong>（monoid）。</p>

<p><br/></p>

<p>说一个范畴是具有幺半群结构的（monodial），</p>

<p>如果它有一个像笛卡尔积，或者直和，张量积，那样的『乘积』，</p>

<p>并且，这个『乘积』满足结合律，还有一个单位元。</p>

<p><br/></p>

<p>即，一个<strong>严格幺半群范畴</strong>（strict monoidal category）是范畴B上的一个结构&lt;B,□,e&gt;，</p>

<p>其中□是一个满足结合律的二元函子，□: B × B -> B，</p>

<p>□ (□ × 1) = □ (1 × □) : B × B × B -> B</p>

<p>而且存在对象e是二元函子□的单位元，</p>

<p>□ (e × 1) = id(B) = □ (1 × e)</p>

<p><br/></p>

<p>然后就可以在任意的幺半群范畴&lt;B,□,e&gt;中定义幺半群了。</p>

<p><br/></p>

<p>幺半群范畴B上的<strong>幺半群</strong>由三部分组成，&lt;c,µ,η&gt;，</p>

<p>其中c是B中的对象，µ : c □ c -> c，η : e -> c是范畴B中的箭头，</p>

<p>且满足以下条件</p>

<pre>               σ                  µ □ 1<br>c □ (c □ c) -------&gt; (c □ c) □ c -------&gt; c □ c<br>    |                                       |<br>    | 1 □ µ                                 | µ<br>    |                                       |<br>    v                                       v<br>  c □ c ----------------------------------&gt; c<br>                        µ</pre>




<pre>        η □ 1          1 □ η<br>e □ c -------&gt; c □ c &lt; ------- c □ e<br>  |              |               |<br>  | α            | µ             | β<br>  |              |               |<br>  v              v               v<br>  c      =       c        =      c</pre>


<p><br/></p>

<h2>结语</h2>

<p>『All told, a monad in X is just a monoid in the category of endofunctors of X,</p>

<p>with the product × replaced by composition of endofunctors</p>

<p>and unit set by the identity endofunctor.』</p>

<p><br/></p>

<p>一语成谶，很多人都是因为这句话入坑的，</p>

<p>然而理解它真的很不容易，</p>

<p>原来这个『幺半群』应该在范畴论意义上进行理解，</p>

<p>已经不是集合论基础上群论的内容了。</p>

<p><br/></p>

<p>在写这篇文章时，我甚至还没有入门，有错误在所难免，</p>

<p>但是多年坚持下来，似乎对这个问题有些眉目了，</p>

<p>于是就赶紧整理了一下，希望接下来以此为起点继续努力，勇往直前。</p>

<p><br/></p>

<p><strong>参考</strong>：</p>

<p>《<a href="http://book.douban.com/subject/4201293/">近世代数引论</a>》</p>

<p>《<a href="http://book.douban.com/subject/1823110/">Categories for the Working Mathematician 2nd</a>》</p>

<p><a href="https://medium.com/@brettwines/implementing-a-category-theoretic-hask-monad-in-haskell-7bf662f2e98b">Implementing a category-theoretic Hask-monad in Haskell</a></p>

<p><a href="http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem">A monad is just a monoid in the category of endofunctors, what&rsquo;s the problem?</a></p>

<p><a href="http://slides.com/julientournay/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-what-s-the-problem/fullscreen">A MONAD IS JUST A MONOID IN THE CATEGORY OF ENDOFUNCTORS. WHAT&rsquo;S THE PROBLEM ?</a></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/25">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/23">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
	<h1>Categories</h1>
	<ul id="categories">
		<li class='category'><a href='/blog/categories/design/'>design (11)</a></li>
<li class='category'><a href='/blog/categories/haskell/'>haskell (6)</a></li>
<li class='category'><a href='/blog/categories/lisp/'>lisp (17)</a></li>
<li class='category'><a href='/blog/categories/logic/'>logic (9)</a></li>
<li class='category'><a href='/blog/categories/mind/'>mind (33)</a></li>
<li class='category'><a href='/blog/categories/software/'>software (12)</a></li>

	</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/08/02/cohomology-group/">懵逼的上同调群</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/07/23/computability/">可计算性理论名词释义</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/07/18/overcome-the-limitation/">挑战极限</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/07/01/the-way-to-express/">重在表达</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/06/25/complete-partial-order/">不动点算子与完全偏序</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/06/08/algebraic-data-type/">代数数据类型的语法和语义</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/06/02/requirement-change/">如何应对需求变更</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/05/29/let-things-happen/">让事情去发生</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/05/19/type-theory-in-my-eye/">类型理论之拙见</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/05/18/do-not-rely-on-the-hearsay/">不要依赖『道听途说』</a>
      </li>
    
  </ul>
</section>

<section>
	<h1>GitHub Repos</h1>
	
	
    <ul>
        <li><a href="https://github.com/thzt">@thzt</a> on GitHub</li>
    </ul>
	
	
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - thzt -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
