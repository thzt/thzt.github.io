
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>何幻</title>
  <meta name="author" content="thzt">

  
  <meta name="description" content="在漫长的编程学习过程中， 你可能会不经意间的， 知道了Y组合子。 它的内部结构极其诡异， 但是它又如此的让你魂牵梦萦， 让你茶饭不思， 为伊消得人憔悴。 这时候，数学基础是很重要的， 概念的差距，产生了无法逾越的鸿沟。 我们还是认真的从头开始吧。 lambda calculus lambda &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="https://thzt.github.io/posts/33/" />
  <link type="favicon" rel="shortcut icon" href="/favicon.ico" />
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css" />
  <link href="/atom.xml" rel="alternate" title="何幻" type="application/atom+xml" />
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.aspnetcdn.com/ajax/jQuery/jquery-1.9.1.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.useso.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.useso.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">何幻</a></h1>
  
    <h2>Programming is about ideas, languages are just a way to express them.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<ul class="main-navigation">
	<li><a href="/">Newest</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/06/10/fixed-point/">不动点组合子与匿名递归函数</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-06-10T00:00:00+08:00'><span class='date'><span class='date-month'>Jun</span> <span class='date-day'>10</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>在漫长的编程学习过程中，</p>

<p>你可能会不经意间的，</p>

<p>知道了<strong>Y组合子</strong>。</p>

<p><br/></p>

<p>它的内部结构极其诡异，</p>

<p>但是它又如此的让你魂牵梦萦，</p>

<p>让你茶饭不思，</p>

<p>为伊消得人憔悴。</p>

<p><br/></p>

<p>这时候，<strong>数学基础</strong>是很重要的，</p>

<p>概念的差距，产生了无法逾越的鸿沟。</p>

<p>我们还是认真的从头开始吧。</p>

<p><br/></p>

<h2><strong>lambda calculus</strong></h2>

<p>lambda calculus简称LC，</p>

<p>它是一个形式系统，</p>

<p>用来研究函数的组合和应用。</p>

<p><br/></p>

<p>LC的研究对象称为<strong>λ项</strong>，</p>

<p>它是这样定义的，</p>

<p>λ项 = 变量</p>

<p>λ项 = λ项 λ项</p>

<p>λ项 = λ变量.λ项</p>

<p><br/></p>

<p>例如：</p>

<p>((λy.y)(λx.(xy)))</p>

<p>(x(λx.(λx.x)))</p>

<p>都是合法的λ项。</p>

<p><br/></p>

<p>我们用小写字母x，y，z表示变量，</p>

<p>大写字母M，N，P，Q表示λ项。</p>

<p><br/></p>

<p>λ项是左结合的，</p>

<p>MNPQ ≡ (((MN)P)Q)，</p>

<p><br/></p>

<p>λx.PQ ≡ (λx.(PQ))</p>

<p>λx尽可能多的向右结合。</p>

<p><br/></p>

<p>其中，“≡”表示语法上相等。</p>

<p><br/></p>

<h2><strong>替换规则</strong></h2>

<p>[N/x]M</p>

<p>表示把M中所有的x替换成N。</p>

<p><br/></p>

<h2><strong>α转换</strong></h2>

<p>α转换说的是，</p>

<p>可以将λx.PQ中的x改为其他变量y，</p>

<p>只需要同时将PQ中的自由变量x改为y即可。</p>

<p><br/></p>

<p>α转换定义了一个等价关系，</p>

<p>称为α等价。</p>

<p><br/></p>

<p>注：</p>

<p>这里y不能和PQ中的同名变量y冲突。</p>

<p><br/></p>

<p>α转换相当于<strong>变量更名</strong>。</p>

<p><br/></p>

<h2><strong>β归约</strong></h2>

<p>β归约相当于<strong>函数调用</strong>。</p>

<p><br/></p>

<p>(λx.M)N -> [N/x]M</p>

<p>即，对(λx.M)N进行β归约，</p>

<p>相当于把M中的变量x替换成N。</p>

<p><br/></p>

<p>一个<strong>β范式</strong>（weak normal form），</p>

<p>是不能再进行β归约的λ项。</p>

<p><br/></p>

<h2><strong>Church–Rosser定理</strong></h2>

<p>如果λ项P能β归约为M，即P->M，</p>

<p>也能β归约为N，P->N，</p>

<p>则存在λ项T，满足，</p>

<p>M->T且N->T。</p>

<p><br/></p>

<p>它表示了λ项β归约的<strong>汇聚性</strong>。</p>

<p>而且，λ项在α等价的条件下，至多存在一个β范式。</p>

<p><br/></p>

<h2><strong>Combinator logic</strong></h2>

<p>Combinator logic简称为CL，</p>

<p>它是一个形式系统，</p>

<p>与lambda calculus具有同样的计算能力。</p>

<p><br/></p>

<p>CL研究了<strong>CL项</strong>的演算规则，</p>

<p>一个合法的CL项，由以下条件递归定义，</p>

<p>CL项 = 变量 | 基本组合子</p>

<p>CL项 = CL项 CL项</p>

<p><br/></p>

<p>例如：</p>

<p>((S(KS))K)</p>

<p>((S(Kx))((SY)K))</p>

<p>都是合法的CL项。</p>

<p><br/></p>

<p>我们用小写字母x，y，z表示变量，</p>

<p>大写字母X，Y，Z表示CL项。</p>

<p><br/></p>

<p>CL项是左结合的，</p>

<p>UVWX ≡ (((UV)W)X)，</p>

<p>其中，“≡”表示语法上相等。</p>

<p><br/></p>

<h2><strong>替换规则</strong></h2>

<p>[U/x]Y</p>

<p>表示把Y中所有的x替换成U。</p>

<p><br/></p>

<p>例如：</p>

<p>[(SK)/x](yxx) ≡ y(SK)(SK)</p>

<p><br/></p>

<h2><strong>弱归约（Weak reduction）</strong></h2>

<p>以下形式的CL项可以进行弱归约，</p>

<p>IX -> X</p>

<p>KXY -> X</p>

<p>SXYZ -> XZ(YZ)</p>

<p><br/></p>

<p>如果进行这些变换可以使U变成U'，</p>

<p>就称CL项U可以弱归约为U'。</p>

<p><br/></p>

<p>一个<strong>弱范式</strong>（weak normal form），</p>

<p>是不能再进行弱归约的CL项。</p>

<p><br/></p>

<h2><strong>Church–Rosser定理</strong></h2>

<p>与lambda calculus一样，</p>

<p>对于CL，也有类似的定理，</p>

<p><br/></p>

<p>如果CL项U可以弱归约为X，即U->X，</p>

<p>也可以弱归约为Y，即U->Y，</p>

<p>则存在CL项T，满足，</p>

<p>X->T且Y->T。</p>

<p><br/></p>

<p>这表示了CL项弱归约的<strong>汇聚性</strong>。</p>

<p>而且，CL项至多存在一个弱范式。</p>

<p><br/></p>

<h2><strong>CL项的抽象</strong></h2>

<p>为了和lambda演算进行对比，</p>

<p>我们定义CL项的抽象，</p>

<p>(a) [x].M ≡ KM，如果x不是M中的自由变量</p>

<p>(b) [x].x ≡ I</p>

<p>&copy; [x].Ux ≡ U，如果x不是U中的自由变量</p>

<p>(d) [x].UV ≡ S([x].U)([x].V)，如果不满足(a)或&copy;</p>

<p><br/></p>

<p>可以证明，</p>

<p>([x].M)N可以弱归约为[N/x]M。</p>

<p><br/></p>

<p>这里，我们只是用原始的CL项来定义了CL项的抽象，</p>

<p>[x]并不是CL语法的一部分，</p>

<p>而对于lambda calculus中的λ项λx.xy，</p>

<p>λx是λ项的一部分。</p>

<p><br/></p>

<h2><strong>LC和CL的相似性</strong></h2>

<p>经过以上学习，</p>

<p>我们发现，</p>

<p>LC中的<strong>α等价</strong>，对应着CL中的<strong>语法等价</strong>，</p>

<p>LC中的<strong>β归约</strong>，对应着CL中的<strong>弱归约</strong>，</p>

<p>LC中的<strong>λx</strong>，对应着CL中的<strong>[x]</strong>。</p>

<p><br/></p>

<p>我们就可以统一的，</p>

<p>用LC中的符号来说明问题了。</p>

<p><br/></p>

<h2><strong>组合子</strong></h2>

<p>LC中的<strong>组合子</strong>，</p>

<p>表示一个闭项（closed pure term），</p>

<p>它不是一个原子，也不包含自由变量。</p>

<p><br/></p>

<p>例如：</p>

<p>λxyz.x(yz)</p>

<p>λxy.x</p>

<p><br/></p>

<p>CL中的<strong>组合子</strong>，</p>

<p>只有3个，I，K，S。</p>

<p><br/></p>

<p>在LC中，可以这样表示，</p>

<p>I ≡ λx.x</p>

<p>K ≡ λxy.x</p>

<p>S ≡ λxyz.xz(yz)</p>

<p><br/></p>

<h2><strong>不动点定理</strong></h2>

<p>在LC和CL中，</p>

<p><strong>对于任意x，存在它的不动点Yx，满足，</strong></p>

<p><strong>Yx -> x(Yx)</strong></p>

<p><br/></p>

<p>其中，</p>

<p>“->”表示LC中的β归约，</p>

<p>或CL中的弱归约。</p>

<p><br/></p>

<p><strong>证明：</strong></p>

<p>取Y ≡ UU</p>

<p>U ≡ λux.x(uux)</p>

<p><br/></p>

<p>Yx -></p>

<p>UUx -></p>

<p>(λux.x(uux))Ux -></p>

<p>(λx.x(UUx))x -></p>

<p>x(UUx) -></p>

<p>x(Yx)</p>

<p><br/></p>

<h2><strong>不动点组合子</strong></h2>

<p>不动点组合子并不是唯一的，</p>

<p><br/></p>

<p>存在不止一个Y，</p>

<p>使得对于任意x，Yx -> x(Yx)。</p>

<p><br/></p>

<p>例如：</p>

<p><strong>Turing组合子</strong></p>

<p>Y ≡ UU，U ≡ λux.x(uux)</p>

<p><br/></p>

<p><strong>Curry-Ros组合子</strong></p>

<p>Y ≡ λx.VV，V ≡ λy.x(yy)</p>

<p><br/></p>

<h2><strong>不动点定理的用法</strong></h2>

<p>根据不动点定理，</p>

<p>我们能得到任意LC项或CL项的不动点，</p>

<p>所以，<strong>不动点方程总是有解的</strong>。</p>

<p><br/></p>

<p>例如：</p>

<p>给定方程，x = M，M中可能包含x，</p>

<p>我们可以将它转换成不动点方程，</p>

<p>x = (λx.M)x，</p>

<p>解为：x = Y(λx.M) = Y(λt.[t/x]M)</p>

<p>它<strong>消除了M中的x</strong>。</p>

<p><br/></p>

<p>例如：M ≡ yxz</p>

<p>x = Y(λx.M) = Y(λx.yxz) = Y(λt.ytz)，</p>

<p>等式右边就不包含自由变量x了。</p>

<p><br/></p>

<p>所以，形如x = M的方程，</p>

<p>我们可以使用Y来消除M中的x。</p>

<p><br/></p>

<p>这也表明可以不依赖于副作用，</p>

<p>用Y来定义<strong>匿名递归函数</strong>。</p>

<p><br/></p>

<h2><strong>用Y组合子解递归方程</strong></h2>

<p>Haskell中的Turing Y组合子定义如下：</p>

<p><strong>import Unsafe.Coerce</strong></p>

<p>u = \u x -> x $ u <strong>(unsafeCoerce</strong> u<strong>)</strong> x</p>

<p>y = u u</p>

<p><br/></p>

<p>斐波那契函数fib的递归定义，</p>

<p>fib = \n -> if n&lt;2 then 1 else (n*) $ fib $ n-1</p>

<p><br/></p>

<p>为了<strong>消除等式右边fib</strong>，</p>

<p>我们把它转换成不动点方程，</p>

<p>fib = (\f -> \n -> if n&lt;2 then 1 else (n*) $ f $ n-1) fib</p>

<p>用Y组合子求解，得到了一个匿名的递归函数，</p>

<p>fib = y $ <strong>\f -></strong> \n -> if n&lt;2 then 1 else (n*) $ <strong>f</strong> $ n-1</p>

<p><br/></p>

<p>验证一下运行结果，</p>

<p>fib 5</p>

<p>=> 120</p>

<p><br/></p>

<h2><strong>不动点存在性的疑问</strong></h2>

<p>方程解的性质是由方程决定的，</p>

<p><strong>解法无法改变解的性质</strong>。</p>

<p><br/></p>

<p>例如：</p>

<p>a = undefined = (\a -> undefined) a</p>

<p>解为：a = y $ \a -> undefined <strong>= undefined</strong></p>

<p><br/></p>

<p>add = \n -> add n+1</p>

<p>这个一个无限递归函数。</p>

<p>转换为不动点方程的形式，</p>

<p>add = (\f -> \n -> f n+1) add</p>

<p>解为：add = y $ (\f -> \n -> f n+1)</p>

<p>这个add<strong>仍然是</strong>一个无限递归函数。</p>

<p><br/></p>

<h2><strong>初等函数的不动点</strong></h2>

<p>另外，对于初等函数的不动点方程，</p>

<p>x = f(x)</p>

<p>程序中直接写成x = f(x)会<strong>导致无限递归</strong>，</p>

<p>因为初等函数方程给出来的是<strong>约束</strong>，</p>

<p>而不是<strong>计算过程</strong>。</p>

<p><br/></p>

<p>例如：</p>

<p>求解f(x) = 2x的不动点，</p>

<p><strong>直接写x = 2*x是一个无限的递归</strong>，并不能解出x = 0来，</p>

<p>因此，x = 2*x实际表示的是一个无限递归的计算过程。</p>

<p><br/></p>

<p>然而，<strong>仍然</strong>会存在满足这个方程的解。</p>

<p>不动点方程形式如下，</p>

<p>x = (\x -> 2*x) x</p>

<p>解为：x = y $ \x -> 2*x</p>

<p>确实可以使等式成立，</p>

<p>但它<strong>同样表示</strong>的是一个无限递归的计算过程。</p>

<p><br/></p>

<p>f(x) = 2x的不动点方程，对应的“计算过程”<strong>应该是</strong>，</p>

<p>x = 0</p>

<p>不动点方程的形式如下，</p>

<p>x = (\x -> 0) x</p>

<p>解为：x = y $ \x -> 0 <strong>= 0</strong></p>

<p><br/></p>

<p>因此，</p>

<p>初等函数的不动点，</p>

<p>与LC或CL的不动点是两个不同的场景，</p>

<p>初等函数方程是一种<strong>约束规则</strong>，</p>

<p>LC或CL的等式是一种<strong>推导规则</strong>。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>不动点问题，</p>

<p>一直是我的心结。</p>

<p>只可惜功力不够，总是想不明白。</p>

<p><br/></p>

<p>本文只是对最近学习的总结，</p>

<p>肯定有<strong>不严谨</strong>的地方，</p>

<p>只当做以后继续学习的起点吧。</p>

<p><br/></p>

<p>参考：《Lambda-Calculus and Combinators》</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/34">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/32">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
	<h1>Categories</h1>
	<ul id="categories">
		<li class='category'><a href='/blog/categories/design/'>design (7)</a></li>
<li class='category'><a href='/blog/categories/haskell/'>haskell (6)</a></li>
<li class='category'><a href='/blog/categories/lisp/'>lisp (17)</a></li>
<li class='category'><a href='/blog/categories/logic/'>logic (2)</a></li>
<li class='category'><a href='/blog/categories/mind/'>mind (24)</a></li>
<li class='category'><a href='/blog/categories/software/'>software (12)</a></li>

	</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/01/26/less-is-more/">多做不如少做，不做不如去做</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/21/the-rhythm-of-the-development/">软件开发的节奏</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/18/the-fourth-level/">第四重境界</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/11/monad-in-hask-category/">Hask范畴上的Monad</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/22/grow-up-positively/">积极成长</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/01/defend-the-advantage/">守住天赋</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/25/fanatic-for-cleanliness-on-solving-problems/">问题洁癖</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/23/introduction-to-mathematical-logic/">数理逻辑定义汇总</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/08/demonstration-and-intuition/">论证与直觉</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/30/preparation/">先后之分</a>
      </li>
    
  </ul>
</section>

<section>
  <h1>GitHub Repos</h1>
  <ul id="gh_repos">
    <li class="loading">Status updating...</li>
  </ul>
  
  <a href="https://github.com/thzt">@thzt</a> on GitHub
  
  <script type="text/javascript">
    $(document).ready(function(){
        if (!window.jXHR){
            var jxhr = document.createElement('script');
            jxhr.type = 'text/javascript';
            jxhr.src = '/javascripts/libs/jXHR.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(jxhr, s);
        }

        github.showRepos({
            user: 'thzt',
            count: 0,
            skip_forks: true,
            target: '#gh_repos'
        });
    });
  </script>
  <script src="/javascripts/github.js" type="text/javascript"> </script>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - thzt -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
