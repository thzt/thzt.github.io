
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>何幻</title>
  <meta name="author" content="thzt">

  
  <meta name="description" content="据说Haskell是一种惰性求值的语言， 表达式的求值策略是按需求值，即call-by-need。 但是到底什么才是按需的， 求值到什么程度。 刚开始学习的时候，总是很模糊。 随着学习的深入，才慢慢了解， Haskell规范中，并没有涉及惰性求值， 只说它是一种non-strict &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="https://thzt.github.io/posts/27/" />
  <link type="favicon" rel="shortcut icon" href="/favicon.ico" />
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css" />
  <link href="/atom.xml" rel="alternate" title="何幻" type="application/atom+xml" />
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.aspnetcdn.com/ajax/jQuery/jquery-1.9.1.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.useso.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.useso.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">何幻</a></h1>
  
    <h2>Programming is about ideas, languages are just a way to express them.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.bing.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="thzt.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
	<li><a href="/">Newest</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/07/12/lazy-evaluation/">惰性求值</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-07-12T00:00:00+08:00'><span class='date'><span class='date-month'>Jul</span> <span class='date-day'>12</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p><strong>据说</strong>Haskell是一种惰性求值的语言，</p>

<p>表达式的求值策略是按需求值，即call-by-need。</p>

<p><br/></p>

<p>但是到底什么才是按需的，</p>

<p>求值到什么程度。</p>

<p>刚开始学习的时候，总是很模糊。</p>

<p><br/></p>

<p>随着学习的深入，才慢慢了解，</p>

<p>Haskell规范中，并没有涉及惰性求值，</p>

<p>只说它是一种<strong>non-strict language</strong>，</p>

<p>求值策略取决于具体的实现。</p>

<p><br/></p>

<p>这是怎么回事呢？</p>

<p>又要从头开始了。</p>

<p><br/></p>

<h2><strong>non-strictness</strong></h2>

<p>non-strict function，是<strong>指称语义</strong>中的概念，</p>

<p>指称语义将每一段代码，与一个数学对象相对应，</p>

<p>借此来研究程序的语义。</p>

<p><br/></p>

<p>一开始我们认为，程序中的函数，</p>

<p>会有直接的数学函数与之对应。</p>

<p><br/></p>

<p>其实不然，</p>

<p>因为，程序中的很多函数，在处理某些参数的时候，</p>

<p>行为是“未定义的”，得不到有用的信息，</p>

<p>这样的数学函数称为<strong>部分函数</strong>（partial function）。</p>

<p><br/></p>

<p>这里尽量<a href="http://www.vex.net/~trebla/haskell/lazy.xhtml">不要提及“不能终止的”</a>，</p>

<p>因为指称语义并不考虑求值过程。</p>

<p><br/></p>

<p>例如：</p>

<p>partialFn :: Integer -> Integer</p>

<p>partialFn 0 = 0</p>

<p>partialFn n = test $ n + 1</p>

<p><br/></p>

<p>可以看到partial只在参数为0的时候是有意义的。</p>

<p>所以，与程序中的函数对应的，</p>

<p>就不是普通意义上的数学函数了，</p>

<p>还需要<strong>扩充定义域和值域</strong>。</p>

<p><br/></p>

<p>我们为每个集合增加一个新的值“<strong>⊥</strong>”，称为bottom，</p>

<p>用来表示“未定义”。</p>

<p>函数f(n)={0,n=0;⊥,n≠0}，就能表示partialFn了。</p>

<p><br/></p>

<p>Haskell用undefined来表示⊥，</p>

<p>undefined也确实包含在所有类型中，</p>

<p>> :t undefined</p>

<p>> undefined :: a</p>

<p><br/></p>

<p>通常情况下，</p>

<p>如果一个数学函数的参数是⊥，则结果就是⊥。</p>

<p>这样的函数称为<strong>strict function</strong>。</p>

<p><br/></p>

<p>而Haskell中函数则不同。</p>

<p>例如：</p>

<p>nonStrictFn :: Integer -> Integer</p>

<p>nonStrictFn 0 _ = 0</p>

<p><br/></p>

<p>nonStrictFn 0 undefined
> 0</p>

<p><br/></p>

<p>函数nonStrictFn在参数包含undefined的时候，</p>

<p>并没有得到undefined，而是得到了一个明确的值0，</p>

<p>它对应的数学函数是<strong>non-strict function</strong>。</p>

<p><br/></p>

<p>函数的指称语义是non-strict function，</p>

<p>这样的语言，称为non-strict language。</p>

<p><br/></p>

<h2><strong>lazy evaluation</strong></h2>

<p>求值，是<strong>操作语义</strong>中的概念。</p>

<p><strong>能实现non-strict指称语义的求值策略并不是唯一的</strong>。</p>

<p><br/></p>

<p>GHC是Haskell目前最流行的编译器，</p>

<p>它使用了<strong>惰性求值</strong>（lazy evaluation）。</p>

<p><br/></p>

<p>例如：</p>

<p>x = 1</p>

<p>y = 2</p>

<p>z = (x, y)</p>

<p><br/></p>

<p>> :sprint x</p>

<p>> x = _</p>

<p>> :sprint y</p>

<p>> y = _</p>

<p>> :sprint z</p>

<p>> y = _</p>

<p><br/></p>

<p>这里“:sprint”只是打印表达式，而不会求值它。</p>

<p>“_”用来表示“未求值的”，或称为一个“<strong>thunk</strong>”。</p>

<p><br/></p>

<p>thunk在使用的时候，<strong>并不一定被完全求值</strong>。</p>

<p>> let first = (u, _) = u</p>

<p>> first z</p>

<p>> 1</p>

<p><br/></p>

<p>> :sprint x</p>

<p>> x = 1</p>

<p>> :sprint y</p>

<p>> y = _</p>

<p>> :sprint z</p>

<p>> y = (1, _)</p>

<p><br/></p>

<p>first函数，只求值了第一个参数，</p>

<p>第二个参数，仍然是未求值的。</p>

<p><br/></p>

<p>实际上，<strong>thunk的求值是分层次的</strong>，</p>

<p>为了尽量少的求值，每一次只将表达式求值为<strong>WHNF</strong>（weak head normal form），</p>

<p>其中的子表达式，仍然是未求值的thunk。</p>

<p><br/></p>

<p>如果不能满足需要，</p>

<p>就会继续将对应的sub-thunk，再求值为WHNF。</p>

<p><br/></p>

<h2><strong>Weak head normal form</strong></h2>

<p>一个WHNF（weak head normal form），</p>

<p>是表达式求值的一种结果形式。</p>

<p><br/></p>

<p>WHNF，只将表达式求值到，</p>

<p>最外层的<strong>值构造器</strong>或者<strong>lambda抽象</strong>为止。</p>

<p><br/></p>

<p>例如：以下表达式是WHNF，</p>

<p>(1 + 1, 2 + 2)，最外层是一个值构造器，(,)</p>

<p>\x -> 2 + 2，最外层是一个lambda抽象，</p>

<p>&lsquo;h&rsquo; : (&ldquo;e&rdquo; ++ &ldquo;llo&rdquo;)，最外层是一个值构造器，(:)</p>

<p><br/></p>

<p>以下表达式不是WHNF：</p>

<p>1 + 2，最外层是加法函数调用，(+)</p>

<p>(\x -> x + 1) 2，最外层是一个匿名函数调用</p>

<p>&ldquo;he&rdquo; ++ &ldquo;llo"，最外层是列表的连接函数调用，(++)</p>

<p><br/></p>

<p>因此，</p>

<p>表达式(1 + 1, 2 + 2)会按需首先求值为(thunk1,thunk2),</p>

<p>如果还需要thunk1的值，thunk1会求值为2。</p>

<p><br/></p>

<p>例如：</p>

<p>testFn1 _ = 1</p>

<p>testFn2 (<em>, </em>) = 2</p>

<p>tettFn3 (u, _) = 3</p>

<p>这3个函数会导致表达式(1 + 1, 2 + 2)进行<strong>不同层次</strong>的求值。</p>

<p><br/></p>

<h2><strong>seq</strong></h2>

<p>为了控制求值程度，</p>

<p>GHC内置了seq函数。</p>

<p><br/></p>

<p>> :t seq</p>

<p>> seq :: a -> b -> b</p>

<p><br/></p>

<p>它表示，<strong>在结果求值为WHNF之前</strong>，</p>

<p><strong>会先将seq的第一个参数求值为WHNF</strong>。</p>

<p><br/></p>

<p>例如：</p>

<p>u = 1</p>

<p>v = (u, u)</p>

<p><br/></p>

<p>x = 1</p>

<p>y = seq x (x, x)</p>

<p><br/></p>

<p>> :sprint u</p>

<p>> u = _</p>

<p>> :sprint v</p>

<p>> v = _</p>

<p><br/></p>

<p>> :sprint x</p>

<p>> x = _</p>

<p>> :sprint y</p>

<p>> y = _</p>

<p><br/></p>

<p>我们定义一个函数，用来把参数求值WHNF，</p>

<p>> let whnf (<em>, </em>) = ()</p>

<p><br/></p>

<p>则，</p>

<p>> whnf v</p>

<p>> ()</p>

<p>> whnf y</p>

<p>> ()</p>

<p><br/></p>

<p>> :sprint u</p>

<p>> u = _</p>

<p>> :sprint v</p>

<p>> v = (<em>, </em>)</p>

<p><br/></p>

<p>> :sprint x</p>

<p>> x = 1</p>

<p>> :sprint y</p>

<p>> y = (1, 1)</p>

<p><br/></p>

<p>使用seq控制求值深度，</p>

<p>可以防止创建过多的thunk。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>当我们在REPL中输入一个表达式时，</p>

<p>实际上调用了print函数，</p>

<p>它会对表达式完全求值。</p>

<p><br/></p>

<p>因此，表达式求值的层次问题，</p>

<p><strong>是很难从REPL中看出来的</strong>。</p>

<p><br/></p>

<p>另一方面，WHNF将求值过程分成了一系列节点，</p>

<p>能清晰的刻画求值程度，</p>

<p>这可能是我们学习Haskell入门的起点吧。</p>

<p><br/></p>

<p>参考：</p>

<p><a href="">Haskell/Denotational semantics</a></p>

<p><a href="https://en.wikibooks.org/wiki/Haskell/Laziness">Haskell/Laziness</a></p>

<p><a href="http://stackoverflow.com/questions/6872898/haskell-what-is-weak-head-normal-form">Haskell: What is Weak Head Normal Form?</a></p>

<p><a href="http://book.douban.com/subject/24294415/">Parallel and Concurrent Programming in Haskell</a></p>

<p><a href="https://hackhands.com/lazy-evaluation-works-haskell/">How Lazy Evaluation Works in Haskell</a></p>

<p><a href="http://www.vex.net/~trebla/haskell/lazy.xhtml">Lazy Evaluation of Haskell</a></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/28">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/26">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
	<h1>Categories</h1>
	<ul id="categories">
		<li class='category'><a href='/blog/categories/design/'>design (7)</a></li>
<li class='category'><a href='/blog/categories/haskell/'>haskell (6)</a></li>
<li class='category'><a href='/blog/categories/lisp/'>lisp (17)</a></li>
<li class='category'><a href='/blog/categories/logic/'>logic (2)</a></li>
<li class='category'><a href='/blog/categories/mind/'>mind (24)</a></li>
<li class='category'><a href='/blog/categories/software/'>software (12)</a></li>

	</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/01/26/less-is-more/">多做不如少做，不做不如去做</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/21/the-rhythm-of-the-development/">软件开发的节奏</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/18/the-fourth-level/">第四重境界</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/11/monad-in-hask-category/">Hask范畴上的Monad</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/22/grow-up-positively/">积极成长</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/01/defend-the-advantage/">守住天赋</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/25/fanatic-for-cleanliness-on-solving-problems/">问题洁癖</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/23/introduction-to-mathematical-logic/">数理逻辑定义汇总</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/08/demonstration-and-intuition/">论证与直觉</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/30/preparation/">先后之分</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - thzt -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
