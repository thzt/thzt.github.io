
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>何幻</title>
  <meta name="author" content="thzt">

  
  <meta name="description" content="自从Scheme引入词法作用域以来， 越来越多的编程语言，加入了这个特性。 函数调用时， 所引用的自由变量， 要去函数定义时的环境中去查找， 而不是在执行环境中查找。 这对寻找自由变量到底在哪定义， 是很方便的。 可是， 词法作用域到底有什么好的， 又是怎样实现的呢？ 这还要从环境说起。 &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="https://thzt.github.io/posts/21/" />
  <link type="favicon" rel="shortcut icon" href="/favicon.ico" />
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css" />
  <link href="/atom.xml" rel="alternate" title="何幻" type="application/atom+xml" />
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.aspnetcdn.com/ajax/jQuery/jquery-1.9.1.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.useso.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.useso.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">何幻</a></h1>
  
    <h2>Programming is about ideas, languages are just a way to express them.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="https://www.google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="sitesearch" value="thzt.github.io">
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
	<li><a href="/">Newest</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/08/15/implementation-of-lexical-scope/">词法作用域是怎样实现的</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-08-15T00:00:00+08:00'><span class='date'><span class='date-month'>Aug</span> <span class='date-day'>15</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>自从Scheme引入词法作用域以来，</p>

<p>越来越多的编程语言，加入了这个特性。</p>

<p><br/></p>

<p>函数调用时，</p>

<p>所引用的自由变量，</p>

<p>要去<strong>函数定义时的环境</strong>中去查找，</p>

<p>而不是在<strong>执行环境</strong>中查找。</p>

<p><br/></p>

<p>这对寻找自由变量到底在哪定义，</p>

<p>是很方便的。</p>

<p><br/></p>

<p>可是，</p>

<p>词法作用域到底有什么好的，</p>

<p>又是怎样实现的呢？</p>

<p><br/></p>

<p>这还要从环境说起。</p>

<p><br/></p>

<h2><strong>环境的表示</strong></h2>

<p>调用一个函数，它的形参有可能会<strong>遮挡</strong>外层的变量，</p>

<p>等函数执行完后，这个被遮挡的值还要恢复，</p>

<p>所以我们必须把要被遮挡的值存起来。</p>

<p><br/></p>

<p>我们可以用一个列表表示环境。</p>

<p><br/></p>

<p>(</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(x 3)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(x 1) (y 2)]</p>

<p>)</p>

<p><br/></p>

<p>它表示一个环境，每个元素称为一个<strong>frame</strong>，</p>

<p>例如，这个环境包含了两个frame，</p>

<p>frame[(x 3)]中的x，遮挡了frame[(x 1) (y 2)]中的x。</p>

<p><br/></p>

<p><strong>frame是用来表示形参和实参的绑定关系的</strong>，</p>

<p><strong>整个环境用来表示调用栈</strong>。</p>

<p><br/></p>

<p>当调用函数时，会创建一个新的frame，</p>

<p>例如，[(x 4) (y 5) (z 6)]</p>

<p>并把frame放到环境顶端。</p>

<p><br/></p>

<p>(</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(x 4) (y 5) (z 6)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(x 3)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(x 1) (y 2)]</p>

<p>)</p>

<p><br/></p>

<p>函数执行完后，环境要恢复成以前的样子，</p>

<p><br/></p>

<p>(</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(x 3)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(x 1) (y 2)]</p>

<p>)</p>

<p><br/></p>

<h2><strong>动态作用域：top-level变量</strong></h2>

<p>Emacs Lisp 24.1之前，还是动态作用域的，</p>

<p>之后可以选择性的使用，只需要设置buffer-local变量，</p>

<p>lexical-binding不为nil即可。</p>

<p><br/></p>

<p>我们来看看动态作用域到底带来了哪些麻烦。</p>

<p><br/></p>

<p>环境：()</p>

<p><br/></p>

<p>(define a 1)</p>

<p><br/></p>

<p>环境：(</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(a 1)]</p>

<p>)</p>

<p><br/></p>

<p>(define (fn x)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(+ x a))</p>

<p><br/></p>

<p>环境：(</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(a 1) (fn #&lt;procedure&gt;)]</p>

<p>)</p>

<p><br/></p>

<p>注意，</p>

<p><strong>定义并不增加frame，而是改变当前frame。</strong></p>

<p><br/></p>

<p>(fn 2)</p>

<p>=> (+ x a)</p>

<p><br/></p>

<p><strong>调用函数了，在环境中增加一个frame，</strong></p>

<p>环境：(</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(x 2)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(a 1) (fn #&lt;procedure&gt;)]</p>

<p>)</p>

<p><br/></p>

<p>在环境中，找到了x的值是2，a的值是1，</p>

<p>因此，(+ x a) => 3</p>

<p><br/></p>

<p>函数返回后，</p>

<p>环境：(</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(a 1) (fn #&lt;procedure&gt;)]</p>

<p>)</p>

<p><br/></p>

<h2><strong>动态作用域：被遮挡的top-level变量</strong></h2>

<p>环境：(</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(a 1) (fn #&lt;procedure&gt;)]</p>

<p>)</p>

<p><br/></p>

<p>(define (gn a)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(fn 2))</p>

<p><br/></p>

<p>环境：(</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(a 1) (fn #&lt;procedure&gt;) (gn #&lt;procedure&gt;)]</p>

<p>)</p>

<p><br/></p>

<p>(gn 3)</p>

<p>=> (fn 2)</p>

<p><br/></p>

<p>环境：(</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(a 3)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(a 1) (fn #&lt;procedure&gt;) (gn #&lt;procedure&gt;)]</p>

<p>)</p>

<p><br/></p>

<p>(gn 3)</p>

<p>=> (fn 2)</p>

<p>=> (+ x a)</p>

<p><br/></p>

<p>环境：(</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(x 2)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(a 3)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(a 1) (fn #&lt;procedure&gt;) (gn #&lt;procedure&gt;)]</p>

<p>)</p>

<p><br/></p>

<p>在环境中，找到了x的值是2，a的值是3，</p>

<p>因此，(+ x a) => 5</p>

<p><br/></p>

<p>(fn 2)调用结束后，</p>

<p>环境：(</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(a 3)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(a 1) (fn #&lt;procedure&gt;) (gn #&lt;procedure&gt;)]</p>

<p>)</p>

<p><br/></p>

<p>(gn 3)调用结束后，</p>

<p>环境：(</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(a 1) (fn #&lt;procedure&gt;) (gn #&lt;procedure&gt;)]</p>

<p>)</p>

<p><br/></p>

<h2><strong>动态作用域：意料之外</strong></h2>

<p>在使用动态作用域时，我们发现，</p>

<p>(fn 2)的值，是根据它被使用的位置决定的，</p>

<p><strong>函数中的自由变量a，在不同的执行环境中，可能有不同的值。</strong></p>

<p><br/></p>

<p>这样，我们就总要注意，</p>

<p>不要<strong>意外遮挡</strong>了(fn 2)中的a。</p>

<p><br/></p>

<p>但是，fn如果是别人写的呢？</p>

<p>我们并不知道fn中的有一个名字为a的变量不能被遮挡。</p>

<p><br/></p>

<p>这也对fn的实现者提出了挑战，</p>

<p>不能写带有自由变量的函数，否则这个自由变量的值，</p>

<p>随着函数调用位置的不同是不同的。</p>

<p><br/></p>

<p>此外，<strong>跟踪一个自由变量的值</strong>，</p>

<p>也是很麻烦，我们必须把调用栈写出来，</p>

<p>或者在脑子里记住调用顺序。</p>

<p><br/></p>

<p>这对较大规模的工程来说，是非常耗时的。</p>

<p><br/></p>

<h2><strong>词法作用域：被遮挡的top-level变量</strong></h2>

<p>词法作用域的环境变化规则是不同的，</p>

<p>假如函数调用前的环境是#<env>，</p>

<p><strong>（1）函数调用时，frame要添加到该函数定义时的环境#<env-fn>中去，</strong></p>

<p><strong>（2）函数返回后，整个环境要恢复成调用函数之前的环境#<env>。</strong></p>

<p><br/></p>

<p>第（1）点是为了保证自由变量在函数定义时的环境中查找。</p>

<p>第（2）点是因为#<env>和#<env-fn>通常是不同的。</p>

<p><br/></p>

<p>环境#<env-fn>：()</p>

<p><br/></p>

<p>(define a 1)</p>

<p><br/></p>

<p>环境#<env-fn>：(</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(a 1)]</p>

<p>)</p>

<p><br/></p>

<p>(define (fn x)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(+ x a))</p>

<p><br/></p>

<p>环境#<env-fn>：(</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(a 1) (fn #&lt;procedure&gt;)]</p>

<p>)</p>

<p><br/></p>

<p>(define (gn a)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(fn 2))</p>

<p><br/></p>

<p>环境#<env-fn>：(</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(a 1) (fn #&lt;procedure&gt;) (gn #&lt;procedure&gt;)]</p>

<p>)</p>

<p><br/></p>

<p>(gn 3)</p>

<p>=> (fn 2)</p>

<p><br/></p>

<p>环境#<env>：(</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(a 3)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(a 1) (fn #&lt;procedure&gt;) (gn #&lt;procedure&gt;)]</p>

<p>)</p>

<p><br/></p>

<p>(gn 3)</p>

<p>=> (fn 2)</p>

<p>=> (+ x a)</p>

<p><br/></p>

<p>注意，这里fn定义时的环境是，</p>

<p>环境#<env-fn>：(</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(a 1) (fn #&lt;procedure&gt;) (gn #&lt;procedure&gt;)]</p>

<p>)</p>

<p><strong>并且frame是最后被修改的状态</strong>。</p>

<p><br/></p>

<p>所以调用fn后，</p>

<p>环境#<env-fn-extended>：(</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(x 2)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(a 1) (fn #&lt;procedure&gt;) (gn #&lt;procedure&gt;)]</p>

<p>)</p>

<p><br/></p>

<p>因此，(+ x a) => 3</p>

<p><br/></p>

<p>(fn 2)调用结束后，<strong>要恢复成调用之前环境，</strong></p>

<p>环境#<env>：(</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(a 3)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(a 1) (fn #&lt;procedure&gt;) (gn #&lt;procedure&gt;)]</p>

<p>)</p>

<p><br/></p>

<p>(gn 3)调用结束后，</p>

<p>环境#<env-fn>：(</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;[(a 1) (fn #&lt;procedure&gt;) (gn #&lt;procedure&gt;)]</p>

<p>)</p>

<p><br/></p>

<h2><strong>词法作用域：实现方式</strong></h2>

<p>怎样实现词法作用域呢？</p>

<p>这里的关键在于拿到函数定义时的环境。</p>

<p><br/></p>

<p><strong>最好把函数的形参列表，函数体，和定义时的环境打包成一个对象，</strong></p>

<p>(define-record-type closure</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(fields param body env))</p>

<p><br/></p>

<p>这个打包好的对象，就称为“<strong>闭包</strong>”。</p>

<p><br/></p>

<p>(define (eval-lambda exp env)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(display &ldquo;eval-lambda\n&rdquo;)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(let ((param (caadr exp))</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(body (caddr exp)))</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(make-closure param body env)))</p>

<p><br/></p>

<p>当调用一个函数时，</p>

<p>我们先将定义时的环境提取出来，</p>

<p>然后用形参与实参的绑定关系构成一个frame来扩展它，</p>

<p>最后让函数体在这个扩展后的环境中执行即可。</p>

<p><br/></p>

<p>(define (eval-function-call-list exp env)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(display &ldquo;eval-function-call-list\n&rdquo;)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(let* ((closure (eval-exp (car exp) env))</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(arg (eval-exp (cadr exp) env))</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(body (closure-body closure))</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<strong>lexical-env</strong> (closure-env closure))</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(param (closure-param closure))</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(frame (create-frame)))</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(extend-frame frame param arg)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(let ((executing-env (extend-env <strong>lexical-env</strong> frame)))</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(eval-exp body executing-env))))</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p>要理解一个概念，</p>

<p>只从使用者的角度来看，</p>

<p>是不够的。</p>

<p><br/></p>

<p><strong>我们还要学会切换角色，</strong></p>

<p>从实现者的角度来看。</p>

<p><br/></p>

<p>当然，实现的方式并不是唯一的，</p>

<p>考虑不同的实现，也能增广我们的见闻。</p>

<p><br/></p>

<p>参考：</p>

<p><a href="https://github.com/thzt/scheme-interpreter/tree/master/lexical-scope">源码</a></p>

<p><a href="https://github.com/ultimate-lambda/book-reviews/wiki/The-Structure-And-Interpretation-of-Computer-Programs">The Structure And Interpretation of Computer Programs</a></p>

<p><a href="https://github.com/ultimate-lambda/book-reviews/wiki/Essentials-of-Programming-Languages">Essentials of Programming Languages</a></p>

<p><a href="https://github.com/ultimate-lambda/book-reviews/wiki/Concepts-in-Programming-Languages">Concepts in Programming Languages</a></p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/22">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/20">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
	<h1>Categories</h1>
	<ul id="categories">
		<li class='category'><a href='/blog/categories/design/'>design (7)</a></li>
<li class='category'><a href='/blog/categories/haskell/'>haskell (6)</a></li>
<li class='category'><a href='/blog/categories/javascript/'>javascript (1)</a></li>
<li class='category'><a href='/blog/categories/lisp/'>lisp (16)</a></li>
<li class='category'><a href='/blog/categories/logic/'>logic (2)</a></li>
<li class='category'><a href='/blog/categories/mind/'>mind (24)</a></li>
<li class='category'><a href='/blog/categories/software/'>software (12)</a></li>

	</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/01/26/less-is-more/">多做不如少做，不做不如去做</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/21/the-rhythm-of-the-development/">软件开发的节奏</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/18/the-fourth-level/">第四重境界</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/01/11/monad-in-hask-category/">Hask范畴上的Monad</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/22/grow-up-positively/">积极成长</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/12/01/defend-the-advantage/">守住天赋</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/25/fanatic-for-cleanliness-on-solving-problems/">问题洁癖</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/23/introduction-to-mathematical-logic/">数理逻辑定义汇总</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/11/08/demonstration-and-intuition/">论证与直觉</a>
      </li>
    
      <li class="post">
        <a href="/blog/2015/10/30/preparation/">先后之分</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - thzt -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
