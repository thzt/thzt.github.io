
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>何幻</title>
  <meta name="author" content="thzt">

  
  <meta name="description" content="作用域 作用域，是自由变量的查找规则。 如果变量具有词法作用域， 语言实现会相继到更外层的词法范围内查找绑定值。 如果变量具有动态作用域， 语言实现会回溯到更早的嵌套调用中查找绑定值。 词法作用域 (define test-lexical-binding &nbsp;&nbsp;&nbsp;& &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="https://thzt.github.io/posts/75/" />
  <link type="favicon" rel="shortcut icon" href="/favicon.ico" />
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css" />
  <link href="/atom.xml" rel="alternate" title="何幻" type="application/atom+xml" />
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.aspnetcdn.com/ajax/jQuery/jquery-1.9.1.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="/javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">何幻</a></h1>
  
    <h2>Programming is about ideas, languages are just a way to express them.</h2>
  
</hgroup>


<script>
var _hmt = _hmt || [];
(function() {
	var hm = document.createElement("script");
	hm.src = "//hm.baidu.com/hm.js?33605c59a8749f3e0404d9f438b66667";
	var s = document.getElementsByTagName("script")[0]; 
	s.parentNode.insertBefore(hm, s);
})();
</script>
</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<ul class="main-navigation">
	<li><a href="/">Newest</a></li>
	<li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2015/03/19/closures-are-objects/">闭包就是对象</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2015-03-19T00:00:00+08:00'><span class='date'><span class='date-month'>Mar</span> <span class='date-day'>19</span><span class='date-suffix'>th</span>, <span class='date-year'>2015</span></span> <span class='time'>12:00 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><h2><strong>作用域</strong></h2>

<p>作用域，是自由变量的<strong>查找</strong>规则。</p>

<p><br/></p>

<p>如果变量具有词法作用域，</p>

<p>语言实现会相继到<strong>更外层的词法范围</strong>内查找绑定值。</p>

<p><br/></p>

<p>如果变量具有动态作用域，</p>

<p>语言实现会回溯到<strong>更早的嵌套调用</strong>中查找绑定值。</p>

<p><br/></p>

<h2><strong>词法作用域</strong></h2>

<p>(define test-lexical-binding</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(<strong>let</strong> [(x 1)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(lambda (y) (+ x y))))</p>

<p><br/></p>

<p>(test-lexical-binding 2)</p>

<p>=> 3</p>

<p><br/></p>

<p>其中，<strong>let</strong>表达式返回了一个函数，作为test-lexical-binding的值。</p>

<p>根据函数调用规则，我们知道，</p>

<p>(test-lexical-binding 2)</p>

<p>-> ((lambda (y) (+ x y)) 2)</p>

<p>-> (+ x 2)</p>

<p>变量x是自由变量。</p>

<p><br/></p>

<p>如果x具有词法作用域，</p>

<p>则x的值，就是x所在函数，在定义时，外层作用域的值。</p>

<p>(lambda (y) (+ x y))的外层是let表达式，</p>

<p>(let [(x 1)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&hellip;)</p>

<p><br/></p>

<p>因此，x => 1，(+ x 2) => 3</p>

<p><br/></p>

<h2><strong>动态作用域</strong></h2>

<p>(define parameter-object</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(<strong>make-parameter</strong> 1))</p>

<p><br/></p>

<p>(define (test-dynamic-binding)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(parameter-object))</p>

<p><br/></p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;</p>

<p>(<strong>parameterize</strong> [(parameter-object 2)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(test-dynamic-binding))</p>

<p>=> 2</p>

<p><br/></p>

<p>(test-dynamic-binding)</p>

<p>=> 1</p>

<p><br/></p>

<p>其中，(make-parameter 1)返回一个包含值1的参数对象<strong>#&lt;parameter object&gt;</strong>。</p>

<p>参数对象是一个<strong>无参函数</strong>，调用后会得到它当前状态的包含值。</p>

<p>(parameter-object)的值取决于参数对象所处的动态作用域环境。</p>

<p><br/></p>

<p>我们可以使用parameterize来更改参数对象的包含值，</p>

<p>并且parameterize表达式内部会在新的动态作用域环境中求值。</p>

<p><br/></p>

<p>(<strong>parameterize</strong> [(parameter-object 2)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(test-dynamic-binding))</p>

<p>-> (test-dynamic-binding)</p>

<p>-> (parameter-object)</p>

<p><br/></p>

<p>(parameter-object)要查找调用过程中最近的绑定值，</p>

<p>为了查找调用过程中最近的绑定，我们沿着刚才的推导向上找，</p>

<p>找到了parameterize对它的更改，值为2。</p>

<p>所以，</p>

<p>(<strong>parameterize</strong> [(parameter-object 2)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(test-dynamic-binding))</p>

<p>=> 2</p>

<p><br/></p>

<p>而最后的直接调用(test-dynamic-binding) ，</p>

<p>调用过程中最近的绑定是对参数对象parameter-object的定义，</p>

<p>(define parameter-object</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(<strong>make-parameter</strong> 1))</p>

<p>所以，(test-dynamic-binding) => 1</p>

<p><br/></p>

<h2><strong>词法闭包</strong></h2>

<p>如果变量具有动态作用域，我们就要一直<strong>记着函数的调用过程</strong>。</p>

<p>这在复杂的程序中，是很困难又容易出错的事情。</p>

<p>因此，Scheme中的变量，默认具有词法作用域。</p>

<p><br/></p>

<p>词法作用域，保存了变量定义时的<strong>环境</strong>。</p>

<p>起到了<strong>封闭和隔离</strong>的作用。</p>

<p><br/></p>

<p>例如：</p>

<p>(define-values (get-value set-value!)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(<strong>let</strong> [(field 0)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(values (<strong>lambda</strong> () field)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<strong>lambda</strong> (new-value) (set! field new-value)))))</p>

<p><br/></p>

<p>(get-value)</p>

<p>=> 0</p>

<p><br/></p>

<p>(set-value! 1)</p>

<p><br/></p>

<p>(get-value)</p>

<p>=> 1</p>

<p><br/></p>

<p>其中，<strong>values</strong>表达式用来同时返回多值，而<strong>define-values</strong>用来定义多值。</p>

<p><br/></p>

<p>get-value和set-value!函数分别用来读取和修改词法作用域中的变量field。</p>

<p>field对于get-value和set-value!来说是<strong>共享的</strong>，</p>

<p>而其它任何函数都无法修改和访问它。</p>

<p><br/></p>

<p>正因为有这样的封闭性，我们将函数连同定义时的环境一起，称为<strong>闭包</strong>。</p>

<p><br/></p>

<h2><strong>对象</strong></h2>

<p>熟悉面向对象编程的人们，可能会清晰的认识到。</p>

<p>对象同样也是封闭和隔离了它包含的字段。</p>

<p>因此，<strong>在这种封装意义上来说，闭包就是对象</strong>。</p>

<p><br/></p>

<p>那么面向对象语言中的其它概念，是否也有相似的对应关系呢？</p>

<p>有的。</p>

<p><br/></p>

<p>例如：</p>

<p>(define create-object</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(<strong>lambda</strong> (init)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<strong>let</strong> [(field init)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(values (<strong>lambda</strong> () field)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<strong>lambda</strong> (new-value) (set! field new-value))))))</p>

<p><br/></p>

<p>(define-values (get-value set-value!)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(create-object 1))</p>

<p><br/></p>

<p>(get-value)</p>

<p>=> 1</p>

<p><br/></p>

<p>(set-value! 2)</p>

<p><br/></p>

<p>(get-value)</p>

<p>=> 2</p>

<p><br/></p>

<p>我们定义了个函数create-object，它可以用来生成对象。</p>

<p>相当于一个<strong>对象工厂</strong>，面向对象编程中与之对应的概念就是<strong>“类”</strong>。</p>

<p><br/></p>

<p>例如：</p>

<p>(define-values create-object</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(<strong>let</strong> [(static 1)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<strong>lambda</strong> (x)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<strong>let</strong> [(field x)]</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(values (<strong>lambda</strong> () (+ static field))</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<strong>lambda</strong> (new-value) (set! field new-value)))))</p>

<p><br/></p>

<p>最外层的let表达式返回了一个函数create-object，</p>

<p>我们来使用create-object创建两个对象。</p>

<p><br/></p>

<p>(define-values (get-value1 set-value1!)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(create-object 2))</p>

<p><br/></p>

<p>(get-value1)</p>

<p>=> 3</p>

<p><br/></p>

<p>(set-value1 3)</p>

<p><br/></p>

<p>(get-value1)</p>

<p>=> 4</p>

<p><br/></p>

<p>(define-values (get-value2 set-value2!)</p>

<p>&nbsp;&nbsp;&nbsp;&nbsp;(create-object 3))</p>

<p><br/></p>

<p>(get-value2)</p>

<p>=> 4</p>

<p><br/></p>

<p>(set-value1 4)</p>

<p><br/></p>

<p>(get-value1)</p>

<p>=> 5</p>

<p><br/></p>

<p>结果，最外层let表达式中的变量static，可以同时被两个对象访问。</p>

<p>在面向对象编程中，与之对应的概念就是<strong>“类的静态变量”</strong>。</p>

<p><br/></p>

<h2><strong>思想比手段更重要</strong></h2>

<p>我们看到[let返回lambda]，就是一个“对象”，</p>

<p>[lambda返回[let返回lambda]]，就是一个“类”，</p>

<p>[let返回[lambda返回[let返回lambda]]]，就为类增加了“静态变量”。</p>

<p><br/></p>

<p>这是多么简洁而有力的结论呀。</p>

<p>出自——《Let Over Lambda》2008年</p>

<p><br/></p>

<p>我们想到，</p>

<p><strong>闭包和对象，只是用不同的方法实现了封装</strong>。</p>

<p>而这种封装思想，才是更值得关注的。</p>

<p><br/></p>

<p>编程范型之争愈演愈烈，</p>

<p>函数式和面向对象之间似乎水火不容，</p>

<p>我们可不要在讨论手段的同时，偏废了思想。</p>

<p><br/></p>

<h2><strong>结语</strong></h2>

<p><br/></p>

<p>封装，具有深刻的内涵，</p>

<p>它有几层含义，表达了很多与编程范型无关的思想，</p>

<p>“<a href="https://thzt.github.io/blog/2015/01/29/encapsulation/">封装的内涵</a>”和大家一起详细探讨了这些内容。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/76">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
    <a class="next" href="/posts/74">Newer &rarr;</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
	<h1>Categories</h1>
	<ul id="categories">
		<li class='category'><a href='/blog/categories/design/'>design (14)</a></li>
<li class='category'><a href='/blog/categories/haskell/'>haskell (6)</a></li>
<li class='category'><a href='/blog/categories/lisp/'>lisp (17)</a></li>
<li class='category'><a href='/blog/categories/logic/'>logic (4)</a></li>
<li class='category'><a href='/blog/categories/math/'>math (5)</a></li>
<li class='category'><a href='/blog/categories/mind/'>mind (37)</a></li>
<li class='category'><a href='/blog/categories/software/'>software (12)</a></li>

	</ul>
</section>
<section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2016/09/12/the-secrets-of-decision-making/">决策的秘密</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/09/07/the-bias-of-the-author/">为什么作者无法不持有偏见</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/09/03/weakness/">性格的弱点</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/24/believed-in-the-absence-of-evidence/">相信不证自明</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/18/imagination/">思路和想象力</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/13/about-topology/">拓扑学拾趣</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/05/professional-programmer/">专业程序猿的修炼指南</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/08/02/cohomology-group/">懵逼的上同调群</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/07/23/computability/">可计算性理论名词释义</a>
      </li>
    
      <li class="post">
        <a href="/blog/2016/07/18/overcome-the-limitation/">挑战极限</a>
      </li>
    
  </ul>
</section>

<section>
	<h1>GitHub Repos</h1>
	
	
    <ul>
        <li><a href="https://github.com/thzt">@thzt</a> on GitHub</li>
    </ul>
	
	
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2016 - thzt -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  











</body>
</html>
